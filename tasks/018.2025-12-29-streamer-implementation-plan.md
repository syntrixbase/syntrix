# Streamer Implementation Plan

**Date:** December 29, 2025
**Status:** Ready for Implementation
**Depends On:** Task 016 (Puller Service)

## 1. Overview

This document is the **execution plan** for implementing the Streamer service. For detailed design decisions, data structures, and algorithms, refer to the design documents listed below.

### 1.1 Design Documents

| Document | Content |
|----------|---------|
| [000.overview.md](../docs/design/server/streamer/000.overview.md) | Service overview, goals, non-goals |
| [001.architecture.md](../docs/design/server/streamer/001.architecture.md) | Component architecture, interfaces, threading model |
| [002.subscription.md](../docs/design/server/streamer/002.subscription.md) | Subscription lifecycle, index, TTL, quotas |
| [003.matching.md](../docs/design/server/streamer/003.matching.md) | Bloom filter + CEL two-phase matching |
| [004.routing.md](../docs/design/server/streamer/004.routing.md) | Event routing and partitioning |
| [005.reliability.md](../docs/design/server/streamer/005.reliability.md) | Fault tolerance, recovery, deduplication |
| [006.observability.md](../docs/design/server/streamer/006.observability.md) | Metrics, logging, health checks |
| [007.distributed-considerations.md](../docs/design/server/streamer/007.distributed-considerations.md) | Multi-instance scaling, HA, security |
| [Puller Architecture](../docs/design/server/puller/001.architecture.md) | Event source (gRPC streaming) |

### 1.2 Architecture Summary

```
MongoDB → Puller (gRPC) → Streamer → JetStream → Gateway → Clients
                              │
                    ┌─────────┴─────────┐
                    │ Subscription Index │
                    │ Bloom + CEL Match  │
                    └────────────────────┘
```

**Key Design Decisions:**
- Streamer consumes from Puller via gRPC streaming (not direct MongoDB)
- CEL evaluation happens in Streamer (reduces Gateway traffic by ~90%)
- Events published to Gateway via NATS JetStream
- Subscriptions are ephemeral with TTL-based expiry

---

## 2. Prerequisites

### 2.1 Hard Dependencies

| Dependency | Status | Blocker? |
|------------|--------|----------|
| Puller Service (Task 016) | **Required** | Yes - must be running before Streamer can consume events |
| NATS JetStream | Required | Yes - for Gateway delivery |
| etcd or MongoDB | Required | For subscription persistence |

### 2.2 Pre-Implementation Checklist

- [ ] Puller service is deployed and functional
- [ ] NATS JetStream cluster is available
- [ ] Shared event schema defined in `internal/events/types.go` *(exists)*
- [ ] Gateway team aligned on integration points
- [ ] **Bloom filter library added to go.mod** *(missing - see §2.3)*

### 2.3 Missing Dependencies

**Bloom Filter Library** - Not currently in go.mod. Must add before Phase 4:

```bash
# Recommended option
go get github.com/bits-and-blooms/bloom/v3
```

Alternative: Implement using Go standard library bit operations with existing `blake3` hash library.

---

## 3. Implementation Phases

### Phase 1: Foundation (3 days)

**Goal:** Create package structure, interfaces, and basic server.

**Deliverables:**
- [ ] `internal/streamer/` package structure
- [ ] Core interfaces defined (see [001.architecture.md](../docs/design/server/streamer/001.architecture.md))
- [ ] HTTP server skeleton with `/health` endpoint
- [ ] Configuration loading

**Directory Structure:**
```
internal/streamer/
├── server.go           # HTTP server, main entry
├── config.go           # Configuration
├── types.go            # Core types (Subscription, MatchResult, etc.)
├── index/              # Subscription index
├── matcher/            # Bloom + CEL matching
├── consumer/           # Puller gRPC consumer
├── publisher/          # JetStream publisher
└── observability/      # Metrics, health
```

**Acceptance Criteria:**
- `make build` succeeds
- `/health` returns 200
- Configuration loads from YAML

---

### Phase 2: Subscription Management (4 days)

**Goal:** Implement subscription registration, index, and TTL expiry.

**Deliverables:**
- [ ] `SubscriptionIndex` with CRUD operations
- [ ] Control Plane API endpoints (see [002.subscription.md §3](../docs/design/server/streamer/002.subscription.md))
- [ ] TTL expiry loop
- [ ] Quota enforcement
- [ ] Subscription persistence (etcd/MongoDB)

**API Endpoints:**
```
POST   /internal/v1/subscriptions           # Register
PUT    /internal/v1/subscriptions/:id/heartbeat  # Renew
DELETE /internal/v1/subscriptions/:id       # Unregister
GET    /internal/v1/subscriptions           # List (debug)
```

**Acceptance Criteria:**
- Can register/renew/unregister subscriptions
- Subscriptions expire after TTL
- Quota limits enforced
- Index survives restart (persistence)

**Tests:**
- Unit: CRUD, TTL, quota
- Integration: API endpoints
- Race: Concurrent access

---

### Phase 3: Puller Integration (3 days)

**Goal:** Consume events from Puller via gRPC streaming.

**Note:** Puller service is fully implemented in `internal/puller/`. Use `internal/puller/client/` as reference for gRPC consumer.

**Deliverables:**
- [ ] `PullerGRPCConsumer` implementation
- [ ] Progress marker persistence
- [ ] Reconnection with exponential backoff
- [ ] Deduplication cache

**Reference:** [001.architecture.md §3.3](../docs/design/server/streamer/001.architecture.md)

**Acceptance Criteria:**
- Receives events from Puller
- Reconnects automatically on disconnect
- Progress marker saved and restored
- Duplicates filtered

**Tests:**
- Unit: Event parsing, dedup logic
- Integration: Puller → Streamer flow
- Chaos: Kill Puller, verify reconnect

---

### Phase 4: Event Matching (5 days)

**Goal:** Implement two-phase matching (Bloom filter + CEL).

**Deliverables:**
- [ ] `BloomFilterManager` with per-collection filters
- [ ] `CELEvaluator` with program caching
- [ ] `MatchingEngine` (two-phase pipeline)
- [ ] Bloom filter auto-rebuild

**Reference:** [003.matching.md](../docs/design/server/streamer/003.matching.md)

**Reusable Code:**
- CEL compilation: Reference `internal/api/realtime/cel.go`
- CEL evaluation: Reference `internal/trigger/internal/evaluator/`

**Key Algorithms:**
1. **Bloom Key Extraction:** Generate keys from filter equality conditions
2. **Nested Field Handling:** Flatten `user.name` to `user.name:value`
3. **CEL Compilation:** Gateway validates, Streamer caches and executes

**Acceptance Criteria:**
- Matching latency < 10ms p99
- No false negatives
- Bloom FP rate < 1%
- CEL cache hit rate > 99%

**Tests:**
- Unit: Key extraction, Bloom operations, CEL evaluation
- Benchmark: 100k subscriptions, 10k events/sec
- Correctness: No false negatives

---

### Phase 5: JetStream Publishing (3 days)

**Goal:** Publish matched events to Gateway via NATS JetStream.

**Deliverables:**
- [ ] `JetStreamPublisher` implementation
- [ ] Subject routing: `events.{gatewayId}.{subscriptionId}`
- [ ] Batch publishing for performance
- [ ] Circuit breaker for Gateway failures

**Reference:** [001.architecture.md §3.5](../docs/design/server/streamer/001.architecture.md)

**JetStream Streams:**
```bash
# Create GATEWAY_EVENTS stream
nats stream add GATEWAY_EVENTS \
  --subjects "events.>" \
  --storage file \
  --retention limits \
  --max-age 1h \
  --replicas 3
```

**Acceptance Criteria:**
- Events published to correct subjects
- Gateway receives events
- Publish latency < 5ms p99
- Circuit breaker opens on failures

**Tests:**
- Unit: Subject routing, batching
- Integration: Streamer → JetStream → Gateway
- Chaos: Gateway down, verify circuit breaker

---

### Phase 6: Observability (2 days)

**Goal:** Implement metrics, logging, and health checks.

**Deliverables:**
- [ ] Prometheus metrics (see [006.observability.md](../docs/design/server/streamer/006.observability.md))
- [ ] Structured logging with zap
- [ ] Health endpoints (`/health/live`, `/health/ready`)
- [ ] Alert definitions

**Key Metrics:**
| Metric | Type | Description |
|--------|------|-------------|
| `streamer_subscriptions_active` | Gauge | Active subscriptions |
| `streamer_events_processed_total` | Counter | Events processed |
| `streamer_match_latency_seconds` | Histogram | Matching latency |
| `streamer_publish_latency_seconds` | Histogram | JetStream publish latency |

**Acceptance Criteria:**
- `/metrics` returns Prometheus format
- `/health/ready` reflects actual readiness
- Logs are structured JSON

---

### Phase 7: Gateway Integration (4 days)

**Goal:** Modify Gateway to use Streamer.

**Current State Analysis:**
- Gateway uses `engine.WatchCollection()` in `internal/api/realtime/server.go`
- CEL filtering exists in `internal/api/realtime/cel.go` (can be reused for validation)
- CSP code in `internal/csp/` must be preserved for rollback

**Deliverables:**

- [ ] Gateway generates persistent `gatewayId` on startup
- [ ] `StreamerClient` for registration/heartbeat
- [ ] JetStream consumer for events
- [ ] Feature flag to switch between Streamer and legacy CSP
- [ ] Heartbeat loop

**Gateway Changes:**
```
internal/api/realtime/
├── gateway.go          # New: Gateway ID, Streamer integration
├── streamer_client.go  # New: HTTP client for Streamer API
├── hub.go              # Modify: Forward events instead of CEL eval
├── server.go           # Modify: Add feature flag, keep WatchCollection() for rollback
└── cel.go              # Keep: Reuse for filter validation before registration
```

**Do NOT delete:**
- `internal/csp/` - Keep for rollback support
- `engine.WatchCollection()` - Keep as fallback path

**Acceptance Criteria:**
- Gateway registers subscriptions with Streamer
- Events flow: MongoDB → Puller → Streamer → JetStream → Gateway → Client
- Heartbeat keeps subscriptions alive
- Graceful handling of Streamer unavailability (returns error, does not crash)

**Tests:**
- Integration: Full end-to-end flow
- Load: 1000 concurrent WebSocket connections
- Chaos: Streamer restart, Gateway restart

---

### Phase 8: Testing & Hardening (3 days)

**Goal:** Comprehensive testing and production readiness.

**Deliverables:**

- [ ] Integration test suite with Docker Compose
- [ ] Performance benchmarks
- [ ] Chaos tests (node failures, network partitions)
- [ ] Security tests (CEL injection, quota bypass)
- [ ] Graceful shutdown implementation
- [ ] Documentation updates

**Test Coverage Requirements:**

| Category | Target |
|----------|--------|
| Unit test coverage | ≥ 80% |
| Integration tests | All API endpoints |
| Security tests | CEL timeout, quota limits, malformed input |
| Performance tests | 10k events/sec sustained |

**Test Environment:**
```yaml
# tests/integration/docker-compose.yml
services:
  mongodb:
    image: mongo:7.0
    command: --replSet rs0
  nats:
    image: nats:2.10-alpine
    command: "-js"
  puller:
    build: ../..
    command: puller
  streamer:
    build: ../..
    command: streamer
```

**Acceptance Criteria:**
- All tests pass
- Latency targets met (< 200ms e2e p99)
- Throughput targets met (10k events/sec)
- No memory leaks under load

---

## 4. Distributed System Considerations

These issues were identified during design review. See [007.distributed-considerations.md](../docs/design/server/streamer/007.distributed-considerations.md) for detailed solutions.

### 4.1 Multi-Instance Scaling

**Problem:** How do multiple Streamer instances share load?

**Solution:**
- All instances subscribe to same Puller gRPC stream
- Each instance maintains complete subscription index
- Events are matched redundantly (acceptable for correctness)
- JetStream handles deduplication on publish

**Alternative (if redundancy is too expensive):**
- Partition subscriptions by `hash(collection) % numInstances`
- Requires coordination via etcd

### 4.2 Gateway ID Persistence

**Problem:** Gateway restart generates new ID, orphaning old subscriptions.

**Solution:**
```go
// Gateway persists ID to local file or etcd
func (g *Gateway) loadOrCreateID() string {
    if id, err := os.ReadFile("/data/gateway-id"); err == nil {
        return string(id)
    }
    id := uuid.NewString()
    os.WriteFile("/data/gateway-id", []byte(id), 0644)
    return id
}
```

### 4.3 Event Ordering

**Problem:** Events for same document may arrive out of order.

**Solution:**
- Puller preserves MongoDB oplog order
- Single gRPC stream maintains order
- If using partitioned consumers, partition by `documentId`

### 4.4 CEL Security

**Problem:** Malicious CEL expressions could cause resource exhaustion.

**Solution:**
```go
// Limit CEL evaluation time
ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
defer cancel()
result, _, err := program.ContextEval(ctx, vars)
```

Also limit:
- Expression complexity (max AST depth)
- Number of filters per subscription

### 4.5 Startup Order

**Problem:** Circular dependency between Gateway and Streamer.

**Solution:**
1. Streamer starts first, accepts registrations
2. Gateway starts, registers subscriptions
3. If Streamer unavailable, Gateway operates in degraded mode (no realtime)

---

## 5. Risk Assessment

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Puller not ready | Blocks all work | Medium | Mock Puller for development |
| Performance targets missed | Delay release | Low | Profile early, benchmark often |
| Gateway integration complex | Extra 1-2 weeks | Medium | Define API contract early |
| Bloom filter FP rate high | Increased CPU | Low | Tune parameters, auto-rebuild |

---

## 6. Timeline

| Phase | Duration | Dependencies | Parallelizable |
|-------|----------|--------------|----------------|
| Phase 1: Foundation | 3 days | None | No |
| Phase 2: Subscription Management | 4 days | Phase 1 | Yes (with Phase 3) |
| Phase 3: Puller Integration | 3 days | Phase 1, Puller running | Yes (with Phase 2) |
| Phase 4: Event Matching | 5 days | Phase 2, 3 | No |
| Phase 5: JetStream Publishing | 3 days | Phase 4, NATS available | No |
| Phase 6: Observability | 2 days | Phase 1 | Yes (can start early) |
| Phase 7: Gateway Integration | 4 days | Phase 5, 6 | No |
| Phase 8: Testing & Hardening | 3 days | All phases | No |

**Sequential Path:** 3 + 4 + 5 + 3 + 2 + 4 + 3 = 24 days

**Optimized Path (with parallelization):**
```
Week 1: Phase 1 (3d)
Week 2: Phase 2 + Phase 3 in parallel (4d), Phase 6 starts
Week 3: Phase 4 (5d)
Week 4: Phase 5 (3d), Phase 6 completes
Week 5: Phase 7 (4d)
Week 6: Phase 8 (3d)
```

**Total:** ~22 working days (~4-5 weeks) with parallelization

**Critical Path:** Phase 1 → Phase 2/3 → Phase 4 → Phase 5 → Phase 7 → Phase 8

---

## 7. Migration Strategy

### 7.1 Deployment Order

1. Deploy Puller service (if not already running)
2. Deploy Streamer service
3. Deploy updated Gateway with feature flag `USE_STREAMER=false`
4. Enable Streamer integration: `USE_STREAMER=true`
5. Monitor for 24-48 hours
6. Remove old CSP code path

### 7.2 Rollback Plan

If issues are detected after enabling Streamer:

1. Set `USE_STREAMER=false` on Gateway (instant rollback)
2. Gateway falls back to direct MongoDB change streams
3. Investigate and fix Streamer issues
4. Re-enable when ready

### 7.3 Feature Flag Implementation

```go
// Gateway configuration
type RealtimeConfig struct {
    UseStreamer     bool   `yaml:"use_streamer"`
    StreamerAddress string `yaml:"streamer_address"`
    // Fallback to legacy CSP if UseStreamer is false
}

func (g *Gateway) subscribeToChanges(collection string) {
    if g.config.UseStreamer {
        g.subscribeViaStreamer(collection)
    } else {
        g.subscribeViaCSP(collection)  // Legacy path
    }
}
```

---

## 8. Configuration Reference

See design documents for full configuration details:

- [001.architecture.md §6](../docs/design/server/streamer/001.architecture.md) - Main configuration
- [002.subscription.md §10](../docs/design/server/streamer/002.subscription.md) - Subscription config
- [003.matching.md §9](../docs/design/server/streamer/003.matching.md) - Matching config

**Minimal configuration example:**

```yaml
streamer:
  port: 8083

  puller:
    address: "puller:50051"
    consumer_id: "streamer-main"

  nats:
    urls: ["nats://nats:4222"]
    output_stream: "GATEWAY_EVENTS"

  subscription:
    default_ttl: 300s
    quota:
      max_per_gateway: 10000

  bloom:
    fp_rate: 0.01

  cel:
    evaluation_timeout: 100ms
```

---

## 9. Success Criteria

### Functional
- [ ] 10k+ active subscriptions supported
- [ ] Events matched and delivered correctly
- [ ] Subscriptions expire after TTL
- [ ] Gateway restart recovers subscriptions

### Performance
- [ ] End-to-end latency < 200ms p99
- [ ] Matching latency < 10ms p99
- [ ] Throughput ≥ 10k events/sec

### Reliability
- [ ] At-least-once delivery
- [ ] Resume from progress marker after restart
- [ ] Graceful degradation under load

### Observability
- [ ] Prometheus metrics exported
- [ ] Structured logging
- [ ] Health endpoints functional

---

## 10. References

- [Streamer Design Documents](../docs/design/server/streamer/)
- [Puller Design Documents](../docs/design/server/puller/)
- [Task 016: Puller Implementation](016.2025-12-29-change-stream-puller.md)
- [CEL Specification](https://github.com/google/cel-spec)
- [NATS JetStream Documentation](https://docs.nats.io/nats-concepts/jetstream)
