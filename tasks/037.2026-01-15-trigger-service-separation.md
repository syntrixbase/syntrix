# Trigger Service Separation

**Date:** 2026-01-15
**Status:** In Progress
**Scope:** Split trigger into evaluator and delivery services
**Depends on:** 036 (Core Pubsub Layer) - Note: Implemented without waiting for 036

## Overview

Reorganize `internal/trigger/` to separate the Evaluator and Delivery services into independent packages. This enables:
- Independent scaling of evaluator vs delivery workers
- Clearer code ownership and boundaries
- Distributed deployment configurations

Design doc: [docs/design/server/trigger/04.service_separation.md](../docs/design/server/trigger/04.service_separation.md)

---

## Current State

```
internal/trigger/
├── config/           # Shared config
├── engine/           # Mixed: TriggerEngine + TriggerFactory (creates both services)
│   ├── engine.go     # Evaluator logic
│   ├── factory.go    # Creates Engine AND Consumer
│   └── interfaces.go # TriggerEngine, TaskConsumer, TriggerFactory interfaces
├── evaluator/        # CEL condition evaluator
├── pubsub/           # Mixed: Publisher (for evaluator) + Consumer (for delivery)
├── watcher/          # Document change watcher
├── worker/           # HTTP delivery worker
├── types/            # Shared types
└── ...
```

### Problems
1. `engine/` mixes two service concerns
2. `pubsub/` splits across two services
3. `TriggerFactory` creates unrelated components
4. Hard to understand which code belongs to which service

---

## Target State

```
internal/trigger/
├── types/            # Shared types (Trigger, DeliveryTask, RetryPolicy, etc.)
│   ├── types.go
│   ├── duration.go
│   ├── defaults.go
│   └── metrics.go
│
├── config/           # Shared configuration
│   └── config.go
│
├── evaluator/        # ★ Evaluator Service
│   ├── service.go         # Service interface + implementation
│   ├── factory.go         # NewService factory
│   ├── cel/               # CEL condition evaluator
│   │   └── evaluator.go
│   ├── watcher/           # Document watcher
│   │   ├── interfaces.go
│   │   └── watcher.go
│   └── publisher.go       # TaskPublisher adapter (uses core/pubsub)
│
├── delivery/         # ★ Delivery Service
│   ├── service.go         # Service interface + implementation
│   ├── factory.go         # NewService factory
│   ├── consumer.go        # TaskConsumer adapter (uses core/pubsub)
│   └── worker/            # HTTP delivery worker
│       ├── interfaces.go
│       └── worker.go
│
├── nats.go           # NATS connection helpers (embedded/remote)
├── loader.go         # Trigger rules file loader
└── aliases.go        # Type aliases for backward compatibility
```

---

## Phase 1: Prepare Types Package

### Task 1.1: Consolidate Shared Types

**Current:** Types scattered across `types/`, `types.go`, `duration.go`

- [x] Ensure all shared types are in `internal/trigger/types/`
- [x] Move `FatalError` to types if not already there
- [x] Verify `Trigger`, `DeliveryTask`, `RetryPolicy`, `Duration` are in types
- [ ] Remove duplicate type definitions from root package

---

## Phase 2: Create Evaluator Service Package

### Task 2.1: Define Evaluator Service Interface

**File:** `internal/trigger/evaluator/service.go`

- [x] Define `Service` interface
- [x] Define `ServiceOptions` struct
- [x] Implement `service` struct

```go
package evaluator

import (
    "context"
    "github.com/syntrixbase/syntrix/internal/trigger/types"
)

// Service evaluates document changes against trigger rules and publishes matched tasks.
type Service interface {
    // LoadTriggers validates and loads trigger rules.
    LoadTriggers(triggers []*types.Trigger) error

    // Start begins watching for changes and evaluating triggers.
    // Blocks until context is cancelled.
    Start(ctx context.Context) error

    // Close releases resources.
    Close() error
}

type ServiceOptions struct {
    Database     string
    StartFromNow bool
    RulesFile    string
    StreamName   string
}
```

### Task 2.2: Create Evaluator Factory

**File:** `internal/trigger/evaluator/factory.go`

- [x] Define `Dependencies` struct
- [x] Implement `NewService(deps, opts) (Service, error)`
- [x] Wire CEL evaluator, watcher, and publisher

```go
package evaluator

import (
    "github.com/nats-io/nats.go"
    "github.com/syntrixbase/syntrix/internal/core/pubsub"
    "github.com/syntrixbase/syntrix/internal/core/storage"
    "github.com/syntrixbase/syntrix/internal/puller"
    "github.com/syntrixbase/syntrix/internal/trigger/types"
)

type Dependencies struct {
    Store   storage.DocumentStore
    Puller  puller.Service
    Nats    *nats.Conn
    Metrics types.Metrics
}

func NewService(deps Dependencies, opts ServiceOptions) (Service, error) {
    // Implementation
}
```

### Task 2.3: Move CEL Evaluator

- [x] Move `internal/trigger/evaluator/` contents to `internal/trigger/evaluator/cel/`
- [x] Update imports
- [x] Rename `celeEvaluator` to `Evaluator` (exported)

### Task 2.4: Move Watcher

- [x] Move `internal/trigger/watcher/` to `internal/trigger/evaluator/watcher/`
- [x] Update imports
- [x] Adjust interface if needed

### Task 2.5: Create TaskPublisher Adapter

**File:** `internal/trigger/evaluator/publisher.go`

- [x] Create `TaskPublisher` struct wrapping `core/pubsub.Publisher`
- [x] Implement subject building with encoding
- [x] Implement subject hashing for long keys
- [x] Maintain metrics integration

```go
package evaluator

import (
    "context"
    "github.com/syntrixbase/syntrix/internal/core/pubsub"
    "github.com/syntrixbase/syntrix/internal/trigger/types"
)

type TaskPublisher struct {
    pub        pubsub.Publisher
    streamName string
    metrics    types.Metrics
}

func NewTaskPublisher(pub pubsub.Publisher, streamName string, metrics types.Metrics) *TaskPublisher {
    return &TaskPublisher{pub: pub, streamName: streamName, metrics: metrics}
}

func (p *TaskPublisher) Publish(ctx context.Context, task *types.DeliveryTask) error {
    // Build subject, encode docKey, handle hashing
    // Marshal task and publish
}

func (p *TaskPublisher) Close() error {
    return p.pub.Close()
}
```

### Task 2.6: Implement Evaluator Service

**File:** `internal/trigger/evaluator/service.go`

- [x] Implement `service` struct with all components
- [x] Implement `LoadTriggers` with validation
- [x] Implement `Start` with watch loop and evaluation
- [x] Implement `Close` with proper cleanup

---

## Phase 3: Create Delivery Service Package

### Task 3.1: Define Delivery Service Interface

**File:** `internal/trigger/delivery/service.go`

- [x] Define `Service` interface
- [x] Define `ServiceOptions` struct
- [x] Implement `service` struct

```go
package delivery

import (
    "context"
    "time"
)

// Service consumes delivery tasks and executes HTTP webhooks.
type Service interface {
    // Start begins consuming and processing delivery tasks.
    // Blocks until context is cancelled.
    Start(ctx context.Context) error
}

type ServiceOptions struct {
    StreamName      string
    NumWorkers      int
    ChannelBufSize  int
    DrainTimeout    time.Duration
    ShutdownTimeout time.Duration
}
```

### Task 3.2: Create Delivery Factory

**File:** `internal/trigger/delivery/factory.go`

- [x] Define `Dependencies` struct
- [x] Implement `NewService(deps, opts) (Service, error)`
- [x] Wire consumer and worker

```go
package delivery

import (
    "github.com/nats-io/nats.go"
    "github.com/syntrixbase/syntrix/internal/core/identity"
    "github.com/syntrixbase/syntrix/internal/trigger/types"
)

type Dependencies struct {
    Nats    *nats.Conn
    Auth    identity.AuthN
    Secrets SecretProvider
    Metrics types.Metrics
}

func NewService(deps Dependencies, opts ServiceOptions) (Service, error) {
    // Implementation
}
```

### Task 3.3: Move HTTP Worker

- [x] Move `internal/trigger/worker/` to `internal/trigger/delivery/worker/`
- [x] Update imports
- [x] Export `HTTPWorker` as `Worker`

### Task 3.4: Create TaskConsumer Adapter

**File:** `internal/trigger/delivery/consumer.go`

- [x] Create `TaskConsumer` struct wrapping `core/pubsub.Consumer`
- [x] Implement message handler with task deserialization
- [x] Integrate with worker for HTTP delivery
- [x] Handle retry logic with `FatalError` detection
- [x] Maintain graceful shutdown semantics

```go
package delivery

import (
    "context"
    "encoding/json"

    "github.com/syntrixbase/syntrix/internal/core/pubsub"
    "github.com/syntrixbase/syntrix/internal/trigger/types"
)

type TaskConsumer struct {
    consumer pubsub.Consumer
    worker   *worker.Worker
    metrics  types.Metrics
}

func NewTaskConsumer(consumer pubsub.Consumer, w *worker.Worker, metrics types.Metrics) *TaskConsumer {
    return &TaskConsumer{consumer: consumer, worker: w, metrics: metrics}
}

func (c *TaskConsumer) Start(ctx context.Context) error {
    return c.consumer.Start(ctx, c.handleMessage)
}

func (c *TaskConsumer) handleMessage(ctx context.Context, msg pubsub.Message) error {
    var task types.DeliveryTask
    if err := json.Unmarshal(msg.Data(), &task); err != nil {
        msg.Term() // Invalid message, don't retry
        return err
    }

    err := c.worker.ProcessTask(ctx, &task)
    if err != nil {
        if types.IsFatal(err) {
            msg.Term()
        } else {
            msg.Nak()
        }
        return err
    }

    return msg.Ack()
}
```

### Task 3.5: Implement Delivery Service

**File:** `internal/trigger/delivery/service.go`

- [x] Implement `service` struct with consumer
- [x] Implement `Start` that delegates to consumer
- [ ] Add graceful shutdown coordination

---

## Phase 4: Update ServiceManager Integration

### Task 4.1: Update Manager Initialization

**File:** `internal/services/manager_init.go`

- [x] Replace `TriggerFactory` usage with separate service factories
- [x] Add `initTriggerEvaluator(ctx)` function
- [x] Add `initTriggerDelivery(ctx)` function
- [x] Update startup sequence

```go
func (m *Manager) initTriggerEvaluator(ctx context.Context) error {
    deps := evaluator.Dependencies{
        Store:   m.documentStore,
        Puller:  m.pullerService,
        Nats:    m.natsConn,
        Metrics: m.metrics,
    }

    svc, err := evaluator.NewService(deps, evaluator.ServiceOptions{
        Database:     m.cfg.Trigger.Database,
        StartFromNow: m.cfg.Trigger.StartFromNow,
        RulesFile:    m.cfg.Trigger.RulesFile,
        StreamName:   m.cfg.Trigger.StreamName,
    })
    if err != nil {
        return err
    }

    m.triggerEvaluator = svc
    return nil
}

func (m *Manager) initTriggerDelivery(ctx context.Context) error {
    deps := delivery.Dependencies{
        Nats:    m.natsConn,
        Auth:    m.auth,
        Secrets: m.secrets,
        Metrics: m.metrics,
    }

    svc, err := delivery.NewService(deps, delivery.ServiceOptions{
        StreamName: m.cfg.Trigger.StreamName,
        NumWorkers: m.cfg.Trigger.NumWorkers,
    })
    if err != nil {
        return err
    }

    m.triggerDelivery = svc
    return nil
}
```

### Task 4.2: Update Manager Lifecycle

- [x] Update `Start()` to start both services
- [x] Update `Close()` to stop both services
- [ ] Maintain proper shutdown order

### Task 4.3: Update Configuration

**File:** `internal/trigger/config/config.go`

- [x] Ensure config supports both services
- [x] Add any missing options

```go
type TriggerConfig struct {
    // Common
    StreamName string
    RulesFile  string
    NatsURL    string

    // Evaluator-specific
    Database     string
    StartFromNow bool

    // Delivery-specific
    NumWorkers      int
    ChannelBufSize  int
    DrainTimeout    time.Duration
    ShutdownTimeout time.Duration
}
```

---

## Phase 5: Backward Compatibility

### Task 5.1: Create Type Aliases

**File:** `internal/trigger/aliases.go`

- [ ] Add deprecated type aliases for migration period
- [ ] Document deprecation timeline

```go
package trigger

import (
    "github.com/syntrixbase/syntrix/internal/trigger/evaluator"
    "github.com/syntrixbase/syntrix/internal/trigger/delivery"
)

// Deprecated: Use evaluator.Service directly.
type TriggerEngine = evaluator.Service

// Deprecated: Use delivery.Service directly.
type TaskConsumer = delivery.Service
```

### Task 5.2: Update Existing Tests

- [ ] Update imports in existing tests
- [ ] Ensure all tests pass with new package structure
- [ ] Add new tests for service interfaces

---

## Phase 6: Cleanup

### Task 6.1: Remove Old Packages

- [ ] Verify all usages migrated to new packages
- [ ] Delete `internal/trigger/engine/`
- [ ] Delete `internal/trigger/pubsub/` (after Task 036 migration)
- [ ] Update all imports in affected files

### Task 6.2: Update Documentation

- [ ] Update `docs/design/server/trigger/01.architecture.md`
- [ ] Update `docs/design/server/trigger/02.interfaces.md`
- [ ] Mark `04.service_separation.md` as implemented
- [ ] Add deployment examples for distributed mode

---

## Testing Strategy

### Unit Tests

- [x] `internal/trigger/evaluator/service_test.go` - Service lifecycle, LoadTriggers
- [ ] `internal/trigger/evaluator/publisher_test.go` - Subject encoding, hashing
- [ ] `internal/trigger/delivery/service_test.go` - Service lifecycle
- [ ] `internal/trigger/delivery/consumer_test.go` - Message handling, retry logic

### Integration Tests

- [ ] Both services together with embedded NATS
- [ ] End-to-end: document change → trigger evaluation → HTTP delivery
- [ ] Graceful shutdown with in-flight messages

### Contract Tests

- [ ] Verify message format compatibility between publisher and consumer
- [ ] Test subject encoding/decoding roundtrip

---

## Acceptance Criteria

- [ ] Evaluator service can run independently
- [ ] Delivery service can run independently
- [ ] Both services can run together (standalone mode)
- [ ] All existing trigger tests pass
- [ ] New service tests pass with >80% coverage
- [ ] `make test` passes
- [ ] `make lint` passes
- [ ] Documentation updated
