# Trigger Integration Test

**Date:** 2026-01-16
**Status:** In Progress
**Scope:** Enable trigger integration test using global test environment
**Depends on:** 037 (Trigger Service Separation)

## Overview

Enable the trigger integration test (`tests/integration/trigger_test.go`) to run with the global test environment. The test should treat the service as a black box and verify the trigger workflow end-to-end.

---

## Approach

动态创建 trigger rules 文件，使用 webhookURL。

**流程：**
1. Start webhook server → get `webhookURL`
2. Create trigger rules file with `webhookURL`
3. Configure `cfg.Trigger.RulesFile`
4. Start services

---

## Changes Required

### 1. main_test.go

```go
// After webhook server starts:
triggerRulesContent := fmt.Sprintf(`
- triggerId: "integration-test-trigger"
  database: "default"
  collection: "*"
  events: ["create", "update", "delete"]
  condition: "true"
  url: "%s"
  headers:
    X-Test: "true"
`, webhookURL)

triggerRulesFile := tempDir + "/triggers.yaml"
os.WriteFile(triggerRulesFile, []byte(triggerRulesContent), 0644)

// In cfg:
cfg.Trigger = trigger_config.Config{
    NatsURL:            "nats://localhost:4222",
    StreamName:         "TRIGGERS_TEST",
    WorkerCount:        4,
    CheckpointDatabase: "default",
    RulesFile:          triggerRulesFile,
}
```

### 2. trigger_test.go

```go
func TestTriggerIntegration(t *testing.T) {
    t.Parallel()

    env := setupServiceEnv(t, "")
    defer env.Cancel()

    token := env.GetToken(t, "trigger-test-user", "user")
    collection := fmt.Sprintf("trigger_test_%d", time.Now().UnixNano())

    // Create document
    docData := map[string]interface{}{
        "id":   "test-doc",
        "name": "Test",
    }
    resp := env.MakeRequest(t, "POST", fmt.Sprintf("/api/v1/%s", collection), docData, token)
    require.Equal(t, http.StatusCreated, resp.StatusCode)

    // Wait for webhook event
    globalEnv := GetGlobalEnv()
    select {
    case eventData := <-globalEnv.WebhookEvents:
        var task DeliveryTask
        json.Unmarshal(eventData, &task)
        assert.Equal(t, "integration-test-trigger", task.TriggerID)
        assert.Equal(t, "create", task.Event)
    case <-time.After(30 * time.Second):
        t.Fatal("Timeout waiting for webhook")
    }
}
```

## Test Scenarios

### 基础场景（必须）

| 场景 | 描述 | 验证点 |
|------|------|--------|
| Create 事件 | 创建文档触发 webhook | TriggerID, Event=create, Collection, DocumentID, After 不为空, **PreIssuedToken 不为空** |
| Update 事件 | 更新文档触发 webhook | Event=update, Before 和 After 都不为空, **PreIssuedToken 不为空** |
| Delete 事件 | 删除文档触发 webhook | Event=delete, Before 不为空, After 为空, **PreIssuedToken 不为空** |

### Token 验证说明

系统在 `worker/worker.go:54-62` 生成 token：
```go
if w.auth != nil {
    token, err := w.auth.GenerateSystemToken("trigger-worker")
    task.PreIssuedToken = token
}
```

Token 放在 `DeliveryTask.PreIssuedToken` 字段中，随 JSON payload 发送给 webhook（不是 HTTP Header）。

### 进阶场景（必须）

| 场景 | 描述 | 验证点 |
|------|------|--------|
| CEL 条件过滤 | 只有满足条件的文档触发 | 满足条件的触发，不满足的不触发 |
| 多 trigger 匹配 | 一个事件匹配多个 trigger | 收到多个 webhook 调用 |
| Database 过滤 | 只有特定数据库的事件触发 | 匹配数据库触发，不匹配不触发 |
| Collection 通配符 | `users/*` 匹配子集合 | 匹配的触发，不匹配的不触发 |
| Webhook 重试 | webhook 失败后重试 | 失败后重试直到成功或达到最大次数 |
| Webhook Headers | 自定义 headers 传递 | webhook 请求包含配置的 headers |

### 决定

- **全部场景都测**
- **并发处理**：每个测试使用唯一的 collection 名称 + drain channel 避免干扰
- **文件位置**：独立的 `trigger_test.go`

---

## Trigger Rules 设计

需要配置多个 trigger 来支持所有测试场景：

```yaml
# 1. 基础 trigger - 匹配所有事件
- triggerId: "trigger-all-events"
  database: "default"
  collection: "*"
  events: ["create", "update", "delete"]
  condition: "true"
  url: "%s"

# 2. CEL 条件 trigger - 只匹配 age >= 18
- triggerId: "trigger-adult-only"
  database: "default"
  collection: "cel_test_*"
  events: ["create"]
  condition: "event.document.age >= 18"
  url: "%s"

# 3. 特定 collection trigger
- triggerId: "trigger-specific-collection"
  database: "default"
  collection: "specific_collection"
  events: ["create"]
  condition: "true"
  url: "%s"

# 4. Headers trigger
- triggerId: "trigger-with-headers"
  database: "default"
  collection: "headers_test_*"
  events: ["create"]
  condition: "true"
  url: "%s"
  headers:
    X-Custom-Header: "test-value"
    X-Trigger-Source: "syntrix"
```

---

## 具体测试 Case 设计

### Case 1: TestTriggerCreateEvent
**目的**：验证 Create 事件触发 webhook

**步骤**：
1. 创建文档 `POST /api/v1/trigger_create_{timestamp}` with `{"name": "test", "value": 100}`
2. 等待 WebhookEvents channel 收到事件（timeout 30s）

**验证**：
- `task.Event == "create"`
- `task.TriggerID == "trigger-all-events"`
- `task.Collection` 包含 "trigger_create_"
- `task.After != nil` 且包含 `name`, `value` 字段
- `task.Before == nil`
- `task.PreIssuedToken != ""`

---

### Case 2: TestTriggerUpdateEvent
**目的**：验证 Update 事件触发 webhook

**步骤**：
1. 创建文档，drain create 事件
2. 更新文档 `PATCH /api/v1/{collection}/{id}` with `{"value": 200}`
3. 等待 WebhookEvents channel 收到 update 事件

**验证**：
- `task.Event == "update"`
- `task.Before != nil` 且 `Before.value == 100`
- `task.After != nil` 且 `After.value == 200`
- `task.PreIssuedToken != ""`

---

### Case 3: TestTriggerDeleteEvent
**目的**：验证 Delete 事件触发 webhook

**步骤**：
1. 创建文档，drain create 事件
2. 删除文档 `DELETE /api/v1/{collection}/{id}`
3. 等待 WebhookEvents channel 收到 delete 事件

**验证**：
- `task.Event == "delete"`
- `task.Before != nil`
- `task.After == nil`
- `task.PreIssuedToken != ""`

---

### Case 4: TestTriggerCELCondition
**目的**：验证 CEL 条件过滤

**Trigger 配置**：
```yaml
- triggerId: "trigger-adult-only"
  collection: "cel_test_*"
  condition: "event.document.age >= 18"
```

**步骤**：
1. 创建文档 `{"name": "minor", "age": 15}` → 不应触发 `trigger-adult-only`
2. 创建文档 `{"name": "adult", "age": 25}` → 应触发 `trigger-adult-only`

**验证**：
- 收到的事件中，只有 `age >= 18` 的文档匹配 `trigger-adult-only`
- 两个文档都会触发 `trigger-all-events`（因为 condition: "true"）

**注意**：需要区分 triggerID 来判断

---

### Case 5: TestTriggerMultiMatch
**目的**：验证一个事件匹配多个 trigger

**步骤**：
1. 创建文档到 `specific_collection`
2. 等待收到多个 webhook 事件

**验证**：
- 收到至少 2 个事件：`trigger-all-events` 和 `trigger-specific-collection`
- 两个事件的 DocumentID 相同

---

### Case 6: TestTriggerHeaders
**目的**：验证自定义 Headers 传递

**Trigger 配置**：
```yaml
- triggerId: "trigger-with-headers"
  collection: "headers_test_*"
  headers:
    X-Custom-Header: "test-value"
    X-Trigger-Source: "syntrix"
```

**步骤**：
1. 创建文档到 `headers_test_{timestamp}`
2. 等待 WebhookEvents channel 收到事件

**验证**：
- `event.Headers["X-Custom-Header"] == "test-value"`
- `event.Headers["X-Trigger-Source"] == "syntrix"`

---

### Case 7: TestTriggerCollectionWildcard
**目的**：验证 Collection 通配符匹配

**步骤**：
1. 创建文档到 `cel_test_abc`（匹配 `cel_test_*`）
2. 创建文档到 `other_collection`（不匹配 `cel_test_*`）

**验证**：
- `cel_test_abc` 的事件匹配 `trigger-adult-only`（如果满足 CEL 条件）
- `other_collection` 的事件不匹配 `trigger-adult-only`

---

### 暂不测试的场景

| 场景 | 原因 |
|------|------|
| Database 过滤 | 当前集成测试环境只有 "default" 数据库，需要额外配置多数据库环境 |
| Webhook 重试 | 需要动态控制 webhook 返回状态码，增加复杂度，可后续单独测试 |

---

## 测试隔离策略

1. **Collection 隔离**：每个 case 使用唯一的 collection 名称（带 timestamp）
2. **Event 过滤**：通过 `task.TriggerID` 和 `task.Collection` 过滤目标事件
3. **Drain 策略**：创建后等待特定事件，忽略其他 case 产生的事件
4. **Timeout**：每个 case 最多等待 30s

---

## 数据结构定义

### WebhookEvent

Webhook server 捕获的事件结构，包含 Headers 和 Body：

```go
// WebhookEvent represents a captured webhook request
type WebhookEvent struct {
    Headers map[string]string // HTTP headers from the webhook request
    Body    []byte            // Raw JSON body
}
```

### DeliveryTask

从 `internal/trigger/worker` 包导入，或在测试中定义匹配的结构体：

```go
// DeliveryTask mirrors the structure from internal/trigger/worker
type DeliveryTask struct {
    TriggerID      string                 `json:"triggerId"`
    Event          string                 `json:"event"`      // "create", "update", "delete"
    Database       string                 `json:"database"`
    Collection     string                 `json:"collection"`
    DocumentID     string                 `json:"documentId"`
    Before         map[string]interface{} `json:"before,omitempty"`
    After          map[string]interface{} `json:"after,omitempty"`
    PreIssuedToken string                 `json:"preIssuedToken,omitempty"`
}
```

---

## 辅助函数

### waitForEvent

等待匹配特定条件的事件，用于测试隔离：

```go
// waitForEvent waits for a webhook event matching the given condition
func waitForEvent(t *testing.T, ch <-chan WebhookEvent, match func(DeliveryTask) bool, timeout time.Duration) DeliveryTask {
    t.Helper()
    deadline := time.After(timeout)
    for {
        select {
        case evt := <-ch:
            var task DeliveryTask
            if err := json.Unmarshal(evt.Body, &task); err != nil {
                continue // skip malformed events
            }
            if match(task) {
                return task
            }
            // not matching, continue waiting
        case <-deadline:
            t.Fatalf("timeout waiting for matching event")
        }
    }
}
```

### drainEvents

清空 channel 中的事件，用于忽略前置操作产生的事件：

```go
// drainEvents removes all pending events from the channel
func drainEvents(ch <-chan WebhookEvent, drainTime time.Duration) {
    deadline := time.After(drainTime)
    for {
        select {
        case <-ch:
            // discard
        case <-deadline:
            return
        }
    }
}
```

---

## 并发安全考虑

### Channel Buffer 大小

`WebhookEvents` channel 使用 buffered channel，建议 buffer 大小为 100：

```go
WebhookEvents: make(chan WebhookEvent, 100),
```

### 测试隔离

由于所有测试共享同一个 `WebhookEvents` channel，需要注意：

1. **匹配过滤**：`waitForEvent` 通过 `match` 函数只接受目标事件
2. **唯一 Collection**：每个测试使用 `{test_name}_{timestamp}` 格式的 collection
3. **不保证顺序**：测试不应假设事件到达顺序
4. **Buffer 溢出**：如果 buffer 满，webhook handler 应该 drop 或 block（建议 drop 并 log warning）

### Webhook Handler 实现

```go
func (g *GlobalTestEnv) webhookHandler(w http.ResponseWriter, r *http.Request) {
    body, _ := io.ReadAll(r.Body)
    headers := make(map[string]string)
    for k, v := range r.Header {
        if len(v) > 0 {
            headers[k] = v[0]
        }
    }

    evt := WebhookEvent{Headers: headers, Body: body}

    select {
    case g.WebhookEvents <- evt:
        // sent
    default:
        log.Printf("WARNING: WebhookEvents channel full, dropping event")
    }

    w.WriteHeader(http.StatusOK)
}

---

## Checklist

- [x] Confirm approach with user
- [ ] Define `WebhookEvent` struct in main_test.go
- [ ] Add `WebhookEvents` channel to GlobalTestEnv (buffer size 100)
- [ ] Implement webhook handler with Headers capture
- [ ] Add `trigger_config` import to main_test.go
- [ ] Create trigger rules file with dynamic webhookURL
- [ ] Add Trigger config to cfg struct
- [ ] Implement `waitForEvent` helper function
- [ ] Implement `drainEvents` helper function
- [ ] Rewrite trigger_test.go to use WebhookEvents channel
- [ ] Run and verify tests pass
