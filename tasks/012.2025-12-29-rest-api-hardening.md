# REST API Hardening

Date: 2025-12-29
Status: In Progress
Scope: Security hardening, reliability improvements, and code quality optimization for REST API handlers

## Background

A comprehensive code review of `internal/api/rest` identified several security risks, reliability issues, and code quality concerns that need to be addressed.

## Risk Summary

### Security Risks (High Priority)

| # | Issue | Location | Severity |
|---|-------|----------|----------|
| 1 | No request body size limit | All `json.NewDecoder(r.Body)` calls | ðŸ”´ High |
| 2 | No request timeout control | All handlers | ðŸŸ  Medium |
| 3 | No rate limiting | Entire REST module | ðŸŸ  Medium |
| 4 | Sensitive error info leakage | `handler_query.go:29`, `handler_document.go:32` | ðŸŸ  Medium |
| 5 | TriggerGet path not validated | `handler_trigger.go:49` | ðŸŸ  Medium |
| 6 | No panic recovery | All handlers | ðŸŸ¡ Low |

### Code Quality Issues

| # | Issue | Location |
|---|-------|----------|
| 7 | JSON encoding errors not handled | All `json.NewEncoder(w).Encode()` calls |
| 8 | Inconsistent logging | Only `handler_replication.go` uses logging |
| 9 | Duplicated error handling patterns | Multiple handler files |
| 10 | Hardcoded constants | `validation.go:78-80` (`limit > 1000`) |
| 11 | Uncertain design in comments | `handler_trigger.go:52` |

### Reliability Issues

| # | Issue | Location |
|---|-------|----------|
| 12 | Non-atomic Create-then-Get | `handler_document.go:75-79` |
| 13 | Non-transactional TriggerWrite | `handler_trigger.go:82-123` |
| 14 | Vague authz error handling | `handler.go:163-166` |

---

## Implementation Plan

### Phase 1: Security Hardening (High Priority)

#### 1.1 Add Request Body Size Limit Middleware

**Why**: Without body size limits, attackers can send extremely large payloads causing memory exhaustion (DoS).

**How**:
- Create `maxBodySize` middleware using `http.MaxBytesReader`
- Default limit: 1MB for standard endpoints
- Configurable per-endpoint if needed

**Files**: `handler.go`

```go
func (h *Handler) maxBodySize(next http.HandlerFunc, maxBytes int64) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        r.Body = http.MaxBytesReader(w, r.Body, maxBytes)
        next(w, r)
    }
}
```

#### 1.2 Add TriggerGet Path Validation

**Why**: Unvalidated paths could allow path traversal attacks or access to unintended resources.

**How**:
- Reuse existing `validateDocumentPath` function
- Validate each path in the `paths` array before processing

**Files**: `handler_trigger.go`

#### 1.3 Unified Error Response Handling

**Why**: Raw `err.Error()` may expose internal details (SQL errors, file paths, etc.).

**How**:
- Create `APIError` struct with code, message, and optional details
- Create `writeError` helper function
- Internal errors return generic message with request ID for debugging

**Files**: `handler.go`, all `handler_*.go` files

```go
type APIError struct {
    Code    string `json:"code"`
    Message string `json:"message"`
    Details string `json:"details,omitempty"`
}

func writeError(w http.ResponseWriter, code int, errCode string, message string) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(code)
    json.NewEncoder(w).Encode(APIError{Code: errCode, Message: message})
}
```

---

### Phase 2: Reliability Improvements (Medium Priority)

#### 2.1 Add Panic Recovery Middleware

**Why**: Unhandled panics crash the entire request handler and may leak resources.

**How**:
- Create recovery middleware that catches panics
- Log stack trace for debugging
- Return 500 Internal Server Error to client

**Files**: `handler.go`

```go
func (h *Handler) recover(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                log.Printf("[PANIC] %v\n%s", err, debug.Stack())
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            }
        }()
        next(w, r)
    }
}
```

#### 2.2 JSON Encoding Error Handling

**Why**: `json.Encode()` can fail (e.g., broken pipe), and ignoring errors leaves clients with incomplete responses.

**How**:
- Create `writeJSON` helper function
- Log encoding errors for debugging

**Files**: `handler.go`, all `handler_*.go` files

```go
func writeJSON(w http.ResponseWriter, status int, data interface{}) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    if err := json.NewEncoder(w).Encode(data); err != nil {
        log.Printf("[WARN] JSON encode error: %v", err)
    }
}
```

#### 2.3 Request Timeout Control

**Why**: Slow backend operations can tie up goroutines and connections indefinitely.

**How**:
- Add context timeout middleware
- Default timeout: 30s, configurable
- Cancel context on timeout

**Files**: `handler.go`

---

### Phase 3: Code Quality Optimization (Medium Priority)

#### 3.1 Unified Logging Framework

**Why**: Inconsistent logging makes debugging and monitoring difficult.

**How**:
- Use `log/slog` for structured logging
- Add request ID to all log entries
- Add appropriate log levels (Info, Warn, Error)

**Files**: All `handler_*.go` files

#### 3.2 Extract Common Error Handling

**Why**: Duplicated error-to-HTTP-status mapping is error-prone and hard to maintain.

**How**:
- Create `mapStorageError` function (partially exists in `handler_trigger.go`)
- Move to common location and reuse

**Files**: `handler.go`, `handler_document.go`, `handler_trigger.go`

#### 3.3 Configurable Constants

**Why**: Hardcoded limits prevent operational flexibility.

**How**:
- Move `limit > 1000` and similar thresholds to configuration
- Add validation config struct

**Files**: `validation.go`, `types.go`

---

### Phase 4: Architecture Optimization (Low Priority)

#### 4.1 Optimize Authorized Middleware Body Handling

**Why**: Reading and re-wrapping body in middleware is inefficient.

**How**:
- Consider body caching or lazy evaluation
- Profile to measure actual impact first

**Files**: `handler.go`

#### 4.2 Response Compression (Optional)

**Why**: Large JSON responses benefit from gzip compression.

**How**:
- Add optional gzip middleware
- Use `Accept-Encoding` header detection

**Files**: `handler.go`

---

## Implementation Order

### Immediate (Security Critical)
- [x] 1.1 Request body size limit
- [x] 1.2 TriggerGet path validation
- [x] 1.3 Unified error response

### Short-term (1-2 weeks)
- [x] 2.1 Panic recovery middleware
- [x] 2.2 JSON encoding error handling (Completed as part of 1.3)
- [x] 2.3 Request timeout control

### Medium-term (2-4 weeks)
- [x] 3.1 Unified logging (using log/slog with request ID)
- [x] 3.2 Extract common error handling (writeStorageError centralized)
- [x] 3.3 Configurable constants (ValidationConfig struct)

### Long-term (As needed)
- [x] 4.1 Optimize body handling (context caching to avoid double parsing)
- [ ] 4.2 Response compression (deferred - implement when needed)

---

## Testing Strategy

Each change requires:
1. Unit tests for new middleware/helper functions
2. Integration tests for error scenarios
3. Verify existing tests still pass

---

## Success Criteria

- [x] All security vulnerabilities addressed
- [x] No raw `err.Error()` exposed to clients
- [x] Consistent logging across all handlers
- [x] All tests pass with >= 80% coverage
- [ ] No panics in stress testing

---

## References

- [OWASP API Security Top 10](https://owasp.org/www-project-api-security/)
- Go HTTP best practices
- Existing codebase patterns in `internal/api/rest`
