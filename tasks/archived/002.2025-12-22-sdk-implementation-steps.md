# SDK Implementation Execution Plan (TypeScript Client)

Date: December 22, 2025
Status: Done
Scope: Deliver the TypeScript SDK per design docs for SyntrixClient, TriggerClient, shared auth, and replication scaffolding.

## Objectives (Why)
- Provide a concrete execution path to implement the SDK designs in docs/design/sdk while keeping scope tight and testable.
- Ensure public API parity across clients and adherence to the shared `StorageClient` contract.
- Bake in auth/refresh semantics once to avoid divergence across CRUD, replication, and realtime triggers.
- Establish gating tests and checkpoints to catch regressions early.

## Constraints / Dependencies
- Align with design docs: [docs/design/sdk/001_sdk_architecture.md](docs/design/sdk/001_sdk_architecture.md), [docs/design/sdk/002_replication_client.md](docs/design/sdk/002_replication_client.md), [docs/design/sdk/003_authentication.md](docs/design/sdk/003_authentication.md), [docs/design/sdk/004_syntrix_client.md](docs/design/sdk/004_syntrix_client.md), [docs/design/sdk/005_trigger_client.md](docs/design/sdk/005_trigger_client.md).
- No new external dependencies without explicit approval.
- Tests for Go surfaces must use `github.com/stretchr/testify`; TypeScript tests should use the existing TS test runner in the repo (keep consistent).

## Work Breakdown (How)
1) Repository scaffolding readiness
- Confirm pkg/syntrix-client-ts has lint/test scripts wired; align tsconfig/paths if needed (no new deps without approval).
- Only add/adjust `package.json` scripts or CI hooks after explicit approval; keep consistent with existing project style and do not introduce new dependencies.

2) Shared auth layer (per 003)
- Implement `TokenProvider`, `AuthConfig`, hooks, and serialized refresh logic in a dedicated module under `src/internal/auth/`.
- Axios (or fetch) interceptor: attach bearer token; on 401/403 run single refresh, retry once, emit hooks.
- Export `setToken` for static token flows; ensure no token logging.
- Tests: concurrent 401s serialize refresh; refresh failure bubbles; realtime auth error closes channel.

3) StorageClient contract + internal transport utilities
- Define `StorageClient` interface in `src/internal/storage-client.ts` with CRUD/query signatures.
- Implement transport helper to map CRUD/query to REST endpoints with JSON handling and 404->null conversion hook.
- Tests: method-to-endpoint mapping, payload shapes, 404->null, non-404 errors propagate.

4) SyntrixClient (per 004)
- Implement class in `src/clients/syntrix-client.ts` using shared auth + transport; wire fluent Reference API entry points (`collection`, `doc`).
- Ensure optional client-provided id on create; query posts to `/api/v1/query` with `Query` shape.
- Tests: create with/without id; get returns null on 404; auth refresh once on 401/403; reference API delegates correctly.

5) TriggerClient (per 005)
- Implement class in `src/clients/trigger-client.ts` with `preIssuedToken` only (no refresh). Use trigger endpoints (`/api/v1/trigger/...`).
- Enforce required id on create; `get` tolerant to empty docs array; implement `batch(writes)` to `/api/v1/trigger/write`.
- Tests: create without id rejects; batch forwards writes; query uses trigger endpoint; missing token fails fast.

6) Reference API layer
- Add `CollectionReference` / `DocumentReference` builders in `src/api/` that depend only on `StorageClient`.
- Provide chaining (`where`, `orderBy`, `limit`) and terminal ops (`get`, `add`, `set/replace`, `update`, `delete`).
- Tests: chaining calls underlying `StorageClient` with correct paths and shapes; type generics preserved.

7) Replication scaffolding (per 002) — scope: types + skeleton
- Add `src/replication/` files: `types.ts`, `checkpoint.ts`, `outbox.ts`, `realtime.ts`, `pull.ts`, `push.ts`, `coordinator.ts` with stubbed orchestrator wiring but no full logic yet.
- Ensure checkpoints not advanced on auth errors; realtime events only schedule pulls.
- Tests (scaffold-level): constructor guards, option validation, no-op start/stop lifecycle, auth error does not mutate checkpoint.

8) Public entrypoints and packaging
- Update `src/index.ts` exports for both clients, reference API types, and replication scaffolding types/factory. SDK is unreleased, so feature flags are optional, but do not expose unfinished replication surfaces: keep them in internal-only paths (e.g., `src/replication/internal/*`) and omit from the top-level index until ready; if you must surface them, mark clearly as WIP.
- Ensure tree-shakeable exports; avoid leaking `internal` symbols.
- Tests: build succeeds; import paths resolved; public API surface matches docs.

9) Documentation updates
- Add README snippets for SyntrixClient/TriggerClient usage; document auth hooks and error handling.
- Add replication WIP section noting current scaffold state and planned completion steps.
- For design/implementation notes, include concise "Why" and "How" rationale aligned with AGENTS instructions so decisions are traceable.

10) Test & quality gates

- Run TypeScript unit tests via the existing package script in pkg/syntrix-client-ts using bun (`bun test`); record results. If bun scripts/config are missing, add them first, otherwise request approval before switching runners. Normalize to Bun’s default `bun.lockb`: regenerate with `bun install`, remove any legacy `bun.lock`, and avoid mixing package managers unless approved.
- Add coverage targets for new modules: target ≥80% line coverage for new TS modules; emit coverage artifacts (e.g., `coverage/lcov.info`) and attach/report in reviews/CI as applicable; confirm threshold with stakeholders if adjustment is needed. Prefer table-driven tests for Go parts using testify.
- Run Go tests `go test ./...`; lint/format per repo standards.

## Definition of Done
- Both clients implemented per design; shared auth in place; reference API functional.
- Replication scaffolding merged with clear TODOs and guards (no partial behavior exposed by default).
- Tests green (TS + Go), lint clean, build passes.
- Docs updated reflecting current capability and roadmap.

## Risks / Mitigations
- Auth refresh loops: cap retries to 1 and serialize refresh (tests cover concurrency).
- TriggerClient misuse with long-lived tokens: enforce fail fast and document.
- Replication partial feature risk: gate unfinished pieces and clearly mark WIP exports.
- Coding-phase pitfalls & suggested mitigations:
	- Auth interceptor concurrency: ensure single-flight refresh with queued waiters; retry exactly once; avoid infinite loops; include status/endpoint in surfaced errors for hooks.
	- Reference API path handling: normalize/validate collection/doc paths (no double slashes or empty segments); share the same path builder for SyntrixClient and TriggerClient.
	- TriggerClient create semantics: enforce required id at both type and runtime; batch payload order/types must match server contract; reject missing token early.
	- Replication scaffolding exposure: keep under internal paths and out of top-level index; if exported, mark WIP prominently and avoid tree-shaken accidental surfacing.
	- bun test setup: ensure bun scripts/config and lockfile exist before running tests; align ESM/CJS and TS config; set coverage collection to respect source maps.
	- HTTP error handling: only 404 maps to null for get; propagate other statuses; include diagnostics in errors for observability hooks.
	- Query serialization: mirror server Query shape (field names/operator casing); add tests to cover serialization cases.
	- Lint/format consistency: ensure bun scripts cover lint/format or document the command; keep CI consistent.
	- Dual-stack test sequencing: ensure TS scaffolding is in place before running Go tests to avoid CI noise from missing JS/TS deps.

## Next Actions
- Confirm naming/layout with stakeholders if any disagreements; otherwise proceed with step 2 (shared auth layer).
- Should I add more testing beyond the listed gates?
