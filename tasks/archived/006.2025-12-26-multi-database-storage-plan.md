# Multi-Database Storage Implementation Plan

Date: 2025-12-26
Status: Completed
Scope: Storage layer multi-tenancy (database-aware IDs, routing, indexes, Mongo implementation, tests)
Reference Design: docs/design/server/storage/005.multi-database.md

## Objectives

- Enforce database-aware IDs and routing to prevent cross-database data access.
- Add database-scoped indexing (collection_hash) and Mongo filters.
- Provide per-database backend binding with fail-closed defaults.
- Deliver unit tests for isolation and index guarantees.

## Plan

1) Update config structures to add `databases` binding map and enforce default database presence.
2) Refactor storage interfaces to require `database string`; introduce database-aware ID helpers; deprecate path-only helpers.
3) Mongo implementation: add `database` field handling, database-aware `_id` generation (prefix format `database:hash(...)`), `collection_hash` population, filters, watch guards (using prefix match), and indexes.
4) Routing/factory: lookup database→backend before op-kind routing; error on missing/empty database; keep read/write split per backend.
5) Tests: isolation across databases for CRUD/query/watch; per-database uniqueness for users/revocations; index existence checks (`collection_hash`, TTL); database-aware `_id` difference for same path across databases.
6) Docs: update design to reflect database-aware ID strategy and routing requirements (tracked in 005.multi-database.md).

### Suggested Order / Milestones

- M1: Interfaces + helpers become database-aware; add new ID generators; deprecate path-only helpers.
- M2: Mongo documents add `database`, database-aware `_id`, filters, `(database, collection_hash)` index; EnsureIndexes updated; watch adds database guard.
- M3: Routing/Factory enforce database mandatory, database→backend binding (default required), empty/missing errors; config structs gain `storage.databases` with validation.
- M4: User/Revocation models gain `database`, database-aware `_id`, per-database unique `(database, username)`; revocation per-database TTL/index; migrate call sites.
- M5: Migration/backfill guidance (dev/test data): add `database`/`collection_hash` and rerun EnsureIndexes.
- M6: Tests: cross-database isolation (CRUD/query/watch), empty-database fail, index presence, database-aware `_id` difference, user/revocation per-database uniqueness.

## Deliverables

- Code changes in storage interfaces, Mongo stores, routers/factory.
- Config updates with database bindings.
- Unit tests covering isolation, indexes, and ID behavior.
- Updated design doc reflecting final implementation details.

## Risks & Mitigations

- Risk: Caller forgets database; Mitigation: storage layer fails closed on empty database, add middleware to inject/validate default.
- Risk: Legacy helpers still path-based; Mitigation: deprecate and migrate all call sites.
- Risk: Index drift in existing envs; Mitigation: EnsureIndexes migration step and tests to assert presence.

## Open Issues / Actions

- Align design vs implementation: refactor code to database-aware IDs and `database` parameters on storage interfaces; remove path-only helpers usage.
- Update config example to include `storage.databases` default binding and dedicated bindings; ensure validation for missing default.
- Watch behavior: implement server-side regex filter on `documentKey._id` for delete events.
- TODO: Define Read/Write split strategy for dedicated databases.
- Backfill/EnsureIndexes: define handling for existing dev/test data (add `database`, `collection_hash`); EnsureIndexes to enforce required indexes.
- Migration list: inventory and replace all uses of `CalculateID`/`NewDocument` to database-aware helpers.
- Risk/rollback: decide whether a temporary compatibility layer or feature flag is needed during helper/ID migration; add if necessary.
