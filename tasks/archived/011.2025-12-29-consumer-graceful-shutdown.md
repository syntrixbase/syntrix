# Consumer Graceful Shutdown

Date: 2025-12-29
Status: Complete
Scope: Implement graceful shutdown for trigger consumer to ensure message safety and prevent resource leaks
Reference: tasks/010.2025-12-28-trigger-engine-refactor.md (Item 8.9)

## Background

From the trigger engine refactor (Task 010), item 8.9 was deferred:

> **8.9 Consumer Graceful Shutdown Incomplete**
> - File: `internal/trigger/internal/pubsub/consumer.go`
> - Issue: On shutdown, channels are closed immediately without waiting for in-flight messages.
> - Note: Deferred to future iteration - requires careful design to avoid deadlocks

## Problem Statement

Current shutdown flow in `consumer.go`:

```go
<-ctx.Done()                    // Wait for context cancellation

log.Println("Stopping Trigger Consumer...")
cc.Stop()                       // Stop receiving new messages

for _, ch := range c.workerChans {
    close(ch)                   // Immediately close all worker channels
}
c.wg.Wait()                     // Wait for workers to exit
```

**Issues**:
1. Messages in `dispatch()` may be sent to already-closed channels, causing panic
2. No **drain period** - cannot wait for in-transit messages to be safely processed
3. No **shutdown timeout** - blocked workers cause infinite wait

## Design Goals

1. **Safe shutdown**: Prevent sending to closed channels
2. **Message integrity**: Ensure all queued messages are processed
3. **Timeout protection**: Avoid infinite wait on blocked workers
4. **Observability**: Log key events during shutdown

## Architecture

```
                          ┌──────────────────────────────────────────┐
                          │            Consumer Shutdown             │
                          └──────────────────────────────────────────┘
                                           │
                                           ▼
                          ┌──────────────────────────────────────────┐
                          │   Phase 1: Stop Accepting New Messages   │
                          │   - cc.Stop() (NATS consumer stop)       │
                          │   - Set c.closing = true                 │
                          └──────────────────────────────────────────┘
                                           │
                                           ▼
                          ┌──────────────────────────────────────────┐
                          │   Phase 2: Drain Period                  │
                          │   - Wait for in-flight dispatch() calls  │
                          │   - Use atomic counter for tracking      │
                          │   - Max wait: drainTimeout (default 5s)  │
                          └──────────────────────────────────────────┘
                                           │
                                           ▼
                          ┌──────────────────────────────────────────┐
                          │   Phase 3: Close Worker Channels         │
                          │   - Close all workerChans                │
                          │   - Workers drain remaining messages     │
                          └──────────────────────────────────────────┘
                                           │
                                           ▼
                          ┌──────────────────────────────────────────┐
                          │   Phase 4: Wait for Workers              │
                          │   - c.wg.Wait() with timeout             │
                          │   - Max wait: shutdownTimeout (10s)      │
                          │   - Log if timeout exceeded              │
                          └──────────────────────────────────────────┘
```

## Detailed Design

### Data Structure Changes

```go
type natsConsumer struct {
    // ... existing fields ...
    
    // Shutdown coordination
    closing         atomic.Bool      // Marks closing state
    inFlightCount   atomic.Int32     // Count of messages in dispatch()
    drainTimeout    time.Duration    // Drain phase timeout (default: 5s)
    shutdownTimeout time.Duration    // Overall shutdown timeout (default: 10s)
}
```

### Configuration Options

```go
// WithDrainTimeout sets the drain timeout for graceful shutdown.
func WithDrainTimeout(d time.Duration) ConsumerOption {
    return func(c *natsConsumer) {
        if d > 0 {
            c.drainTimeout = d
        }
    }
}

// WithShutdownTimeout sets the overall shutdown timeout.
func WithShutdownTimeout(d time.Duration) ConsumerOption {
    return func(c *natsConsumer) {
        if d > 0 {
            c.shutdownTimeout = d
        }
    }
}
```

### Core Implementation

#### 1. Safe dispatch() with Closing Check

```go
func (c *natsConsumer) dispatch(msg jetstream.Msg) {
    // Increment in-flight count
    c.inFlightCount.Add(1)
    defer c.inFlightCount.Add(-1)
    
    // Check if closing
    if c.closing.Load() {
        log.Printf("[Warn] Consumer is closing, NAK message for redelivery")
        msg.Nak()  // Let NATS redeliver to other consumers
        return
    }
    
    // ... existing unmarshal and dispatch logic ...
}
```

#### 2. Graceful Shutdown Flow

```go
func (c *natsConsumer) Start(ctx context.Context) error {
    // ... existing setup code ...

    <-ctx.Done()
    
    // Phase 1: Stop accepting new messages
    log.Println("[Info] Stopping Trigger Consumer...")
    c.closing.Store(true)
    cc.Stop()

    // Phase 2: Wait for in-flight dispatches
    drainCtx, drainCancel := context.WithTimeout(context.Background(), c.drainTimeout)
    defer drainCancel()
    c.waitForDrain(drainCtx)

    // Phase 3: Close worker channels
    for _, ch := range c.workerChans {
        close(ch)
    }

    // Phase 4: Wait for workers with timeout
    done := make(chan struct{})
    go func() {
        c.wg.Wait()
        close(done)
    }()
    
    shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), c.shutdownTimeout)
    defer shutdownCancel()
    
    select {
    case <-done:
        log.Println("[Info] All workers stopped gracefully")
    case <-shutdownCtx.Done():
        log.Printf("[Warn] Shutdown timeout exceeded, %d workers may still be running", c.countActiveWorkers())
    }
    
    return nil
}

func (c *natsConsumer) waitForDrain(ctx context.Context) {
    ticker := time.NewTicker(100 * time.Millisecond)
    defer ticker.Stop()
    
    for {
        select {
        case <-ctx.Done():
            remaining := c.inFlightCount.Load()
            if remaining > 0 {
                log.Printf("[Warn] Drain timeout, %d messages still in-flight", remaining)
            }
            return
        case <-ticker.C:
            if c.inFlightCount.Load() == 0 {
                log.Println("[Info] All in-flight messages drained")
                return
            }
        }
    }
}
```

### Default Values

Add to `internal/trigger/types/defaults.go`:

```go
const (
    DefaultDrainTimeout    = 5 * time.Second
    DefaultShutdownTimeout = 10 * time.Second
)
```

## Observability

| Event | Log Level | Description |
|-------|-----------|-------------|
| Consumer closing started | Info | Shutdown flow started |
| Message NAK during shutdown | Warn | New message rejected during close |
| Drain timeout | Warn | Drain phase timeout, log remaining count |
| Drain complete | Info | All in-flight messages processed |
| Workers stopped | Info | All workers exited normally |
| Shutdown timeout | Warn | Overall timeout, log active worker count |

## Edge Cases

| Scenario | Handling |
|----------|----------|
| dispatch() receives close signal | NAK message for NATS redelivery |
| Worker processing when ctx cancelled | Worker continues current message to completion |
| Drain timeout | Log warning, continue shutdown flow |
| Worker timeout | Log warning, don't force terminate (avoid state inconsistency) |

## Test Plan

### Unit Tests

1. **TestConsumer_GracefulShutdown_DrainComplete**
   - Send messages then immediately cancel context
   - Verify all messages are processed

2. **TestConsumer_GracefulShutdown_DrainTimeout**
   - Mock a slow dispatch
   - Verify drain timeout takes effect

3. **TestConsumer_GracefulShutdown_MessageNakOnClose**
   - Verify new messages are NAK'd during close

4. **TestConsumer_GracefulShutdown_WorkerTimeout**
   - Mock a blocking worker
   - Verify shutdown timeout takes effect

## Implementation Plan

| Step | Task | Est. Time |
|------|------|-----------|
| 1 | Add default constants to `types/defaults.go` | 5 min |
| 2 | Modify `natsConsumer` struct | 5 min |
| 3 | Add `ConsumerOption` functions | 5 min |
| 4 | Modify `dispatch()` | 10 min |
| 5 | Implement graceful shutdown flow | 20 min |
| 6 | Write unit tests | 30 min |

**Total**: ~75 minutes

## Milestones

- [x] M1: Add defaults and struct changes
- [x] M2: Implement dispatch safety check
- [x] M3: Implement 4-phase shutdown flow
- [x] M4: Add unit tests
- [x] M5: Update task doc status

## Acceptance Criteria

- [x] No panic when shutdown during active dispatch
- [x] All queued messages processed before exit (within timeout)
- [x] Shutdown completes within configured timeout
- [x] All 4 test cases pass
- [x] Test coverage >= 80% for consumer.go

## Status Log

- 2025-12-29: Task created, design documented
- 2025-12-29: Implementation complete, all tests passing
