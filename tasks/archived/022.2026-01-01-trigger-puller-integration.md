# Task: Trigger Evaluator Integration with Puller

## Status
- [ ] Draft
- [ ] In Progress
- [x] Completed

## Implementation Notes
- **TriggerEvent**: Introduced `internal/trigger/types/event.go` to decouple Trigger Engine from Storage events.
- **Watcher**: Rewrote `internal/trigger/internal/watcher/watcher.go` to consume from `puller.Service`.
- **Checkpointing**: Switched from MongoDB BSON tokens to Puller String tokens.
- **Testing**: Updated all tests to use `TriggerEvent` and `MockPullerService`.
- **Integration**: Updated `internal/services/manager_init.go` to inject Puller service into Trigger Factory.

## Context
Currently, in Standalone mode, both the `Puller` service and the `TriggerEvaluator` independently watch MongoDB change streams. This results in:
1.  **Redundant Connections**: Double the number of connections to MongoDB (one for Puller, one for Trigger).
2.  **Redundant Processing**: Both services deserialize and process the same raw BSON events.
3.  **Resource Waste**: Unnecessary network bandwidth and CPU usage.

Since `Puller` is designed to be the central "Change Data Capture" (CDC) component, it should be the single source of truth for change events. Other components like `TriggerEvaluator` should consume from `Puller`, especially in Standalone mode where this can be done efficiently in-memory.

## Objective
Optimize `TriggerEvaluator` to consume events directly from the `Puller` service when running in Standalone mode.

## Design

### 1. Architecture
*   **Current**: `TriggerEngine` -> `DefaultWatcher` -> `Storage.Watch` -> `MongoDB`
*   **Target**: `TriggerEngine` -> `PullerWatcher` -> `Puller.Subscribe` -> `Puller Internal Buffer` -> `MongoDB`

### 2. New Trigger Event Type
We will introduce a new `TriggerEvent` type in `internal/trigger/types` to decouple the trigger engine from the storage implementation.

**`internal/trigger/types/event.go`**:
```go
type EventType string

const (
    EventCreate EventType = "create"
    EventUpdate EventType = "update"
    EventDelete EventType = "delete"
)

type TriggerEvent struct {
    Id          string
    DatabaseID    string
    Type        EventType
    Document    *storage.StoredDoc // We still use storage.StoredDoc for now as it's the common data model
    Before      *storage.StoredDoc
    Timestamp   int64
    ResumeToken string // Changed from interface{} to string to match Puller
}
```

### 3. New Watcher Implementation
We will **rewrite** `internal/trigger/internal/watcher/watcher.go` to consume from the Puller service instead of watching MongoDB directly.

**Changes:**
*   **Delete** the existing `defaultWatcher` struct and its direct MongoDB watching logic.
*   Implement the new watcher logic using `puller.Service`.
*   Update `DocumentWatcher` interface to return `<-chan types.TriggerEvent`.

**Responsibilities:**
1.  **Subscription**: Call `puller.Service.Subscribe(ctx, consumerID, lastCheckpoint)`.
    *   `consumerID` should be unique per watcher instance, e.g., `"trigger-evaluator-<database>"`.
2.  **Filtering**: **Crucial**: The Watcher must filter events to only pass through those where `PullerEvent.Change.DatabaseID` matches the Watcher's configured `database`.
3.  **Adaptation**: Convert `events.PullerEvent` (Puller model) to `types.TriggerEvent` (Trigger model).
4.  **Checkpointing**:
    *   The `TriggerEvaluator` persists its progress in `sys/checkpoints`.
    *   The "resume token" will be the Puller's `Progress` (string).
    *   **BREAKING CHANGE**: No backward compatibility for old MongoDB resume tokens. If an old token exists, it will likely fail to be used or be ignored, causing a re-sync or start-from-now depending on configuration. This is acceptable.

**Event Mapping:**
*   `PullerEvent.Progress` -> `TriggerEvent.ResumeToken`
*   `PullerEvent.Change.DatabaseID` -> `TriggerEvent.DatabaseID`
*   `PullerEvent.Change.OpType` -> `TriggerEvent.Type`
    *   `insert` -> `create`
    *   `update`, `replace`:
        *   If `FullDocument.Deleted == true` -> `delete` (Soft Delete)
        *   Else if `OpType == replace` -> `create` (Re-creation/Overwrite)
        *   Else -> `update`
    *   `delete` -> `delete` (Hard Delete)
*   `PullerEvent.Change.FullDocument` -> `TriggerEvent.Document`
*   `PullerEvent.Change.MgoDocID` -> `TriggerEvent.Id`
*   **Special Handling for Delete**:
    *   Since `Puller` does not provide the "before" document, and `Event.Collection` does not exist on the `Event` struct (it's on the `Document`), we must construct a minimal `TriggerEvent.Before` document for Delete events.
    *   `TriggerEvent.Before` = `&storage.StoredDoc{Collection: PullerEvent.Change.MgoColl, Id: PullerEvent.Change.MgoDocID, DatabaseID: PullerEvent.Change.DatabaseID}`.

### 4. Evaluator Updates
Modify `internal/trigger/internal/evaluator/evaluator.go`:
*   Update `Evaluate` signature to accept `types.TriggerEvent`.
*   Update internal logic to use `TriggerEvent` fields.

### 5. Factory Updates
Modify `internal/trigger/engine/factory.go`:
*   Add `WithPuller(p puller.Service)` option to `FactoryOption`.
*   In `Engine()`, check if `puller` is configured.
    *   If **Yes**: Instantiate the new `Watcher` with the puller service.
    *   If **No**: Return error. **Puller is now mandatory** for the Trigger Engine.

### 6. Service Manager Integration
Modify `internal/services/manager_init.go`:
*   Ensure `m.pullerService` is initialized before `initTriggerServices`.
*   Pass `m.pullerService` to `trigger.NewFactory` using `WithPuller`.
*   If `m.pullerService` is not available (e.g. Puller disabled in config), `initTriggerServices` should fail or skip trigger initialization with a warning.

## Implementation Steps

1.  **Define TriggerEvent (`internal/trigger/types/event.go`)**
    *   Create new file with `TriggerEvent` struct.

2.  **Update Watcher Interface (`internal/trigger/internal/watcher/interfaces.go`)**
    *   Update `Watch` method to return `<-chan types.TriggerEvent`.

3.  **Rewrite Watcher (`internal/trigger/internal/watcher/watcher.go`)**
    *   **Delete** `defaultWatcher` struct and methods.
    *   Update `NewWatcher` signature to accept `puller.Service`.
    *   Implement `Watch` using `puller.Subscribe`.
    *   Implement filtering by database.
    *   Implement event conversion logic to `TriggerEvent`.

4.  **Update Evaluator (`internal/trigger/internal/evaluator/evaluator.go`)**
    *   Update `Evaluate` method to accept `types.TriggerEvent`.

5.  **Update Engine (`internal/trigger/engine/engine.go`)**
    *   Update `Start` loop to handle `TriggerEvent`.

6.  **Update Watcher Tests (`internal/trigger/internal/watcher/watcher_test.go`)**
    *   Update tests to mock `puller.Service`.
    *   Verify filtering and event mapping logic.

7.  **Update Trigger Factory (`internal/trigger/engine/factory.go`)**
    *   Add `puller` field to factory struct.
    *   Add `WithPuller` option.
    *   Update `Engine()` to enforce `puller` presence and pass it to `NewWatcher`.

8.  **Update Service Manager (`internal/services/manager_init.go`)**
    *   Ensure Puller is started before Triggers.
    *   Inject `pullerService` into Trigger factory.

9.  **Verification**
    *   Run unit tests.
    *   **Integration test**: Update integration tests to spin up the `Puller` service alongside the Trigger service. Verify that Triggers receive events via the Puller.

## Dependencies
*   `internal/puller` package (for `Service` interface and `events` package).
*   `internal/trigger` package.

## Notes
*   **Mandatory Dependency**: `TriggerEvaluator` now strictly depends on `Puller`.
*   The `Puller` must be configured to watch the collections that Triggers are interested in.
