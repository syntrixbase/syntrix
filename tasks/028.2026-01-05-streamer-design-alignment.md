# Task 028: Streamer Design Alignment

**Date**: 2026-01-05
**Status**: Completed ✅
**Scope**: api/proto/streamer, internal/streamer
**Depends On**: Task 027 (Streamer Implementation)
**Design Doc**: [docs/design/server/streamer](../docs/design/server/streamer/)

---

## Completion Summary (2026-01-05)

### Phase 1: Proto Filter 结构化 ✅
- 添加 `Filter`, `Value`, `ListValue` 消息到 streamer.proto
- 更新 `SubscribeRequest` 使用 `repeated Filter filters`
- 保留 `tenant` 字段，移除 `document_id`（通过 Filter 表达）
- 添加 `CompileProtoFilters` 函数将 proto Filter 转换为 CEL
- 更新 manager 和测试使用新的 Filter 结构

### Phase 2: Interface 对齐 ✅
- 重构 interface.go：Client 作为核心接口，Service 嵌入 Client
- StreamerService 实现 `Events()` 和 `Close()` 方法
- 添加编译时检查：`var _ Client = (*StreamerService)(nil)`
- StreamerClient 更新 Subscribe 返回 `(*pb.SubscribeResponse, error)`

### Phase 3: Soft Delete 转换 ✅
- 添加 `mapOperationWithSoftDelete` 处理 soft delete 语义
- UPDATE with `deleted=true` → DELETE
- UPDATE setting `deleted=false` (undelete) → INSERT
- 添加 18 个测试用例覆盖所有场景

### Phase 4: Backpressure ✅
- 修改 `ProcessEvent` 使用 blocking with timeout（不允许 drop）
- 添加 `SendTimeout` 配置（默认 5 秒）
- 超时后触发 `handleSlowGateway` 断开慢客户端

### All Tests Pass ✅
- streamer: 60ms
- internal/cel: cached
- internal/ingest: 7ms
- internal/manager: 7ms

---

## Background

Task 027 实现过程中，未经设计审阅擅自偏离了设计文档。需要修复以下问题：

| Issue | Design Requirement | Current Implementation | Impact |
|-------|-------------------|------------------------|--------|
| Proto Filter | 结构化 `Filter` 消息，严格约束语义 | `string filter` CEL 表达式 | 接口约束缺失 |
| Service/Client 接口 | Service 必须兼容 Client 接口 | 独立接口定义 | 单进程模式无法使用 |
| Soft Delete | Ingest 层转换存储层 soft delete | 未实现 | 事件语义错误 |
| Backpressure | 底层架构不允许 Drop | 满了就 Drop | 数据丢失风险 |

---

## 1. Proto Filter 结构化

### Why
- 严格约束语义，防止随意发挥
- 接口层结构化，底层可用 CEL 实现
- 类型安全，编译时检查

### Current
```protobuf
message SubscribeRequest {
  string subscription_id = 1;
  string collection = 2;
  string document_id = 3;
  string filter = 4;        // ❌ 任意 CEL 字符串
  string tenant = 5;
}
```

### Target (per design doc + tenant)
```protobuf
message SubscribeRequest {
  string subscription_id = 1;
  string collection = 2;
  repeated Filter filters = 3;  // ✅ 结构化
  string tenant = 4;            // 多租户支持
  // document_id 通过 Filter(field="_id", op="eq", value=...) 表达
}

message Filter {
  string field = 1;
  string op = 2;      // eq, ne, gt, lt, gte, lte, in, contains
  Value value = 3;
}

message Value {
  oneof kind {
    string string_value = 1;
    int64 int_value = 2;
    double double_value = 3;
    bool bool_value = 4;
    ListValue list_value = 5;
  }
}

message ListValue {
  repeated Value values = 1;
}
```

### Changes Required
1. `api/proto/streamer/streamer.proto` - 添加 Filter, Value, ListValue 消息
2. `api/proto/streamer/streamer.proto` - 修改 SubscribeRequest 使用 `repeated Filter`
3. Regenerate `api/streamer/v1/*.pb.go`
4. `internal/streamer/internal/cel/cel.go` - 添加 Filter → CEL 转换函数
5. `internal/streamer/internal/manager/manager.go` - 更新 Subscribe 签名
6. `internal/streamer/service.go` - 更新 gRPC handler

---

## 2. Service 兼容 Client 接口

### Why
- 单进程部署时，直接把 Service 当 Client 用
- 去掉网络和序列化/反序列化开销
- 统一抽象，简化调用方代码

### Current
```go
// interface.go
type Service interface {
    Start(ctx context.Context) error
    Stop(ctx context.Context) error
    Subscribe(ctx context.Context, req *pb.SubscribeRequest) error
    // ...
}

type Client interface {
    Connect(ctx context.Context) error
    Close() error
    Subscribe(ctx context.Context, req *pb.SubscribeRequest) error
    // ...
}
```

### Target
```go
// Client 是核心接口
type Client interface {
    Subscribe(ctx context.Context, req *pb.SubscribeRequest) error
    Unsubscribe(ctx context.Context, req *pb.UnsubscribeRequest) error
    Events() <-chan *pb.StreamerEvent
    Close() error
}

// Service 必须实现 Client
type Service interface {
    Client  // 嵌入 Client 接口

    // 额外的 Service 方法
    Start(ctx context.Context) error
    Stop(ctx context.Context) error
    ProcessEvent(ctx context.Context, event *ingest.InternalEvent) error
}

// 确保编译时检查
var _ Client = (*StreamerService)(nil)
var _ Client = (*StreamerClient)(nil)
```

### Changes Required
1. `internal/streamer/interface.go` - 重构接口定义，Service 嵌入 Client
2. `internal/streamer/service.go` - 添加 `Events()` 方法，确保实现 Client
3. `internal/streamer/client.go` - 确保实现相同的 Client 接口
4. 添加编译时检查 `var _ Client = (*StreamerService)(nil)`

---

## 3. Soft Delete 转换

### Why
- 存储层使用 soft delete（`deleted=true`），业务层认为已真正删除
- Streamer 作为事件层，需要将存储层语义转换为业务层语义
- 客户端应收到 DELETE 事件，而不是带 `deleted=true` 的 UPDATE

### Current
```go
// ingest/ingest.go
func (t *Transformer) Transform(event *puller.ChangeEvent) (*InternalEvent, error) {
    // 只做简单的操作类型映射
    // 未处理 soft delete
}
```

### Target
```go
func (t *Transformer) Transform(event *puller.ChangeEvent) (*InternalEvent, error) {
    op := mapOperationType(event.OperationType)

    // Soft Delete Transformation
    if op == pb.OperationType_UPDATE {
        if isDeleted(event.FullDocument) {
            op = pb.OperationType_DELETE
        }
    }

    // Recreation Handling (undelete)
    if op == pb.OperationType_UPDATE {
        if wasDeleted(event.UpdateDescription) && !isDeleted(event.FullDocument) {
            op = pb.OperationType_INSERT
        }
    }

    return &InternalEvent{
        OperationType: op,
        // ...
    }, nil
}

func isDeleted(doc bson.M) bool {
    deleted, ok := doc["deleted"]
    if !ok {
        return false
    }
    b, ok := deleted.(bool)
    return ok && b
}
```

### Changes Required
1. `internal/streamer/internal/ingest/ingest.go` - 添加 soft delete 检测和转换
2. `internal/streamer/internal/ingest/ingest_test.go` - 添加测试用例
3. Soft delete 字段名固定为 `deleted` (bool 类型)

---

## 4. Backpressure 不允许 Drop

### Why
- 底层架构，数据不能丢
- Drop 会导致客户端状态不一致
- 需要有序可靠的事件传递

### Current
```go
// service.go
select {
case sub.eventChan <- event:
    // sent
default:
    // ❌ Drop silently
}
```

### Target Options

**Option A: Blocking with Timeout**
```go
select {
case sub.eventChan <- event:
    // sent
case <-time.After(5 * time.Second):
    // timeout, disconnect client
    sub.Close()
    return ErrClientSlow
}
```

**Option B: Buffered Channel with Block**
```go
// 使用足够大的 buffer
eventChan := make(chan *pb.StreamerEvent, 10000)

// 阻塞发送，如果满了就等待
sub.eventChan <- event
```

**Option C: Ring Buffer with Overwrite + Sequence Number**
```go
// 客户端通过 sequence number 检测丢失
// 丢失时请求重新同步
```

### Decision: Option A (Blocking with Timeout) ✅
- 不丢数据
- 慢客户端会被断开，需要重连和重新同步
- 配合客户端的断线重连机制

### Changes Required
1. `internal/streamer/service.go` - 修改发送逻辑，不允许 drop
2. `internal/streamer/internal/manager/subscriber.go` - 添加 timeout 配置
3. 添加 metrics 监控慢客户端

---

## Execution Plan

### Phase 1: Proto Fix
1. 修改 `streamer.proto` 添加 Filter/Value/ListValue 消息
2. 修改 SubscribeRequest：使用 `repeated Filter`，保留 `tenant`，移除 `document_id`
3. Regenerate Go code
4. 更新 CEL compiler 支持 Filter → CEL 转换
5. 更新 manager/service 使用新的 Filter 结构

### Phase 2: Interface Alignment
1. 重构 interface.go，Service 嵌入 Client
2. 更新 StreamerService 实现 Client 接口
3. 添加编译时检查
4. 更新测试

### Phase 3: Soft Delete
1. 实现 isDeleted / wasDeleted 检测
2. 在 Transform 中添加转换逻辑
3. 添加测试用例

### Phase 4: Backpressure
1. 修改发送逻辑为 blocking with timeout
2. 添加 timeout 配置
3. 添加 metrics
4. 更新测试

---

## Success Criteria

- [ ] Proto 使用结构化 Filter 消息
- [ ] `var _ Client = (*StreamerService)(nil)` 编译通过
- [ ] Soft delete UPDATE → DELETE 转换正确
- [ ] Undelete UPDATE → INSERT 转换正确
- [ ] 事件发送不会 drop，只会 timeout 断开
- [ ] 所有现有测试通过
- [ ] 新增测试覆盖所有修复点
