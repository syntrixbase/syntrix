# Index Persistence with PebbleDB

**Date:** 2026-01-13
**Status:** Planned
**Scope:** Persistent storage for indexes using PebbleDB
**Depends on:** 017 (Index Layer), 034 (Query-Indexer Integration)

## Overview

Replace in-memory BTree indexes with PebbleDB-backed persistent storage. This enables:
- Fast recovery on restart (no full rebuild)
- Bounded memory usage
- Durability guarantees

Design doc: [docs/design/server/indexer/04.persistence.md](../docs/design/server/indexer/04.persistence.md)

---

## Phase 1: Store Interface & PebbleDB Setup

### Task 1.1: Define Store Interface

**File:** `internal/indexer/internal/store/store.go`

- [ ] Define `Store` interface
- [ ] Define `SearchOptions` struct
- [ ] Define `IndexState` enum
- [ ] Define `DocRef` (reuse from manager)

```go
type Store interface {
    Upsert(db, pattern, tmplID, docID string, orderKey []byte) error
    Delete(db, pattern, tmplID, docID string) error
    Get(db, pattern, tmplID, docID string) ([]byte, bool)
    Search(db, pattern, tmplID string, opts SearchOptions) ([]DocRef, error)
    DeleteIndex(db, pattern, tmplID string) error
    SetState(db, pattern, tmplID string, state IndexState) error
    GetState(db, pattern, tmplID string) (IndexState, error)
    SaveProgress(eventID string) error
    LoadProgress() (string, error)
    Flush() error
    Close() error
}
```

### Task 1.2: PebbleDB Initialization

**File:** `internal/indexer/internal/store/pebble.go`

- [ ] Create `PebbleStore` struct
- [ ] Implement `New(cfg StoreConfig) (*PebbleStore, error)`
- [ ] Configure PebbleDB options (block cache, etc.)
- [ ] Implement `Close()` with panic recovery
- [ ] Add config struct to `internal/indexer/config/config.go`

### Task 1.3: Key Encoding Helpers

**File:** `internal/indexer/internal/store/keys.go`

- [ ] `indexKey(db, pattern, tmplID string, orderKey []byte) []byte`
- [ ] `reverseKey(db, pattern, tmplID, docID string) []byte`
- [ ] `metaStateKey(db, pattern, tmplID string) []byte`
- [ ] `parseIndexKey(key []byte) (db, pattern, tmplID string, orderKey []byte)`
- [ ] URL encoding for path components

---

## Phase 2: Synchronous Operations

### Task 2.1: Basic CRUD Operations

**File:** `internal/indexer/internal/store/pebble.go`

- [ ] Implement synchronous `Upsert()` (for testing)
- [ ] Implement synchronous `Delete()`
- [ ] Implement `Get()`
- [ ] Use pebble.Batch for atomicity

### Task 2.2: Search Implementation

**File:** `internal/indexer/internal/store/reader.go`

- [ ] Implement `Search()` with PebbleDB iterator
- [ ] Build key range from SearchOptions
- [ ] Extract docID from index keys
- [ ] Apply limit and StartAfter

### Task 2.3: Index Management

**File:** `internal/indexer/internal/store/pebble.go`

- [ ] Implement `DeleteIndex()` - delete by prefix
- [ ] Implement `SetState()` / `GetState()`
- [ ] Implement `SaveProgress()` / `LoadProgress()`

### Task 2.4: Unit Tests

**File:** `internal/indexer/internal/store/pebble_test.go`

- [ ] Test Upsert + Get
- [ ] Test Upsert + Delete + Get
- [ ] Test Search with various bounds
- [ ] Test Search with StartAfter (pagination)
- [ ] Test DeleteIndex
- [ ] Test state persistence
- [ ] Test progress checkpoint

---

## Phase 3: Async Batching

### Task 3.1: Pending Queue Structure

**File:** `internal/indexer/internal/store/writer.go`

- [ ] Add `pending` and `flushing` maps to PebbleStore
- [ ] Add `pendingOp` struct
- [ ] Add notification channels
- [ ] Add batcher WaitGroup

### Task 3.2: Batcher Goroutine

**File:** `internal/indexer/internal/store/writer.go`

- [ ] Implement `startBatcher()`
- [ ] Implement `flush()` logic
- [ ] Handle BatchSize trigger
- [ ] Handle BatchInterval trigger
- [ ] Handle Close() trigger
- [ ] Error handling: close store on write failure

### Task 3.3: Async Upsert/Delete

**File:** `internal/indexer/internal/store/writer.go`

- [ ] Modify `Upsert()` to enqueue to pending
- [ ] Modify `Delete()` to enqueue to pending
- [ ] Add non-blocking notification

### Task 3.4: Search with Memory Merge

**File:** `internal/indexer/internal/store/reader.go`

- [ ] Snapshot pending + flushing at search start
- [ ] Merge memory ops with DB results
- [ ] Handle delete ops (skip deleted docs)
- [ ] Handle update ops (use memory version)
- [ ] Sort and limit final results

### Task 3.5: Async Tests

**File:** `internal/indexer/internal/store/writer_test.go`

- [ ] Test async write + immediate read (from pending)
- [ ] Test flush on BatchSize
- [ ] Test flush on BatchInterval
- [ ] Test flush on Close
- [ ] Test search sees pending writes
- [ ] Test concurrent writes

---

## Phase 4: Manager Integration

### Task 4.1: Replace In-Memory Index

**File:** `internal/indexer/internal/manager/manager.go`

- [ ] Add `Store` field to Manager
- [ ] Modify `New()` to accept Store option
- [ ] Delegate Upsert/Delete to Store
- [ ] Delegate Search to Store
- [ ] Keep template matching logic unchanged

### Task 4.2: Update Index Type

**File:** `internal/indexer/internal/index/index.go`

- [ ] Option A: Remove Index type entirely, use Store directly
- [ ] Option B: Make Index a thin wrapper over Store
- [ ] Decide based on code review

### Task 4.3: Service Integration

**File:** `internal/indexer/service.go`

- [ ] Initialize Store in service constructor
- [ ] Pass Store to Manager
- [ ] Load progress on Start()
- [ ] Save progress periodically
- [ ] Flush and close Store on Stop()

### Task 4.4: Config Integration

**File:** `internal/indexer/config/config.go`

- [ ] Add StoreConfig to indexer Config
- [ ] Add YAML tags
- [ ] Add defaults

**File:** `config/config.yml`

- [ ] Add indexer.store section

### Task 4.5: Integration Tests

**File:** `internal/indexer/integration_test.go`

- [ ] Test service restart recovery
- [ ] Test search after restart
- [ ] Test rebuild with persistence

---

## Phase 5: Rebuild Integration

### Task 5.1: Rebuild with Store

**File:** `internal/indexer/internal/rebuild/rebuild.go`

- [ ] Modify rebuild to use Store.DeleteIndex()
- [ ] Modify rebuild to use Store.SetState()
- [ ] Flush Store after rebuild complete

### Task 5.2: Startup Recovery

**File:** `internal/indexer/service.go`

- [ ] Load progress from Store on startup
- [ ] Check index states
- [ ] Resume or restart rebuilds as needed

---

## Phase 6: Memory Store Implementation

### Task 6.1: Memory Store

**File:** `internal/indexer/internal/store/memory.go`

- [ ] Implement `MemoryStore` with BTree + byID map
- [ ] Wrap existing Index logic to implement Store interface
- [ ] No async batching needed (direct writes)

### Task 6.2: Store Factory

**File:** `internal/indexer/internal/store/store.go`

- [ ] Add `storage_mode` config field
- [ ] Implement `NewStore(cfg)` factory function
- [ ] Support "memory" and "pebble" modes

### Task 6.3: Memory Store Tests

**File:** `internal/indexer/internal/store/memory_test.go`

- [ ] Ensure same test cases pass for both stores
- [ ] Use table-driven tests with store factory

---

## Acceptance Criteria

- [ ] All existing tests pass
- [ ] Memory mode: same behavior as current implementation
- [ ] Pebble mode: indexes recovered on restart in < 1s
- [ ] Pebble mode: memory usage bounded by block_cache_size
- [ ] Pebble mode: search latency < 2x memory for cached data
- [ ] Rebuild works with both storage modes
- [ ] Progress checkpoint survives restart (pebble mode)
- [ ] No data loss on graceful shutdown

---

## Estimated Effort

| Phase | Effort |
|-------|--------|
| Phase 1: Interface & Setup | 1 day |
| Phase 2: Sync Operations | 1 day |
| Phase 3: Async Batching | 2 days |
| Phase 4: Manager Integration | 1 day |
| Phase 5: Rebuild Integration | 1 day |
| Phase 6: Memory Store | 0.5 day |
| **Total** | **6.5 days** |
