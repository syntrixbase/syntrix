# Core Pubsub Layer Implementation

**Date:** 2026-01-14
**Status:** Planned
**Scope:** Generic pubsub abstraction in `internal/core/pubsub/`
**Depends on:** None

## Overview

Extract a generic pubsub abstraction from `internal/trigger/pubsub/` into `internal/core/pubsub/`. This enables reuse across services and decouples business logic from NATS transport details.

Design doc: [docs/design/server/core/01.pubsub.md](../docs/design/server/core/01.pubsub.md)

---

## Phase 1: Core Interfaces

### Task 1.1: Define Core Interfaces

**File:** `internal/core/pubsub/interfaces.go`

- [ ] Define `Message` interface
- [ ] Define `MessageMetadata` struct
- [ ] Define `Publisher` interface
- [ ] Define `Consumer` interface
- [ ] Define `MessageHandler` func type

```go
package pubsub

import (
    "context"
    "time"
)

// Message represents a received message with acknowledgment controls.
type Message interface {
    Data() []byte
    Subject() string
    Ack() error
    Nak() error
    NakWithDelay(delay time.Duration) error
    Term() error
    Metadata() (MessageMetadata, error)
}

type MessageMetadata struct {
    NumDelivered uint64
    Timestamp    time.Time
    Subject      string
    Stream       string
    Consumer     string
}

// Publisher publishes messages to a stream.
type Publisher interface {
    Publish(ctx context.Context, subject string, data []byte) error
    Close() error
}

// MessageHandler processes a single message.
type MessageHandler func(ctx context.Context, msg Message) error

// Consumer consumes messages from a stream.
type Consumer interface {
    Start(ctx context.Context, handler MessageHandler) error
}
```

### Task 1.2: Define Options

**File:** `internal/core/pubsub/options.go`

- [ ] Define `PublisherOptions` struct
- [ ] Define `ConsumerOptions` struct
- [ ] Define `Partitioner` func type

```go
package pubsub

import "time"

type PublisherOptions struct {
    StreamName    string
    SubjectPrefix string
    // OnPublish is called after each publish attempt (for metrics)
    OnPublish func(subject string, err error, latency time.Duration)
}

type ConsumerOptions struct {
    StreamName      string
    ConsumerName    string
    FilterSubject   string
    NumWorkers      int
    ChannelBufSize  int
    DrainTimeout    time.Duration
    ShutdownTimeout time.Duration
    // Partitioner assigns messages to workers. If nil, round-robin.
    Partitioner Partitioner
    // OnMessage is called after each message is processed (for metrics)
    OnMessage func(subject string, err error, latency time.Duration)
}

// Partitioner determines which worker handles a message.
type Partitioner func(data []byte) uint32
```

---

## Phase 2: NATS JetStream Implementation

### Task 2.1: Publisher Implementation

**File:** `internal/core/pubsub/nats/publisher.go`

- [ ] Create `jetStreamPublisher` struct
- [ ] Implement `NewPublisher(nc *nats.Conn, opts PublisherOptions) (Publisher, error)`
- [ ] Ensure stream exists on creation
- [ ] Implement `Publish(ctx, subject, data)` with subject prefix
- [ ] Implement `Close()`
- [ ] Call `OnPublish` callback if set

```go
package nats

import (
    "context"
    "time"

    "github.com/nats-io/nats.go"
    "github.com/nats-io/nats.go/jetstream"
    "github.com/syntrixbase/syntrix/internal/core/pubsub"
)

type jetStreamPublisher struct {
    js   jetstream.JetStream
    opts pubsub.PublisherOptions
}

func NewPublisher(nc *nats.Conn, opts pubsub.PublisherOptions) (pubsub.Publisher, error) {
    js, err := jetstream.New(nc)
    if err != nil {
        return nil, err
    }

    // Ensure stream exists
    _, err = js.CreateOrUpdateStream(context.Background(), jetstream.StreamConfig{
        Name:     opts.StreamName,
        Subjects: []string{opts.SubjectPrefix + ".>"},
        Storage:  jetstream.MemoryStorage,
    })
    if err != nil {
        return nil, err
    }

    return &jetStreamPublisher{js: js, opts: opts}, nil
}

func (p *jetStreamPublisher) Publish(ctx context.Context, subject string, data []byte) error {
    start := time.Now()
    fullSubject := p.opts.SubjectPrefix + "." + subject
    _, err := p.js.Publish(ctx, fullSubject, data)
    if p.opts.OnPublish != nil {
        p.opts.OnPublish(fullSubject, err, time.Since(start))
    }
    return err
}

func (p *jetStreamPublisher) Close() error {
    return nil // JetStream doesn't need explicit close
}
```

### Task 2.2: Message Wrapper

**File:** `internal/core/pubsub/nats/message.go`

- [ ] Create `natsMessage` struct wrapping `jetstream.Msg`
- [ ] Implement all `Message` interface methods
- [ ] Convert `jetstream.MsgMetadata` to `MessageMetadata`

```go
package nats

import (
    "time"

    "github.com/nats-io/nats.go/jetstream"
    "github.com/syntrixbase/syntrix/internal/core/pubsub"
)

type natsMessage struct {
    msg jetstream.Msg
}

func (m *natsMessage) Data() []byte    { return m.msg.Data() }
func (m *natsMessage) Subject() string { return m.msg.Subject() }
func (m *natsMessage) Ack() error      { return m.msg.Ack() }
func (m *natsMessage) Nak() error      { return m.msg.Nak() }
func (m *natsMessage) NakWithDelay(d time.Duration) error { return m.msg.NakWithDelay(d) }
func (m *natsMessage) Term() error     { return m.msg.Term() }

func (m *natsMessage) Metadata() (pubsub.MessageMetadata, error) {
    md, err := m.msg.Metadata()
    if err != nil {
        return pubsub.MessageMetadata{}, err
    }
    return pubsub.MessageMetadata{
        NumDelivered: md.NumDelivered,
        Timestamp:    md.Timestamp,
        Subject:      m.msg.Subject(),
        Stream:       md.Stream,
        Consumer:     md.Consumer,
    }, nil
}
```

### Task 2.3: Consumer Implementation

**File:** `internal/core/pubsub/nats/consumer.go`

- [ ] Create `jetStreamConsumer` struct
- [ ] Implement `NewConsumer(nc *nats.Conn, opts ConsumerOptions) (Consumer, error)`
- [ ] Implement worker pool initialization
- [ ] Implement message dispatch with partitioning
- [ ] Implement graceful shutdown (drain → close channels → wait)
- [ ] Call `OnMessage` callback if set

```go
package nats

import (
    "context"
    "hash/fnv"
    "log"
    "sync"
    "sync/atomic"
    "time"

    "github.com/nats-io/nats.go"
    "github.com/nats-io/nats.go/jetstream"
    "github.com/syntrixbase/syntrix/internal/core/pubsub"
)

type jetStreamConsumer struct {
    js          jetstream.JetStream
    opts        pubsub.ConsumerOptions
    workerChans []chan jetstream.Msg
    wg          sync.WaitGroup
    closing     atomic.Bool
    inFlight    atomic.Int32
}

func NewConsumer(nc *nats.Conn, opts pubsub.ConsumerOptions) (pubsub.Consumer, error) {
    js, err := jetstream.New(nc)
    if err != nil {
        return nil, err
    }

    // Apply defaults
    if opts.NumWorkers <= 0 {
        opts.NumWorkers = 16
    }
    if opts.ChannelBufSize <= 0 {
        opts.ChannelBufSize = 100
    }
    if opts.DrainTimeout <= 0 {
        opts.DrainTimeout = 5 * time.Second
    }
    if opts.ShutdownTimeout <= 0 {
        opts.ShutdownTimeout = 30 * time.Second
    }

    return &jetStreamConsumer{js: js, opts: opts}, nil
}

func (c *jetStreamConsumer) Start(ctx context.Context, handler pubsub.MessageHandler) error {
    // 1. Ensure stream exists
    // 2. Create durable consumer
    // 3. Initialize worker pool
    // 4. Consume with dispatch
    // 5. Graceful shutdown
    // (Follow pattern from existing consumer.go)
}
```

### Task 2.4: Connection Helper

**File:** `internal/core/pubsub/nats/connection.go`

- [ ] Create helper for testing: `var JetStreamNew = jetstream.New`
- [ ] Allow mocking in tests

```go
package nats

import (
    "github.com/nats-io/nats.go"
    "github.com/nats-io/nats.go/jetstream"
)

// JetStreamNew is a variable to allow mocking in tests.
var JetStreamNew = func(nc *nats.Conn) (jetstream.JetStream, error) {
    return jetstream.New(nc)
}
```

---

## Phase 3: Test Utilities

### Task 3.1: Mock Publisher

**File:** `internal/core/pubsub/testing/mock_publisher.go`

- [ ] Create `MockPublisher` struct
- [ ] Track published messages
- [ ] Allow injecting errors

```go
package testing

import (
    "context"
    "sync"
)

type PublishedMessage struct {
    Subject string
    Data    []byte
}

type MockPublisher struct {
    mu       sync.Mutex
    Messages []PublishedMessage
    Error    error
}

func (m *MockPublisher) Publish(ctx context.Context, subject string, data []byte) error {
    if m.Error != nil {
        return m.Error
    }
    m.mu.Lock()
    m.Messages = append(m.Messages, PublishedMessage{Subject: subject, Data: data})
    m.mu.Unlock()
    return nil
}

func (m *MockPublisher) Close() error { return nil }

func (m *MockPublisher) Reset() {
    m.mu.Lock()
    m.Messages = nil
    m.Error = nil
    m.mu.Unlock()
}
```

### Task 3.2: Mock Consumer

**File:** `internal/core/pubsub/testing/mock_consumer.go`

- [ ] Create `MockConsumer` struct
- [ ] Allow simulating messages
- [ ] Track handler calls

```go
package testing

import (
    "context"
    "sync"
    "time"

    "github.com/syntrixbase/syntrix/internal/core/pubsub"
)

type MockMessage struct {
    data    []byte
    subject string
    acked   bool
    naked   bool
    termed  bool
}

func (m *MockMessage) Data() []byte    { return m.data }
func (m *MockMessage) Subject() string { return m.subject }
func (m *MockMessage) Ack() error      { m.acked = true; return nil }
func (m *MockMessage) Nak() error      { m.naked = true; return nil }
func (m *MockMessage) NakWithDelay(d time.Duration) error { m.naked = true; return nil }
func (m *MockMessage) Term() error     { m.termed = true; return nil }
func (m *MockMessage) Metadata() (pubsub.MessageMetadata, error) {
    return pubsub.MessageMetadata{NumDelivered: 1}, nil
}

type MockConsumer struct {
    mu      sync.Mutex
    handler pubsub.MessageHandler
    started bool
}

func (c *MockConsumer) Start(ctx context.Context, handler pubsub.MessageHandler) error {
    c.mu.Lock()
    c.handler = handler
    c.started = true
    c.mu.Unlock()
    <-ctx.Done()
    return nil
}

func (c *MockConsumer) SimulateMessage(ctx context.Context, subject string, data []byte) error {
    c.mu.Lock()
    h := c.handler
    c.mu.Unlock()
    if h == nil {
        return nil
    }
    return h(ctx, &MockMessage{data: data, subject: subject})
}
```

---

## Phase 4: Unit Tests

### Task 4.1: Publisher Tests

**File:** `internal/core/pubsub/nats/publisher_test.go`

- [ ] Test `NewPublisher` creates stream
- [ ] Test `Publish` sends to correct subject
- [ ] Test `OnPublish` callback is called
- [ ] Test error handling

### Task 4.2: Consumer Tests

**File:** `internal/core/pubsub/nats/consumer_test.go`

- [ ] Test `NewConsumer` with default options
- [ ] Test `Start` creates worker pool
- [ ] Test message dispatch to correct worker
- [ ] Test partitioner function
- [ ] Test graceful shutdown sequence
- [ ] Test drain timeout handling

### Task 4.3: Message Tests

**File:** `internal/core/pubsub/nats/message_test.go`

- [ ] Test all `Message` interface methods
- [ ] Test `Metadata` conversion

---

## Phase 5: Integration with Trigger

### Task 5.1: Trigger TaskPublisher Adapter

**File:** `internal/trigger/evaluator/publisher.go` (new location)

- [ ] Create `TaskPublisher` wrapping `pubsub.Publisher`
- [ ] Handle `DeliveryTask` serialization
- [ ] Build subject from task fields
- [ ] Maintain metrics integration

```go
package evaluator

import (
    "context"
    "encoding/json"
    "fmt"

    "github.com/syntrixbase/syntrix/internal/core/pubsub"
    "github.com/syntrixbase/syntrix/internal/trigger/types"
)

type TaskPublisher struct {
    pub     pubsub.Publisher
    metrics types.Metrics
}

func NewTaskPublisher(pub pubsub.Publisher, metrics types.Metrics) *TaskPublisher {
    return &TaskPublisher{pub: pub, metrics: metrics}
}

func (p *TaskPublisher) Publish(ctx context.Context, task *types.DeliveryTask) error {
    data, err := json.Marshal(task)
    if err != nil {
        return err
    }
    subject := fmt.Sprintf("%s.%s.%s", task.Database, task.Collection, task.DocumentID)
    return p.pub.Publish(ctx, subject, data)
}

func (p *TaskPublisher) Close() error {
    return p.pub.Close()
}
```

### Task 5.2: Trigger TaskConsumer Adapter

**File:** `internal/trigger/delivery/consumer.go` (new location)

- [ ] Create `TaskConsumer` wrapping `pubsub.Consumer`
- [ ] Handle `DeliveryTask` deserialization
- [ ] Integrate with `DeliveryWorker`
- [ ] Handle retry logic with `FatalError` detection
- [ ] Maintain metrics integration

---

## Phase 6: Cleanup Old Code

### Task 6.1: Remove Old pubsub Package

- [ ] Verify all usages migrated to new packages
- [ ] Delete `internal/trigger/pubsub/publisher.go`
- [ ] Delete `internal/trigger/pubsub/consumer.go`
- [ ] Delete `internal/trigger/pubsub/interfaces.go`
- [ ] Delete `internal/trigger/pubsub/vars.go`
- [ ] Update imports in all affected files

### Task 6.2: Update Design Docs

- [ ] Update `docs/design/server/trigger/01.architecture.md`
- [ ] Update `docs/design/server/trigger/02.interfaces.md`
- [ ] Add `docs/design/server/core/01.pubsub.md` to index

---

## Acceptance Criteria

- [ ] All existing trigger tests pass
- [ ] New pubsub unit tests pass with >80% coverage
- [ ] Integration test with embedded NATS works
- [ ] `make test` passes
- [ ] `make coverage` shows no critical issues in new code
