# Core Pubsub Layer Implementation

**Date:** 2026-01-14
**Status:** In Progress
**Scope:** Generic pubsub abstraction in `internal/core/pubsub/`
**Depends on:** None

## Overview

Extract a generic pubsub abstraction from `internal/trigger/pubsub/` into `internal/core/pubsub/`. This enables reuse across services and decouples business logic from NATS transport details.

Design doc: [docs/design/server/core/01.pubsub.md](../docs/design/server/core/01.pubsub.md)

---

## Phase 1: Core Interfaces

### Task 1.1: Define Core Interfaces

**File:** `internal/core/pubsub/interfaces.go`

- [x] Define `Message` interface
- [x] Define `MessageMetadata` struct
- [x] Define `Publisher` interface
- [x] Define `Consumer` interface (Subscribe pattern)

```go
package pubsub

import (
    "context"
    "time"
)

// Message represents a received message with acknowledgment controls.
type Message interface {
    Data() []byte
    Subject() string
    Ack() error
    Nak() error
    NakWithDelay(delay time.Duration) error
    Term() error
    Metadata() (MessageMetadata, error)
}

type MessageMetadata struct {
    NumDelivered uint64
    Timestamp    time.Time
    Subject      string
    Stream       string
    Consumer     string
}

// Publisher publishes messages to a stream.
type Publisher interface {
    Publish(ctx context.Context, subject string, data []byte) error
    Close() error
}

// Consumer consumes messages from a stream.
type Consumer interface {
    // Subscribe starts consuming messages and returns a channel.
    // The channel is closed when the context is cancelled or an error occurs.
    // Caller is responsible for calling Ack/Nak/Term on each message.
    Subscribe(ctx context.Context) (<-chan Message, error)
}
```

### Task 1.2: Define Options

**File:** `internal/core/pubsub/options.go`

- [x] Define `PublisherOptions` struct
- [x] Define `ConsumerOptions` struct

```go
package pubsub

import "time"

type PublisherOptions struct {
    StreamName    string
    SubjectPrefix string
    // OnPublish is called after each publish attempt (for metrics)
    OnPublish func(subject string, err error, latency time.Duration)
}

type ConsumerOptions struct {
    StreamName     string
    ConsumerName   string
    FilterSubject  string
    ChannelBufSize int
}

// DefaultConsumerOptions returns ConsumerOptions with sensible defaults.
func DefaultConsumerOptions() ConsumerOptions {
    return ConsumerOptions{
        ChannelBufSize: 100,
    }
}
```

---

## Phase 2: NATS JetStream Implementation

### Task 2.1: Publisher Implementation

**File:** `internal/core/pubsub/nats/publisher.go`

- [x] Create `jetStreamPublisher` struct
- [x] Implement `NewPublisher(js JetStream, opts PublisherOptions) (Publisher, error)`
- [x] Ensure stream exists on creation (if StreamName provided)
- [x] Implement `Publish(ctx, subject, data)` with subject prefix
- [x] Implement `Close()`
- [x] Call `OnPublish` callback if set

```go
package nats

import (
    "context"
    "time"

    "github.com/syntrixbase/syntrix/internal/core/pubsub"
)

type jetStreamPublisher struct {
    js   JetStream
    opts pubsub.PublisherOptions
}

func NewPublisher(js JetStream, opts pubsub.PublisherOptions) (pubsub.Publisher, error) {
    if js == nil {
        return nil, fmt.Errorf("jetstream cannot be nil")
    }

    // Ensure stream exists if StreamName provided
    if opts.StreamName != "" {
        subjects := []string{opts.StreamName + ".>"}
        if opts.SubjectPrefix != "" {
            subjects = []string{opts.SubjectPrefix + ".>"}
        }
        _, err := js.CreateOrUpdateStream(context.Background(), jetstream.StreamConfig{
            Name:     opts.StreamName,
            Subjects: subjects,
            Storage:  jetstream.MemoryStorage,
        })
        if err != nil {
            return nil, err
        }
    }

    return &jetStreamPublisher{js: js, opts: opts}, nil
}

func (p *jetStreamPublisher) Publish(ctx context.Context, subject string, data []byte) error {
    start := time.Now()
    fullSubject := subject
    if p.opts.SubjectPrefix != "" {
        fullSubject = p.opts.SubjectPrefix + "." + subject
    }
    _, err := p.js.Publish(ctx, fullSubject, data)
    if p.opts.OnPublish != nil {
        p.opts.OnPublish(fullSubject, err, time.Since(start))
    }
    return err
}

func (p *jetStreamPublisher) Close() error {
    return nil // JetStream doesn't need explicit close
}
```

### Task 2.2: Message Wrapper

**File:** `internal/core/pubsub/nats/message.go`

- [x] Create `natsMessage` struct wrapping `jetstream.Msg`
- [x] Implement all `Message` interface methods
- [x] Convert `jetstream.MsgMetadata` to `MessageMetadata`
- [x] Export `WrapMessage(msg jetstream.Msg)` helper

```go
package nats

import (
    "time"

    "github.com/nats-io/nats.go/jetstream"
    "github.com/syntrixbase/syntrix/internal/core/pubsub"
)

type natsMessage struct {
    msg jetstream.Msg
}

// WrapMessage wraps a jetstream.Msg as a pubsub.Message.
func WrapMessage(msg jetstream.Msg) pubsub.Message {
    return &natsMessage{msg: msg}
}

func (m *natsMessage) Data() []byte    { return m.msg.Data() }
func (m *natsMessage) Subject() string { return m.msg.Subject() }
func (m *natsMessage) Ack() error      { return m.msg.Ack() }
func (m *natsMessage) Nak() error      { return m.msg.Nak() }
func (m *natsMessage) NakWithDelay(d time.Duration) error { return m.msg.NakWithDelay(d) }
func (m *natsMessage) Term() error     { return m.msg.Term() }

func (m *natsMessage) Metadata() (pubsub.MessageMetadata, error) {
    md, err := m.msg.Metadata()
    if err != nil {
        return pubsub.MessageMetadata{}, err
    }
    return pubsub.MessageMetadata{
        NumDelivered: md.NumDelivered,
        Timestamp:    md.Timestamp,
        Subject:      m.msg.Subject(),
        Stream:       md.Stream,
        Consumer:     md.Consumer,
    }, nil
}
```

### Task 2.3: Consumer Implementation

**File:** `internal/core/pubsub/nats/consumer.go`

- [x] Create `jetStreamConsumer` struct
- [x] Implement `NewConsumer(js JetStream, opts ConsumerOptions) (Consumer, error)`
- [x] Implement `Subscribe(ctx)` returning message channel
- [x] Implement graceful shutdown on context cancellation

```go
package nats

import (
    "context"
    "fmt"
    "log"
    "sync/atomic"

    "github.com/nats-io/nats.go/jetstream"
    "github.com/syntrixbase/syntrix/internal/core/pubsub"
)

type jetStreamConsumer struct {
    js   JetStream
    opts pubsub.ConsumerOptions
}

func NewConsumer(js JetStream, opts pubsub.ConsumerOptions) (pubsub.Consumer, error) {
    if js == nil {
        return nil, fmt.Errorf("jetstream cannot be nil")
    }
    if opts.StreamName == "" {
        return nil, fmt.Errorf("stream name is required")
    }

    // Apply defaults
    if opts.ChannelBufSize <= 0 {
        opts.ChannelBufSize = pubsub.DefaultConsumerOptions().ChannelBufSize
    }

    return &jetStreamConsumer{js: js, opts: opts}, nil
}

func (c *jetStreamConsumer) Subscribe(ctx context.Context) (<-chan pubsub.Message, error) {
    // Ensure stream exists
    filterSubject := c.opts.FilterSubject
    if filterSubject == "" {
        filterSubject = c.opts.StreamName + ".>"
    }

    _, err := c.js.CreateOrUpdateStream(ctx, jetstream.StreamConfig{
        Name:     c.opts.StreamName,
        Subjects: []string{filterSubject},
        Storage:  jetstream.MemoryStorage,
    })
    if err != nil {
        return nil, fmt.Errorf("failed to ensure stream: %w", err)
    }

    // Create durable consumer
    consumerName := c.opts.ConsumerName
    if consumerName == "" {
        consumerName = "consumer"
    }

    consumer, err := c.js.CreateOrUpdateConsumer(ctx, c.opts.StreamName, jetstream.ConsumerConfig{
        Durable:       consumerName,
        AckPolicy:     jetstream.AckExplicitPolicy,
        FilterSubject: filterSubject,
    })
    if err != nil {
        return nil, fmt.Errorf("failed to create consumer: %w", err)
    }

    // Create message channel
    msgCh := make(chan pubsub.Message, c.opts.ChannelBufSize)

    // Track if we're closing
    var closing atomic.Bool

    // Start consuming
    cc, err := consumer.Consume(func(msg jetstream.Msg) {
        if closing.Load() {
            msg.Nak()
            return
        }
        select {
        case msgCh <- WrapMessage(msg):
        case <-ctx.Done():
            msg.Nak()
        }
    })
    if err != nil {
        close(msgCh)
        return nil, fmt.Errorf("failed to start consumer: %w", err)
    }

    // Goroutine to handle shutdown
    go func() {
        <-ctx.Done()
        closing.Store(true)
        cc.Stop()
        close(msgCh)
    }()

    return msgCh, nil
}
```

### Task 2.4: Connection Helper

**File:** `internal/core/pubsub/nats/connection.go`

- [x] Define `JetStream` interface for testability
- [x] Create `NewJetStream(nc *nats.Conn) (JetStream, error)` helper

```go
package nats

import (
    "context"
    "fmt"

    "github.com/nats-io/nats.go"
    "github.com/nats-io/nats.go/jetstream"
)

// JetStream defines the minimal JetStream interface needed by this package.
type JetStream interface {
    CreateOrUpdateStream(ctx context.Context, cfg jetstream.StreamConfig) (jetstream.Stream, error)
    CreateOrUpdateConsumer(ctx context.Context, stream string, cfg jetstream.ConsumerConfig) (jetstream.Consumer, error)
    Publish(ctx context.Context, subject string, data []byte, opts ...jetstream.PublishOpt) (*jetstream.PubAck, error)
}

// NewJetStream creates a JetStream instance from a NATS connection.
func NewJetStream(nc *nats.Conn) (JetStream, error) {
    if nc == nil {
        return nil, fmt.Errorf("nats connection cannot be nil")
    }
    return jetstream.New(nc)
}
```

---

## Phase 3: Test Utilities

### Task 3.1: Mock Publisher

**File:** `internal/core/pubsub/testing/mock.go`

- [x] Create `MockPublisher` struct
- [x] Track published messages
- [x] Allow injecting errors

```go
package testing

import (
    "context"
    "sync"
)

type PublishedMessage struct {
    Subject string
    Data    []byte
}

type MockPublisher struct {
    mu       sync.Mutex
    Messages []PublishedMessage
    Error    error
}

func (m *MockPublisher) Publish(ctx context.Context, subject string, data []byte) error {
    if m.Error != nil {
        return m.Error
    }
    m.mu.Lock()
    m.Messages = append(m.Messages, PublishedMessage{Subject: subject, Data: data})
    m.mu.Unlock()
    return nil
}

func (m *MockPublisher) Close() error { return nil }

func (m *MockPublisher) Reset() {
    m.mu.Lock()
    m.Messages = nil
    m.Error = nil
    m.mu.Unlock()
}
```

### Task 3.2: Mock Consumer

**File:** `internal/core/pubsub/testing/mock.go`

- [x] Create `MockConsumer` struct with Subscribe pattern
- [x] Allow simulating messages via `Send()` method
- [x] Track subscription state via `IsStarted()`
- [x] Create `MockMessage` struct with all state tracking

```go
package testing

import (
    "context"
    "sync"
    "time"

    "github.com/syntrixbase/syntrix/internal/core/pubsub"
)

type MockMessage struct {
    data     []byte
    subject  string
    metadata pubsub.MessageMetadata
    acked    bool
    naked    bool
    termed   bool
}

func NewMockMessage(subject string, data []byte) *MockMessage {
    return &MockMessage{
        subject: subject,
        data:    data,
        metadata: pubsub.MessageMetadata{
            NumDelivered: 1,
            Timestamp:    time.Now(),
            Subject:      subject,
        },
    }
}

func (m *MockMessage) Data() []byte    { return m.data }
func (m *MockMessage) Subject() string { return m.subject }
func (m *MockMessage) Ack() error      { m.acked = true; return nil }
func (m *MockMessage) Nak() error      { m.naked = true; return nil }
func (m *MockMessage) NakWithDelay(d time.Duration) error { m.naked = true; return nil }
func (m *MockMessage) Term() error     { m.termed = true; return nil }
func (m *MockMessage) Metadata() (pubsub.MessageMetadata, error) {
    return m.metadata, nil
}

type MockConsumer struct {
    mu      sync.Mutex
    msgCh   chan pubsub.Message
    started bool
    err     error
}

func NewMockConsumer() *MockConsumer {
    return &MockConsumer{}
}

func (c *MockConsumer) Subscribe(ctx context.Context) (<-chan pubsub.Message, error) {
    c.mu.Lock()
    defer c.mu.Unlock()

    if c.err != nil {
        return nil, c.err
    }

    c.msgCh = make(chan pubsub.Message, 100)
    c.started = true

    // Close channel when context is done
    go func() {
        <-ctx.Done()
        c.mu.Lock()
        if c.msgCh != nil {
            close(c.msgCh)
            c.msgCh = nil
        }
        c.mu.Unlock()
    }()

    return c.msgCh, nil
}

func (c *MockConsumer) Send(msg pubsub.Message) {
    c.mu.Lock()
    ch := c.msgCh
    c.mu.Unlock()
    if ch != nil {
        ch <- msg
    }
}

func (c *MockConsumer) IsStarted() bool {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.started
}
```

---

## Phase 4: Unit Tests

### Task 4.1: Publisher Tests

**File:** `internal/core/pubsub/nats/publisher_test.go`

- [x] Test `NewPublisher` creates stream
- [x] Test `Publish` sends to correct subject
- [x] Test `OnPublish` callback is called
- [x] Test error handling

### Task 4.2: Consumer Tests

**File:** `internal/core/pubsub/nats/publisher_test.go` (consumer tests included)

- [x] Test `NewConsumer` with default options
- [x] Test `Subscribe` creates durable consumer
- [x] Test message dispatch through channel
- [x] Test graceful shutdown on context cancellation

### Task 4.3: Message Tests

**File:** `internal/core/pubsub/nats/nats_test.go`

- [x] Test all `Message` interface methods
- [x] Test `Metadata` conversion

---

## Phase 5: Integration with Trigger

### Task 5.1: Trigger TaskPublisher Adapter

**File:** `internal/trigger/evaluator/publisher.go` (new location)

- [ ] Create `TaskPublisher` wrapping `pubsub.Publisher`
- [ ] Handle `DeliveryTask` serialization
- [ ] Build subject from task fields
- [ ] Maintain metrics integration

```go
package evaluator

import (
    "context"
    "encoding/json"
    "fmt"

    "github.com/syntrixbase/syntrix/internal/core/pubsub"
    "github.com/syntrixbase/syntrix/internal/trigger/types"
)

type TaskPublisher struct {
    pub     pubsub.Publisher
    metrics types.Metrics
}

func NewTaskPublisher(pub pubsub.Publisher, metrics types.Metrics) *TaskPublisher {
    return &TaskPublisher{pub: pub, metrics: metrics}
}

func (p *TaskPublisher) Publish(ctx context.Context, task *types.DeliveryTask) error {
    data, err := json.Marshal(task)
    if err != nil {
        return err
    }
    subject := fmt.Sprintf("%s.%s.%s", task.Database, task.Collection, task.DocumentID)
    return p.pub.Publish(ctx, subject, data)
}

func (p *TaskPublisher) Close() error {
    return p.pub.Close()
}
```

### Task 5.2: Trigger TaskConsumer Adapter

**File:** `internal/trigger/delivery/consumer.go` (new location)

- [ ] Create `TaskConsumer` wrapping `pubsub.Consumer`
- [ ] Handle `DeliveryTask` deserialization
- [ ] Integrate with `DeliveryWorker`
- [ ] Handle retry logic with `FatalError` detection
- [ ] Maintain metrics integration

---

## Phase 6: Cleanup Old Code

### Task 6.1: Remove Old pubsub Package

- [ ] Verify all usages migrated to new packages
- [ ] Delete `internal/trigger/pubsub/publisher.go`
- [ ] Delete `internal/trigger/pubsub/consumer.go`
- [ ] Delete `internal/trigger/pubsub/interfaces.go`
- [ ] Delete `internal/trigger/pubsub/vars.go`
- [ ] Update imports in all affected files

### Task 6.2: Update Design Docs

- [ ] Update `docs/design/server/trigger/01.architecture.md`
- [ ] Update `docs/design/server/trigger/02.interfaces.md`
- [ ] Add `docs/design/server/core/01.pubsub.md` to index

---

## Acceptance Criteria

- [ ] All existing trigger tests pass
- [ ] New pubsub unit tests pass with >80% coverage
- [ ] Integration test with embedded NATS works
- [ ] `make test` passes
- [ ] `make coverage` shows no critical issues in new code
