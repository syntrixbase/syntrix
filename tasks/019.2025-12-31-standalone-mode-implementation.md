# Standalone Mode Implementation Plan

**Date:** December 31, 2025
**Status:** Planning
**Design Doc:** [docs/design/server/012_standalone_mode.md](../docs/design/server/012_standalone_mode.md)
**Est. Timeline:** 3-4 days

## Overview

Implement standalone deployment mode that packages all Syntrix services into a single process, replacing inter-service network communication with direct function calls.

## Current Code Analysis

### Key Files and Current Behavior

| File | Current Behavior | Required Change |
|------|------------------|-----------------|
| `cmd/syntrix/main.go` | Parses `--api`, `--csp`, `--query` flags | Add `--standalone` flag |
| `internal/services/manager.go` | `Options` struct with boolean flags | Add `Mode DeploymentMode` field |
| `internal/services/manager_init.go` | Creates HTTP servers for each service | Conditional: skip HTTP servers in standalone |
| `internal/engine/internal/core/engine.go` | `cspURL string` + HTTP client | Replace with `csp.Service` interface |
| `internal/engine/interface.go` | `NewService(store, cspURL string)` | Add `NewServiceWithCSP(store, cspService)` |
| `internal/csp/server.go` | HTTP server only | Extract core logic to `Service` interface |

### Inter-Service Communication Points

```
┌─────────────────────────────────────────────────────────────────────────┐
│ Communication Point 1: API Gateway → Query Service                      │
├─────────────────────────────────────────────────────────────────────────┤
│ Current:  engine.NewClient(cfg.Gateway.QueryServiceURL) → HTTP client   │
│ Location: internal/services/manager_init.go:55-60                       │
│ Change:   In standalone, use queryService directly (already supported)  │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ Communication Point 2: Query Engine → CSP Service                       │
├─────────────────────────────────────────────────────────────────────────┤
│ Current:  http.POST to cspURL + "/internal/v1/watch"                    │
│ Location: internal/engine/internal/core/engine.go:191-235               │
│ Change:   Call csp.Service.Watch() interface method directly            │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ Communication Point 3: Trigger Services → NATS                          │
├─────────────────────────────────────────────────────────────────────────┤
│ Current:  nats.Connect(natsURL) to external NATS server                 │
│ Location: internal/services/manager_init.go:177-182                     │
│ Change:   Option to use embedded NATS server                            │
└─────────────────────────────────────────────────────────────────────────┘
```

## Implementation Tasks

### Phase 1: CSP Service Interface (Day 1)

#### Task 1.1: Create CSP Service Interface

**File:** `internal/csp/interface.go` (new)

```go
// Target implementation
package csp

import (
    "context"
    "github.com/codetrek/syntrix/internal/storage"
)

// Service defines the interface for Change Stream processing.
type Service interface {
    // Watch returns a channel of events for a collection.
    // Pass empty string for collection to watch all collections.
    Watch(ctx context.Context, tenant, collection string) (<-chan storage.Event, error)
}
```

**Steps:**
1. Create `internal/csp/interface.go` with `Service` interface
2. Add interface documentation

#### Task 1.2: Implement LocalService

**File:** `internal/csp/local_service.go` (new)

Extract core logic from `server.go:handleWatch()`:

```go
// Target implementation
package csp

type LocalService struct {
    storage storage.DocumentStore
}

func NewLocalService(store storage.DocumentStore) *LocalService {
    return &LocalService{storage: store}
}

func (s *LocalService) Watch(ctx context.Context, tenant, collection string) (<-chan storage.Event, error) {
    // Direct call to storage.Watch() - extracted from handleWatch()
    return s.storage.Watch(ctx, tenant, collection, nil, storage.WatchOptions{})
}
```

**Steps:**
1. Create `internal/csp/local_service.go`
2. Implement `LocalService` struct
3. Extract watch logic from `server.go`

#### Task 1.3: Implement RemoteClient

**File:** `internal/csp/remote_client.go` (new)

Extract HTTP client logic from `engine.go:WatchCollection()`:

```go
// Target implementation
package csp

type RemoteClient struct {
    baseURL string
    client  *http.Client
}

func NewRemoteClient(baseURL string) *RemoteClient {
    return &RemoteClient{baseURL: baseURL, client: &http.Client{}}
}

func (c *RemoteClient) Watch(ctx context.Context, tenant, collection string) (<-chan storage.Event, error) {
    // HTTP POST to /internal/v1/watch - extracted from engine.go
}
```

**Steps:**
1. Create `internal/csp/remote_client.go`
2. Move HTTP logic from `engine.go:191-235` to this file
3. Implement streaming JSON decoder

#### Task 1.4: Add Unit Tests

**Files:**
- `internal/csp/local_service_test.go` (new)
- `internal/csp/remote_client_test.go` (new)

**Coverage targets:**
- `LocalService.Watch()` - mock storage
- `RemoteClient.Watch()` - httptest server

#### Task 1.5: Coverage Verification

```bash
make coverage
./scripts/uncovered_blocks.sh | grep -A5 "internal/csp"
```

**Acceptance Criteria:**
- [ ] `internal/csp` package coverage ≥ 80%
- [ ] All existing tests pass
- [ ] No new uncovered blocks in critical paths

---

### Phase 2: Engine Refactor (Day 1-2)

#### Task 2.1: Modify Engine to Use CSP Interface

**File:** `internal/engine/internal/core/engine.go`

**Current code (lines 17-30):**
```go
type Engine struct {
    storage storage.DocumentStore
    cspURL  string           // ← Remove
    client  *http.Client     // ← Remove
}

func New(storage storage.DocumentStore, cspURL string) *Engine {
    return &Engine{
        storage: storage,
        cspURL:  cspURL,      // ← Remove
        client:  &http.Client{}, // ← Remove
    }
}
```

**Target code:**
```go
type Engine struct {
    storage    storage.DocumentStore
    cspService csp.Service  // ← New field
}

func New(storage storage.DocumentStore, cspService csp.Service) *Engine {
    return &Engine{
        storage:    storage,
        cspService: cspService,
    }
}
```

**Steps:**
1. Add import for `internal/csp`
2. Replace `cspURL string` with `cspService csp.Service`
3. Remove `client *http.Client` field
4. Remove `SetHTTPClient()` method
5. Update `New()` constructor signature

#### Task 2.2: Update WatchCollection Method

**File:** `internal/engine/internal/core/engine.go`

**Current code (lines 191-235):**
```go
func (e *Engine) WatchCollection(ctx context.Context, tenant string, collection string) (<-chan storage.Event, error) {
    reqBody, err := json.Marshal(map[string]string{...})
    // ... 45 lines of HTTP client code
}
```

**Target code:**
```go
func (e *Engine) WatchCollection(ctx context.Context, tenant string, collection string) (<-chan storage.Event, error) {
    return e.cspService.Watch(ctx, tenant, collection)
}
```

**Steps:**
1. Replace entire method body with single interface call
2. Remove unused imports (`bytes`, `fmt`, parts of `net/http`)

#### Task 2.3: Update Public Interface

**File:** `internal/engine/interface.go`

**Current code (line 31):**
```go
func NewService(store storage.DocumentStore, cspURL string) Service {
    return core.New(store, cspURL)
}
```

**Target code:**
```go
// NewService creates a new local Query Service with CSP client.
// For standalone mode, use NewServiceWithCSP with a LocalService.
func NewService(store storage.DocumentStore, cspURL string) Service {
    return core.New(store, csp.NewRemoteClient(cspURL))
}

// NewServiceWithCSP creates a Query Service with a custom CSP implementation.
// Use this for standalone mode with csp.NewLocalService().
func NewServiceWithCSP(store storage.DocumentStore, cspService csp.Service) Service {
    return core.New(store, cspService)
}
```

**Steps:**
1. Add `NewServiceWithCSP()` function
2. Update `NewService()` to wrap `csp.NewRemoteClient()`
3. Maintain backward compatibility

#### Task 2.4: Update Engine Tests

**File:** `internal/engine/internal/core/engine_coverage_test.go`

**Changes needed:**
- Update test setup to use mock `csp.Service`
- Remove HTTP test servers for CSP
- Simplify `TestWatchCollection_*` tests

#### Task 2.5: Coverage Verification

```bash
make coverage
./scripts/uncovered_blocks.sh | grep -A5 "internal/engine"
```

**Acceptance Criteria:**
- [ ] `internal/engine` package coverage ≥ current baseline
- [ ] `WatchCollection` method fully covered
- [ ] All `TestWatchCollection_*` tests pass with new mock
- [ ] No regression in other engine tests

---

### Phase 3: Service Manager Refactor (Day 2)

#### Task 3.1: Add DeploymentMode

**File:** `internal/services/manager.go`

**Current code (lines 16-26):**
```go
type Options struct {
    RunAPI              bool
    RunCSP              bool
    RunQuery            bool
    RunTriggerEvaluator bool
    RunTriggerWorker    bool
    ListenHost          string
    ForceQueryClient    bool
}
```

**Target code:**
```go
type DeploymentMode int

const (
    ModeDistributed DeploymentMode = iota  // Default: HTTP between services
    ModeStandalone                          // All-in-one: direct function calls
)

type Options struct {
    RunAPI              bool
    RunCSP              bool
    RunQuery            bool
    RunTriggerEvaluator bool
    RunTriggerWorker    bool
    ListenHost          string
    ForceQueryClient    bool
    
    Mode DeploymentMode  // New field
}
```

**Steps:**
1. Add `DeploymentMode` type and constants
2. Add `Mode` field to `Options`

#### Task 3.2: Update Manager Initialization

**File:** `internal/services/manager_init.go`

**Current code (lines 45-67):**
```go
func (m *Manager) Init(ctx context.Context) error {
    // ...
    var queryService engine.Service

    if m.opts.RunQuery {
        qs := m.initQueryServices()
        if !m.opts.ForceQueryClient {
            queryService = qs
        }
    }

    if m.opts.RunAPI {
        if queryService == nil {
            queryService = engine.NewClient(m.cfg.Gateway.QueryServiceURL)
        }
        // ...
    }

    if m.opts.RunCSP {
        m.initCSPServer()
    }
    // ...
}
```

**Target code:**
```go
func (m *Manager) Init(ctx context.Context) error {
    // ...
    
    // Initialize CSP service based on mode
    var cspService csp.Service
    if m.opts.Mode == ModeStandalone {
        cspService = csp.NewLocalService(m.docStore)
        // Skip CSP HTTP server in standalone mode
    } else if m.opts.RunCSP {
        cspService = csp.NewLocalService(m.docStore)
        m.initCSPServer()  // Start HTTP server for distributed mode
    } else {
        cspService = csp.NewRemoteClient(m.cfg.Query.CSPServiceURL)
    }
    
    var queryService engine.Service
    if m.opts.RunQuery || m.opts.Mode == ModeStandalone {
        queryService = engine.NewServiceWithCSP(m.docStore, cspService)
        if m.opts.Mode != ModeStandalone {
            m.initQueryHTTPServer(queryService)
        }
    }
    
    if m.opts.RunAPI || m.opts.Mode == ModeStandalone {
        if queryService == nil {
            queryService = engine.NewClient(m.cfg.Gateway.QueryServiceURL)
        }
        if err := m.initAPIServer(queryService); err != nil {
            return err
        }
    }
    // ...
}
```

**Steps:**
1. Add CSP service initialization logic
2. Refactor Query service initialization
3. Add mode-based conditional logic
4. Extract `initQueryHTTPServer()` helper

#### Task 3.3: Update CLI Flags

**File:** `cmd/syntrix/main.go`

**Current code (lines 17-27):**
```go
runAPI := flag.Bool("api", false, "Run API Gateway")
runCSP := flag.Bool("csp", false, "Run CSP Service")
runQuery := flag.Bool("query", false, "Run Query Service")
runTriggerEvaluator := flag.Bool("trigger-evaluator", false, "Run Trigger Evaluator")
runTriggerWorker := flag.Bool("trigger-worker", false, "Run Trigger Worker")
runAll := flag.Bool("all", false, "Run All Services")
```

**Target code:**
```go
runAPI := flag.Bool("api", false, "Run API Gateway")
runCSP := flag.Bool("csp", false, "Run CSP Service")
runQuery := flag.Bool("query", false, "Run Query Service")
runTriggerEvaluator := flag.Bool("trigger-evaluator", false, "Run Trigger Evaluator")
runTriggerWorker := flag.Bool("trigger-worker", false, "Run Trigger Worker")
runAll := flag.Bool("all", false, "Run All Services")
standalone := flag.Bool("standalone", false, "Run all services in single process (no inter-service HTTP)")
```

**Steps:**
1. Add `--standalone` flag
2. Update `Options` construction to set `Mode`
3. In standalone mode, enable all services automatically

#### Task 3.4: Coverage Verification

```bash
make coverage
./scripts/uncovered_blocks.sh | grep -A5 "internal/services"
```

**Acceptance Criteria:**
- [ ] `ModeStandalone` initialization path covered
- [ ] `ModeDistributed` initialization path covered (regression test)
- [ ] `internal/services` package coverage ≥ current baseline
- [ ] All manager tests pass

---

### Phase 4: Configuration Support (Day 2-3)

#### Task 4.1: Add Deployment Config

**File:** `internal/config/config.go`

**Add new config section:**
```go
type DeploymentConfig struct {
    Mode string `yaml:"mode"` // "standalone" or "distributed"
    Standalone StandaloneConfig `yaml:"standalone"`
}

type StandaloneConfig struct {
    EmbeddedNATS bool   `yaml:"embedded_nats"`
    NATSDataDir  string `yaml:"nats_data_dir"`
}
```

**Steps:**
1. Add `DeploymentConfig` struct
2. Add to main `Config` struct
3. Add defaults in `LoadConfig()`
4. Add env var overrides

#### Task 4.2: Environment Variable Support

**File:** `internal/config/config.go`

Add env vars:
- `SYNTRIX_DEPLOYMENT_MODE` → `standalone` | `distributed`
- `SYNTRIX_EMBEDDED_NATS` → `true` | `false`

#### Task 4.3: Coverage Verification

```bash
make coverage
./scripts/uncovered_blocks.sh | grep -A5 "internal/config"
```

**Acceptance Criteria:**
- [ ] `DeploymentConfig` struct parsing covered
- [ ] Env var overrides tested (`SYNTRIX_DEPLOYMENT_MODE`, `SYNTRIX_EMBEDDED_NATS`)
- [ ] `internal/config` package coverage ≥ current baseline
- [ ] Default values tested

---

### Phase 5: Embedded NATS (Day 3, Optional)

#### Task 5.1: Add Embedded NATS Support

**File:** `internal/services/embedded_nats.go` (new)

```go
package services

import (
    "github.com/nats-io/nats-server/v2/server"
    "github.com/nats-io/nats.go"
)

func (m *Manager) startEmbeddedNATS(ctx context.Context) (*nats.Conn, error) {
    opts := &server.Options{
        Host:      "127.0.0.1",
        Port:      -1,  // Random port
        JetStream: true,
        StoreDir:  m.cfg.Deployment.Standalone.NATSDataDir,
        NoLog:     true,
    }
    
    ns, err := server.NewServer(opts)
    if err != nil {
        return nil, err
    }
    
    go ns.Start()
    if !ns.ReadyForConnections(5 * time.Second) {
        return nil, errors.New("nats not ready")
    }
    
    m.embeddedNATS = ns
    return nats.Connect(ns.ClientURL())
}
```

**Steps:**
1. Add `nats-server` dependency
2. Create embedded server wrapper
3. Integrate into Manager
4. Add shutdown handling

#### Task 5.2: Update initTriggerServices

**File:** `internal/services/manager_init.go`

Modify `initTriggerServices()` to use embedded NATS when in standalone mode:

```go
func (m *Manager) initTriggerServices() error {
    var nc *nats.Conn
    var err error
    
    if m.opts.Mode == ModeStandalone && m.cfg.Deployment.Standalone.EmbeddedNATS {
        nc, err = m.startEmbeddedNATS(ctx)
    } else {
        natsURL := m.cfg.Trigger.NatsURL
        if natsURL == "" {
            natsURL = nats.DefaultURL
        }
        nc, err = natsConnector(natsURL)
    }
    // ...
}
```

#### Task 5.3: Coverage Verification

```bash
make coverage
./scripts/uncovered_blocks.sh | grep -A5 "embedded_nats"
```

**Acceptance Criteria:**
- [ ] `startEmbeddedNATS()` function covered
- [ ] Embedded NATS startup/shutdown tested
- [ ] Error paths covered (server not ready, connection failure)
- [ ] Integration with trigger services tested

---

### Phase 6: Testing (Day 3-4)

#### Task 6.1: Unit Tests

| File | Tests to Add |
|------|--------------|
| `internal/csp/local_service_test.go` | Watch with mock storage |
| `internal/csp/remote_client_test.go` | HTTP client with httptest |
| `internal/services/manager_init_test.go` | Mode-based initialization |

#### Task 6.2: Integration Tests

**File:** `tests/integration/standalone_test.go` (new)

```go
func TestStandaloneMode_AllServicesInProcess(t *testing.T) {
    // Start manager in standalone mode
    // Verify no HTTP servers for Query/CSP
    // Verify API gateway works
    // Verify realtime works
}
```

#### Task 6.3: Run Full Test Suite

```bash
make test
make coverage
./scripts/uncovered_blocks.sh
```

#### Task 6.4: Final Coverage Verification

```bash
make coverage
./scripts/uncovered_blocks.sh
```

**Final Acceptance Criteria:**
- [ ] Overall project coverage ≥ baseline (check `make coverage` output)
- [ ] No critical uncovered paths in standalone mode logic
- [ ] All integration tests pass

**Coverage Targets by Package:**

| Package | Target Coverage |
|---------|----------------|
| `internal/csp` | ≥ 80% |
| `internal/engine` | ≥ current baseline |
| `internal/services` | ≥ current baseline |
| `internal/config` | ≥ current baseline |
| **Overall** | ≥ current baseline |

---

## Coverage Checkpoint Summary

每个阶段完成后执行：

```bash
make coverage
./scripts/uncovered_blocks.sh
```

| Phase | Focus Area | Target |
|-------|------------|--------|
| Phase 1 | `internal/csp` | ≥ 80% |
| Phase 2 | `internal/engine` | ≥ baseline |
| Phase 3 | `internal/services` | ≥ baseline |
| Phase 4 | `internal/config` | ≥ baseline |
| Phase 5 | `internal/services` (embedded NATS) | ≥ baseline |
| Phase 6 | Overall | ≥ baseline |

---

## File Change Summary

| File | Action | Lines Changed (Est.) |
|------|--------|---------------------|
| `internal/csp/interface.go` | Create | ~15 |
| `internal/csp/local_service.go` | Create | ~25 |
| `internal/csp/remote_client.go` | Create | ~60 |
| `internal/csp/local_service_test.go` | Create | ~50 |
| `internal/csp/remote_client_test.go` | Create | ~80 |
| `internal/engine/internal/core/engine.go` | Modify | ~50 |
| `internal/engine/interface.go` | Modify | ~15 |
| `internal/services/manager.go` | Modify | ~15 |
| `internal/services/manager_init.go` | Modify | ~50 |
| `internal/config/config.go` | Modify | ~30 |
| `cmd/syntrix/main.go` | Modify | ~20 |
| `internal/services/embedded_nats.go` | Create (optional) | ~50 |
| `tests/integration/standalone_test.go` | Create | ~100 |

**Total: ~560 lines** (excluding optional embedded NATS)

---

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Breaking engine tests | High | Medium | Update tests incrementally, run after each change |
| Backward compatibility | Medium | High | Keep `NewService(url)` working via wrapper |
| Config migration | Low | Low | New config section, old configs still work |

---

## Success Criteria

- [ ] `syntrix --standalone` starts single process with all services
- [ ] No HTTP calls between internal services in standalone mode
- [ ] Existing `syntrix --api --query --csp` unchanged
- [ ] All existing tests pass
- [ ] New tests for standalone mode pass
- [ ] `make coverage` ≥ current baseline

---

## Rollback Plan

If issues arise:
1. Revert `internal/engine/internal/core/engine.go` changes
2. Keep CSP interface files but don't use them
3. `--standalone` flag becomes no-op

All changes are additive; distributed mode remains default.
