# Standalone Mode Implementation Plan

**Date:** December 31, 2025
**Status:** ✅ Complete
**Design Doc:** [docs/design/server/012_standalone_mode.md](../docs/design/server/012_standalone_mode.md)
**Est. Timeline:** 3-4 days

## Progress

| Phase | Status | Coverage |
|-------|--------|----------|
| Phase 1: CSP Service Interface | ✅ Complete | 92.9% |
| Phase 2: Engine Refactor | ✅ Complete | 95.2% |
| Phase 3: Service Manager Refactor | ✅ Complete | 95.2% |
| Phase 4: Configuration Support | ✅ Complete | 95.2% |
| Phase 5: NATS Service Interface | ✅ Complete | 95.2% |
| Phase 6: Testing | ✅ Complete | 95.2% |

**Final Statistics:**
- Total Tests: 874
- Overall Coverage: 95.2%
- Integration Tests Added: 4 (TestStandaloneMode_*)

## Overview

Implement standalone deployment mode that packages all Syntrix services into a single process, replacing inter-service network communication with direct function calls.

## Current Code Analysis

### Key Files and Current Behavior

| File | Current Behavior | Required Change |
|------|------------------|-----------------|
| `cmd/syntrix/main.go` | Parses `--api`, `--csp`, `--query` flags | Add `--standalone` flag |
| `internal/services/manager.go` | `Options` struct with boolean flags | Add `Mode DeploymentMode` field |
| `internal/services/manager_init.go` | Creates HTTP servers for each service | Conditional: skip HTTP servers in standalone |
| `internal/engine/internal/core/engine.go` | `cspURL string` + HTTP client | Replace with `csp.Service` interface |
| `internal/engine/interface.go` | `NewService(store, cspURL string)` | Add `NewServiceWithCSP(store, cspService)` |
| `internal/csp/server.go` | HTTP server only | Extract core logic to `Service` interface |

### Inter-Service Communication Points

```
┌─────────────────────────────────────────────────────────────────────────┐
│ Communication Point 1: API Gateway → Query Service                      │
├─────────────────────────────────────────────────────────────────────────┤
│ Current:  engine.NewClient(cfg.Gateway.QueryServiceURL) → HTTP client   │
│ Location: internal/services/manager_init.go:55-60                       │
│ Change:   In standalone, use queryService directly (already supported)  │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ Communication Point 2: Query Engine → CSP Service                       │
├─────────────────────────────────────────────────────────────────────────┤
│ Current:  http.POST to cspURL + "/internal/v1/watch"                    │
│ Location: internal/engine/internal/core/engine.go:191-235               │
│ Change:   Call csp.Service.Watch() interface method directly            │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ Communication Point 3: Trigger Services → NATS                          │
├─────────────────────────────────────────────────────────────────────────┤
│ Current:  nats.Connect(natsURL) to external NATS server                 │
│ Location: internal/services/manager_init.go:177-182                     │
│ Change:   Option to use embedded NATS server                            │
└─────────────────────────────────────────────────────────────────────────┘
```

## Implementation Tasks

### Phase 1: CSP Service Interface (Day 1)

#### Task 1.1: Create CSP Service Interface

**File:** `internal/csp/interface.go` (new)

> ⚠️ **Design Note:** Interface signature must match `storage.DocumentStore.Watch()` to support `resumeToken` (断点续传) and `WatchOptions` (e.g., `IncludeBefore`).

```go
// Target implementation
package csp

import (
    "context"
    "github.com/codetrek/syntrix/internal/storage"
)

// Service defines the interface for Change Stream processing.
type Service interface {
    // Watch returns a channel of events for a collection.
    // Pass empty string for collection to watch all collections.
    // resumeToken can be nil to start from now.
    Watch(ctx context.Context, tenant, collection string, resumeToken interface{}, opts storage.WatchOptions) (<-chan storage.Event, error)
}
```

**Steps:**
1. Create `internal/csp/interface.go` with `Service` interface
2. Add interface documentation

#### Task 1.2: Implement EmbeddedService

**File:** `internal/csp/embedded_service.go` (new)

Extract core logic from `server.go:handleWatch()`:

```go
// Target implementation
package csp

type EmbeddedService struct {
    storage storage.DocumentStore
}

func NewEmbeddedService(store storage.DocumentStore) *EmbeddedService {
    return &EmbeddedService{storage: store}
}

func (s *EmbeddedService) Watch(ctx context.Context, tenant, collection string, resumeToken interface{}, opts storage.WatchOptions) (<-chan storage.Event, error) {
    // Direct call to storage.Watch() - extracted from handleWatch()
    return s.storage.Watch(ctx, tenant, collection, resumeToken, opts)
}
```

**Steps:**
1. Create `internal/csp/embedded_service.go`
2. Implement `EmbeddedService` struct
3. Extract watch logic from `server.go`

#### Task 1.3: Implement RemoteService

**File:** `internal/csp/remote_service.go` (new)

Extract HTTP client logic from `engine.go:WatchCollection()`:

```go
// Target implementation
package csp

type RemoteService struct {
    baseURL string
    client  *http.Client
}

func NewRemoteService(baseURL string) *RemoteService {
    return &RemoteService{baseURL: baseURL, client: &http.Client{}}
}

func (c *RemoteService) Watch(ctx context.Context, tenant, collection string, resumeToken interface{}, opts storage.WatchOptions) (<-chan storage.Event, error) {
    // HTTP POST to /internal/v1/watch - extracted from engine.go
    // Note: resumeToken and opts are ignored for HTTP client (server manages state)
}
```

**Steps:**
1. Create `internal/csp/remote_service.go`
2. Move HTTP logic from `engine.go` `WatchCollection()` method to this file
3. Implement streaming JSON decoder

> ⚠️ **Note:** Similar HTTP client code exists in `internal/engine/internal/client/client.go:WatchCollection()`. Consider:
> - Using `bufio.Scanner` for line-by-line JSON (matches existing client implementation)
> - Or using `json.Decoder` (matches current engine.go implementation)
> - Choose one approach and document the decision

#### Task 1.4: Add Unit Tests

**Files:**
- `internal/csp/embedded_service_test.go` (new)
- `internal/csp/remote_service_test.go` (new)

**Coverage targets:**
- `EmbeddedService.Watch()` - mock storage
- `RemoteService.Watch()` - httptest server

#### Task 1.5: Coverage Verification

```bash
make coverage
./scripts/uncovered_blocks.sh | grep -A5 "internal/csp"
```

**Acceptance Criteria:**
- [ ] `internal/csp` package coverage ≥ 80%
- [ ] All existing tests pass
- [ ] No new uncovered blocks in critical paths

---

### Phase 2: Engine Refactor (Day 1-2)

#### Task 2.1: Modify Engine to Use CSP Interface

**File:** `internal/engine/internal/core/engine.go`

**Current code (lines 17-30):**
```go
type Engine struct {
    storage storage.DocumentStore
    cspURL  string           // ← Remove
    client  *http.Client     // ← Remove
}

func New(storage storage.DocumentStore, cspURL string) *Engine {
    return &Engine{
        storage: storage,
        cspURL:  cspURL,      // ← Remove
        client:  &http.Client{}, // ← Remove
    }
}
```

**Target code:**
```go
type Engine struct {
    storage    storage.DocumentStore
    cspService csp.Service  // ← New field
}

func New(storage storage.DocumentStore, cspService csp.Service) *Engine {
    return &Engine{
        storage:    storage,
        cspService: cspService,
    }
}
```

**Steps:**
1. Add import for `internal/csp`
2. Replace `cspURL string` with `cspService csp.Service`
3. Remove `client *http.Client` field
4. Remove `SetHTTPClient()` method
5. Update `New()` constructor signature

> ⚠️ **Circular Dependency Risk:** `internal/engine` will import `internal/csp`. Ensure `csp` package does NOT import `engine` to avoid import cycle. If needed in future, extract `csp.Service` interface to a shared package.

#### Task 2.2: Update WatchCollection Method

**File:** `internal/engine/internal/core/engine.go`

**Current code (lines 191-235):**
```go
func (e *Engine) WatchCollection(ctx context.Context, tenant string, collection string) (<-chan storage.Event, error) {
    reqBody, err := json.Marshal(map[string]string{...})
    // ... 45 lines of HTTP client code
}
```

**Target code:**
```go
func (e *Engine) WatchCollection(ctx context.Context, tenant string, collection string) (<-chan storage.Event, error) {
    return e.cspService.Watch(ctx, tenant, collection, nil, storage.WatchOptions{})
}
```

**Steps:**
1. Replace entire method body with single interface call
2. Remove unused imports (`bytes`, `fmt`, parts of `net/http`)

#### Task 2.3: Update Public Interface

**File:** `internal/engine/interface.go`

**Current code (line 31):**
```go
func NewService(store storage.DocumentStore, cspURL string) Service {
    return core.New(store, cspURL)
}
```

**Target code:**
```go
// NewService creates a new local Query Service with CSP client.
// For standalone mode, use NewServiceWithCSP with an EmbeddedService.
func NewService(store storage.DocumentStore, cspURL string) Service {
    return core.New(store, csp.NewRemoteService(cspURL))
}

// NewServiceWithCSP creates a Query Service with a custom CSP implementation.
// Use this for standalone mode with csp.NewEmbeddedService().
func NewServiceWithCSP(store storage.DocumentStore, cspService csp.Service) Service {
    return core.New(store, cspService)
}
```

**Steps:**
1. Add `NewServiceWithCSP()` function
2. Update `NewService()` to wrap `csp.NewRemoteService()`
3. Maintain backward compatibility

#### Task 2.4: Update Engine Tests

**File:** `internal/engine/internal/core/engine_coverage_test.go`

**Changes needed:**
- Update test setup to use mock `csp.Service`
- Remove HTTP test servers for CSP
- Simplify `TestWatchCollection_*` tests

#### Task 2.5: Coverage Verification

```bash
make coverage
./scripts/uncovered_blocks.sh | grep -A5 "internal/engine"
```

**Acceptance Criteria:**
- [ ] `internal/engine` package coverage ≥ current baseline
- [ ] `WatchCollection` method fully covered
- [ ] All `TestWatchCollection_*` tests pass with new mock
- [ ] No regression in other engine tests

---

### Phase 3: Service Manager Refactor (Day 2)

#### Task 3.1: Add DeploymentMode

**File:** `internal/services/manager.go`

**Current code (lines 16-26):**
```go
type Options struct {
    RunAPI              bool
    RunCSP              bool
    RunQuery            bool
    RunTriggerEvaluator bool
    RunTriggerWorker    bool
    ListenHost          string
    ForceQueryClient    bool
}
```

**Target code:**
```go
type DeploymentMode int

const (
    ModeDistributed DeploymentMode = iota  // Default: HTTP between services
    ModeStandalone                          // All-in-one: direct function calls
)

type Options struct {
    RunAPI              bool
    RunCSP              bool
    RunQuery            bool
    RunTriggerEvaluator bool
    RunTriggerWorker    bool
    ListenHost          string
    ForceQueryClient    bool
    
    Mode DeploymentMode  // New field
}
```

**Steps:**
1. Add `DeploymentMode` type and constants
2. Add `Mode` field to `Options`

#### Task 3.2: Refactor initQueryServices

**File:** `internal/services/manager_init.go`

> ⚠️ **Important:** Current `initQueryServices()` creates both the service AND HTTP server. Must split into two functions to avoid creating HTTP server in standalone mode.

**Current `initQueryServices()` problem:**
```go
func (m *Manager) initQueryServices() engine.Service {
    service := engine.NewService(m.docStore, m.cfg.Query.CSPServiceURL)
    m.servers = append(m.servers, &http.Server{...})  // ← Always creates HTTP server!
    return service
}
```

**Refactor to:**
```go
// createQueryService creates the query engine without HTTP server
func (m *Manager) createQueryService(cspService csp.Service) engine.Service {
    return engine.NewServiceWithCSP(m.docStore, cspService)
}

// initQueryHTTPServer starts HTTP server for the query service
func (m *Manager) initQueryHTTPServer(service engine.Service) {
    m.servers = append(m.servers, &http.Server{
        Addr:    listenAddr(m.opts.ListenHost, m.cfg.Query.Port),
        Handler: engine.NewHTTPHandler(service),
    })
    m.serverNames = append(m.serverNames, "Query Service")
}
```

#### Task 3.3: Update Manager Init Logic

**File:** `internal/services/manager_init.go`

**Current code (around lines 45-67):**
```go
func (m *Manager) Init(ctx context.Context) error {
    // ...
    var queryService engine.Service

    if m.opts.RunQuery {
        qs := m.initQueryServices()
        if !m.opts.ForceQueryClient {
            queryService = qs
        }
    }

    if m.opts.RunAPI {
        if queryService == nil {
            queryService = engine.NewClient(m.cfg.Gateway.QueryServiceURL)
        }
        // ...
    }

    if m.opts.RunCSP {
        m.initCSPServer()
    }
    // ...
}
```

**Target code:**
```go
func (m *Manager) Init(ctx context.Context) error {
    // ...
    
    // Initialize CSP service based on mode
    var cspService csp.Service
    if m.opts.Mode == ModeStandalone {
        cspService = csp.NewEmbeddedService(m.docStore)
        // Skip CSP HTTP server in standalone mode
    } else if m.opts.RunCSP {
        cspService = csp.NewEmbeddedService(m.docStore)
        m.initCSPServer()  // Start HTTP server for distributed mode
    } else {
        cspService = csp.NewRemoteService(m.cfg.Query.CSPServiceURL)
    }
    
    var queryService engine.Service
    if m.opts.RunQuery || m.opts.Mode == ModeStandalone {
        queryService = engine.NewServiceWithCSP(m.docStore, cspService)
        if m.opts.Mode != ModeStandalone {
            m.initQueryHTTPServer(queryService)
        }
    }
    
    if m.opts.RunAPI || m.opts.Mode == ModeStandalone {
        if queryService == nil {
            queryService = engine.NewClient(m.cfg.Gateway.QueryServiceURL)
        }
        if err := m.initAPIServer(queryService); err != nil {
            return err
        }
    }
    // ...
}
```

**Steps:**
1. Add CSP service initialization logic
2. Refactor Query service initialization
3. Add mode-based conditional logic
4. Extract `initQueryHTTPServer()` helper

#### Task 3.4: Update CLI Flags

**File:** `cmd/syntrix/main.go`

**Current code (lines 17-27):**
```go
runAPI := flag.Bool("api", false, "Run API Gateway")
runCSP := flag.Bool("csp", false, "Run CSP Service")
runQuery := flag.Bool("query", false, "Run Query Service")
runTriggerEvaluator := flag.Bool("trigger-evaluator", false, "Run Trigger Evaluator")
runTriggerWorker := flag.Bool("trigger-worker", false, "Run Trigger Worker")
runAll := flag.Bool("all", false, "Run All Services")
```

**Target code:**
```go
runAPI := flag.Bool("api", false, "Run API Gateway")
runCSP := flag.Bool("csp", false, "Run CSP Service")
runQuery := flag.Bool("query", false, "Run Query Service")
runTriggerEvaluator := flag.Bool("trigger-evaluator", false, "Run Trigger Evaluator")
runTriggerWorker := flag.Bool("trigger-worker", false, "Run Trigger Worker")
runAll := flag.Bool("all", false, "Run All Services")
standalone := flag.Bool("standalone", false, "Run all services in single process (no inter-service HTTP)")
```

**Steps:**
1. Add `--standalone` flag
2. Update `Options` construction to set `Mode`
3. In standalone mode:
   - Enable all services automatically
   - **Ignore** `--api`, `--csp`, `--query`, `--trigger-*` flags (they are implied)
   - Log a message if other flags are also set: `"Running in standalone mode, ignoring individual service flags"`

#### Task 3.5: Coverage Verification

```bash
make coverage
./scripts/uncovered_blocks.sh | grep -A5 "internal/services"
```

**Acceptance Criteria:**
- [ ] `ModeStandalone` initialization path covered
- [ ] `ModeDistributed` initialization path covered (regression test)
- [ ] `internal/services` package coverage ≥ current baseline
- [ ] All manager tests pass

---

### Phase 4: Configuration Support (Day 2-3)

#### Task 4.1: Add Deployment Config

**File:** `internal/config/config.go`

**Add new config section:**
```go
type DeploymentConfig struct {
    Mode string `yaml:"mode"` // "standalone" or "distributed"
    Standalone StandaloneConfig `yaml:"standalone"`
}

type StandaloneConfig struct {
    EmbeddedNATS bool   `yaml:"embedded_nats"`
    NATSDataDir  string `yaml:"nats_data_dir"`
}
```

**Steps:**
1. Add `DeploymentConfig` struct
2. Add to main `Config` struct
3. Add defaults in `LoadConfig()`
4. Add env var overrides

#### Task 4.2: Environment Variable Support

**File:** `internal/config/config.go`

Add env vars:
- `SYNTRIX_DEPLOYMENT_MODE` → `standalone` | `distributed`
- `SYNTRIX_EMBEDDED_NATS` → `true` | `false`

#### Task 4.3: Coverage Verification

```bash
make coverage
./scripts/uncovered_blocks.sh | grep -A5 "internal/config"
```

**Acceptance Criteria:**
- [ ] `DeploymentConfig` struct parsing covered
- [ ] Env var overrides tested (`SYNTRIX_DEPLOYMENT_MODE`, `SYNTRIX_EMBEDDED_NATS`)
- [ ] `internal/config` package coverage ≥ current baseline
- [ ] Default values tested

---

### Phase 5: NATS Service Interface (Day 3)

> **设计思路**: 与 CSP Service 处理方式一致，先定义接口抽象，保留现有外部 NATS 连接方式，后续再实现嵌入式版本。这样可以：
> 1. 不引入新依赖（nats-server）
> 2. 保持代码可测试性
> 3. 为未来嵌入式 NATS 预留扩展点

#### Task 5.1: Define NATS Provider Interface

**File:** `internal/trigger/nats_provider.go` (new)

```go
package trigger

import (
    "context"
    "github.com/nats-io/nats.go"
)

// NATSProvider abstracts NATS connection management.
// This allows swapping between external NATS server and future embedded NATS.
type NATSProvider interface {
    // Connect establishes a connection to NATS
    Connect(ctx context.Context) (*nats.Conn, error)
    // Close closes the NATS connection and any embedded server
    Close() error
}
```

#### Task 5.2: Implement RemoteNATSProvider

**File:** `internal/trigger/remote_nats.go` (new)

```go
package trigger

import (
    "context"
    "github.com/nats-io/nats.go"
)

// RemoteNATSProvider connects to an external NATS server.
type RemoteNATSProvider struct {
    url  string
    conn *nats.Conn
}

func NewRemoteNATSProvider(url string) *RemoteNATSProvider {
    if url == "" {
        url = nats.DefaultURL
    }
    return &RemoteNATSProvider{url: url}
}

func (p *RemoteNATSProvider) Connect(ctx context.Context) (*nats.Conn, error) {
    nc, err := nats.Connect(p.url)
    if err != nil {
        return nil, err
    }
    p.conn = nc
    return nc, nil
}

func (p *RemoteNATSProvider) Close() error {
    if p.conn != nil {
        p.conn.Close()
    }
    return nil
}
```

#### Task 5.3: Add EmbeddedNATSProvider Stub (Future)

**File:** `internal/trigger/embedded_nats.go` (new - stub only)

```go
package trigger

import (
    "context"
    "errors"
    "github.com/nats-io/nats.go"
)

// EmbeddedNATSProvider runs an embedded NATS server (future implementation).
// Currently returns an error indicating it's not implemented.
type EmbeddedNATSProvider struct {
    dataDir string
}

func NewEmbeddedNATSProvider(dataDir string) *EmbeddedNATSProvider {
    return &EmbeddedNATSProvider{dataDir: dataDir}
}

func (p *EmbeddedNATSProvider) Connect(ctx context.Context) (*nats.Conn, error) {
    // TODO: Implement embedded NATS server
    // Requires: go get github.com/nats-io/nats-server/v2@latest
    return nil, errors.New("embedded NATS not implemented; use external NATS server or set embedded_nats: false")
}

func (p *EmbeddedNATSProvider) Close() error {
    return nil
}
```

#### Task 5.4: Update Manager to Use NATSProvider

**File:** `internal/services/manager.go`

Add `natsProvider` field:
```go
type Manager struct {
    // ...existing fields...
    natsProvider trigger.NATSProvider  // New field
}
```

**File:** `internal/services/manager_init.go`

Update `initTriggerServices()`:
```go
func (m *Manager) initTriggerServices() error {
    // Create NATS provider based on mode
    if m.opts.Mode == ModeStandalone && m.cfg.Deployment.Standalone.EmbeddedNATS {
        m.natsProvider = trigger.NewEmbeddedNATSProvider(m.cfg.Deployment.Standalone.NATSDataDir)
    } else {
        m.natsProvider = trigger.NewRemoteNATSProvider(m.cfg.Trigger.NatsURL)
    }
    
    nc, err := m.natsProvider.Connect(context.Background())
    if err != nil {
        return fmt.Errorf("failed to connect to NATS: %w", err)
    }
    m.natsConn = nc
    // ...rest of initialization...
}
```

**File:** `internal/services/manager_shutdown.go`

Update shutdown:
```go
// Close NATS provider (handles both connection and embedded server)
if m.natsProvider != nil {
    m.natsProvider.Close()
}
```

#### Task 5.5: Coverage Verification

```bash
make coverage
./scripts/uncovered_blocks.sh | grep -A5 "nats_provider\|remote_nats\|embedded_nats"
```

**Acceptance Criteria:**
- [ ] `NATSProvider` interface defined
- [ ] `RemoteNATSProvider` implemented and tested
- [ ] `EmbeddedNATSProvider` stub with clear error message
- [ ] Manager uses `NATSProvider` interface
- [ ] All existing trigger tests pass
- [ ] Coverage ≥ current baseline

---

### Phase 6: Testing (Day 3-4)

#### Task 6.1: Unit Tests

| File | Tests to Add |
|------|--------------|
| `internal/csp/local_service_test.go` | Watch with mock storage |
| `internal/csp/remote_client_test.go` | HTTP client with httptest |
| `internal/services/manager_init_test.go` | Mode-based initialization |

#### Task 6.2: Integration Tests

**File:** `tests/integration/standalone_test.go` (new)

```go
func TestStandaloneMode_AllServicesInProcess(t *testing.T) {
    // Start manager in standalone mode
    // Verify no HTTP servers for Query/CSP
    // Verify API gateway works
    // Verify realtime works
}
```

#### Task 6.3: Run Full Test Suite

```bash
make test
make coverage
./scripts/uncovered_blocks.sh
```

#### Task 6.4: Final Coverage Verification

```bash
make coverage
./scripts/uncovered_blocks.sh
```

**Final Acceptance Criteria:**
- [ ] Overall project coverage ≥ baseline (check `make coverage` output)
- [ ] No critical uncovered paths in standalone mode logic
- [ ] All integration tests pass

**Coverage Targets by Package:**

| Package | Target Coverage |
|---------|----------------|
| `internal/csp` | ≥ 80% |
| `internal/engine` | ≥ current baseline |
| `internal/services` | ≥ current baseline |
| `internal/config` | ≥ current baseline |
| **Overall** | ≥ current baseline |

---

## Coverage Checkpoint Summary

每个阶段完成后执行：

```bash
make coverage
./scripts/uncovered_blocks.sh
```

| Phase | Focus Area | Target |
|-------|------------|--------|
| Phase 1 | `internal/csp` | ≥ 80% |
| Phase 2 | `internal/engine` | ≥ baseline |
| Phase 3 | `internal/services` | ≥ baseline |
| Phase 4 | `internal/config` | ≥ baseline |
| Phase 5 | `internal/services` (embedded NATS) | ≥ baseline |
| Phase 6 | Overall | ≥ baseline |

---

## File Change Summary

| File | Action | Lines Changed (Est.) |
|------|--------|---------------------|
| `internal/csp/interface.go` | Create | ~15 |
| `internal/csp/local_service.go` | Create | ~25 |
| `internal/csp/remote_client.go` | Create | ~60 |
| `internal/csp/local_service_test.go` | Create | ~50 |
| `internal/csp/remote_client_test.go` | Create | ~80 |
| `internal/engine/internal/core/engine.go` | Modify | ~50 |
| `internal/engine/interface.go` | Modify | ~15 |
| `internal/services/manager.go` | Modify | ~15 |
| `internal/services/manager_init.go` | Modify | ~50 |
| `internal/config/config.go` | Modify | ~30 |
| `cmd/syntrix/main.go` | Modify | ~20 |
| `internal/services/embedded_nats.go` | Create (optional) | ~50 |
| `tests/integration/standalone_test.go` | Create | ~100 |

**Total: ~560 lines** (excluding optional embedded NATS)

---

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Breaking engine tests | High | Medium | Update tests incrementally, run after each change |
| Backward compatibility | Medium | High | Keep `NewService(url)` working via wrapper |
| Config migration | Low | Low | New config section, old configs still work |
| Circular dependency `engine` ↔ `csp` | Medium | High | Ensure `csp` never imports `engine`; extract interface if needed |
| `initQueryServices()` creates unwanted HTTP server | High | Medium | Refactor to separate `createQueryService()` and `initQueryHTTPServer()` |
| Code duplication with `client.Client.WatchCollection` | Low | Low | Document decision; consider consolidation in future |

## Known Issues (TODO)

- [ ] **Realtime Server Watch Tenant**: `internal/api/realtime/server.go` calls `WatchCollection(ctx, "", "")` with empty tenant. Verify this works correctly with `csp.EmbeddedService` in standalone mode. MongoDB backend must support watching all tenants when tenant is empty string.

---

## Success Criteria

- [ ] `syntrix --standalone` starts single process with all services
- [ ] No HTTP calls between internal services in standalone mode
- [ ] Existing `syntrix --api --query --csp` unchanged
- [ ] All existing tests pass
- [ ] New tests for standalone mode pass
- [ ] `make coverage` ≥ current baseline

---

## Rollback Plan

If issues arise:
1. Revert `internal/engine/internal/core/engine.go` changes
2. Keep CSP interface files but don't use them
3. `--standalone` flag becomes no-op

All changes are additive; distributed mode remains default.
