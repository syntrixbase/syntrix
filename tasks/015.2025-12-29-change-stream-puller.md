# Change Stream Puller Implementation

Date: December 29, 2025
Status: Planned
Scope: Implement change stream puller with fan-out, checkpointing, backpressure, and optional JetStream integration.
Depends On: [015.index-layer-implementation](015.2025-12-29-index-layer-implementation.md)

## Related Design Documents

| Doc | Path | Description |
|-----|------|-------------|
| Architecture | [001.architecture.md](../docs/design/server/engine/001.architecture.md) | Overall architecture |
| Puller | [007.puller.md](../docs/design/server/engine/007.puller.md) | Puller design, fan-out, JetStream |

## Goals
- Implement change stream puller to reduce load on primary storage.
- Fan-out events to index consumers by collection/partition.
- Per-consumer checkpointing with external persistence.
- Backpressure and lag detection with rebuild triggers.
- Optional JetStream integration for durable fan-out.

## Prerequisites
- Task 015 completed: Index layer in place, consuming events from Data layer.
- Change event schema finalized.

## Execution Steps

### 1. Config Expansion
- Add `jetstream` block under `query` in config:
  ```yaml
  query:
    jetstream:
      enabled: false
      url: ${NATS_URL}
      retention: 10m
      replicas: 1
      max_ack_pending: 200
      ack_wait: 5s
  ```

### 2. Puller Core
- Create `internal/engine/internal/puller/`:
  - `puller.go`: Main puller loop subscribing to storage change stream.
  - `fanout.go`: Shard events by collection, deliver to consumers.
  - `checkpoint.go`: Persist/load checkpoints per collection.
- Interface:
  ```go
  type Puller interface {
      Run(ctx context.Context) error
      Subscribe(collection string) (<-chan Event, error)
      Checkpoint() error
  }
  ```

### 3. Backpressure & Lag Detection
- Per-consumer channel buffer: 100 events.
- Soft lag threshold: 30s or 50k versions behind.
- Hard lag threshold: 2m or 200k versions behind.
- On hard lag: pause deliveries, mark shard for rebuild.
- Metrics: events/sec, lag per collection, rebuild triggers.

### 4. Batching & Coalescing
- Batch size: 256 events or 1MB (whichever first).
- Coalesce multiple events for same doc when safe.
- Checkpoint cadence: every 1s or 1k events applied.

### 5. JetStream Integration (optional)
- When `jetstream.enabled=true`:
  - Create JetStream stream per collection/shard.
  - Subject pattern: `query.index.<collection>`.
  - Pull consumer per shard with `max_ack_pending=200`, `ack_wait=5s`.
- Semantics:
  - At-least-once delivery; index apply must be idempotent.
  - External checkpoint authoritative for rebuild decisions.
  - Gap/invalid offset → trigger rebuild.
- When disabled: direct storage change stream path.

### 6. Rebuild Integration
- On lag/gap detection, signal Index manager to rebuild affected collection.
- Pause live apply during rebuild; buffer in WAL (cap 10k events or 32MB).
- Resume from checkpoint after rebuild completes.

### 7. Tests (testify)
- Puller: happy path event flow, checkpoint persistence/recovery.
- Backpressure: consumer lag triggers pause + rebuild flag.
- JetStream: delivery semantics, ack handling, gap detection.
- Coalescing: multiple events for same doc merged correctly.

## Key Defaults Summary

| Parameter | Value | Notes |
|-----------|-------|-------|
| Batch size | 256 events or 1MB | Whichever first |
| Consumer buffer | 100 events | Per-consumer channel |
| Soft lag | 30s or 50k versions | Warn threshold |
| Hard lag | 2m or 200k versions | Force rebuild |
| Checkpoint cadence | 1s or 1k events | Whichever first |
| WAL buffer | 10k events or 32MB | Overflow → restart rebuild |
| JetStream retention | 10m | Short window |
| JetStream replicas | 1 (dev) / 3 (prod) | |
| max_ack_pending | 200 | |
| ack_wait | 5s | |

## JetStream vs Direct Path

| Aspect | JetStream | Direct Path |
|--------|-----------|-------------|
| Durability | Durable within retention | Transient |
| Ordering | Per-subject guaranteed | Per-collection from storage |
| Ops complexity | Higher (NATS cluster) | Lower |
| Use case | Multi-consumer, HA | Single process, simple |

## Risks
- JetStream requires NATS cluster; adds operational complexity.
- Checkpoint loss may cause duplicate event processing (idempotency required).
- WAL overflow during long rebuilds.

## Verification
- Unit tests for puller, fanout, checkpoint.
- Integration test: puller → index consumer → query correct results.
- Stress test: high event rate, lag detection, rebuild trigger.

## Status Log
- 2025-12-29: Task created from 014 dry-run analysis.
