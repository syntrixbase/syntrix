# Query-Indexer Integration

**Date:** 2026-01-11
**Status:** Planned
**Scope:** Query Engine + Indexer Integration
**Depends on:** 017 (Index Layer), Indexer Service

## Overview

Integrate Query Engine with Indexer service.

**Core Principles:**
1. Indexer is a **required dependency** for Query - no fallback to MongoDB
2. **Standalone mode only** (`--standalone` or `deployment.mode: standalone`): direct in-process calls allowed
3. **Distributed mode** (default, including `--all`): must use gRPC, even if services are in same process

Design doc: [docs/design/server/query/02.indexer-integration.md](../docs/design/server/query/02.indexer-integration.md)

## Mode Determination

| CLI Flag | Config | Mode | Query → Indexer |
|----------|--------|------|-----------------|
| `--standalone` | - | Standalone | Direct call |
| - | `deployment.mode: standalone` | Standalone | Direct call |
| `--all` | - | **Distributed** | **gRPC** |
| `--query` | - | Distributed | gRPC |
| (default) | - | Distributed | gRPC |

---

## Phase 1: Core Integration (Standalone)

### Task 1.1: Modify Query Engine

**File:** `internal/query/internal/core/engine.go`

- [ ] Change `New()` signature: `New(storage, indexer)` - indexer required
- [ ] Remove `WithIndexer()` method
- [ ] Remove fallback logic in `ExecuteQuery()`
- [ ] Add `ErrIndexerRequired` error

```go
// Before
func New(storage storage.DocumentStore) *Engine

// After
func New(storage storage.DocumentStore, indexer indexer.Service) *Engine
```

### Task 1.2: Modify Query Package Interface

**File:** `internal/query/interface.go`

- [ ] Update `NewService()` signature to require indexer

```go
// Before
func NewService(store storage.DocumentStore) Service

// After
func NewService(store storage.DocumentStore, idx indexer.Service) Service
```

### Task 1.3: Modify Manager Init (Standalone)

**File:** `internal/services/manager_init.go`

- [ ] Modify `createQueryService()` to inject local Indexer (Standalone only)
- [ ] Add Indexer nil check with clear error message
- [ ] Verify init order: Puller → Indexer → Query

### Task 1.4: Update Tests

**File:** `internal/query/internal/core/engine_indexer_test.go`

- [ ] Update tests for new `New()` signature
- [ ] Remove fallback-related tests
- [ ] Add error scenario tests

---

## Phase 2: Distributed Mode Support

**Key Principle:** Distributed mode (including `--all`) must always use gRPC client, never direct calls.

### Task 2.1: Extend Gateway Config

**File:** `internal/api/config/config.go`

- [ ] Add `IndexerServiceURL` field (required for Distributed mode)

```go
type GatewayConfig struct {
    // ... existing fields
    IndexerServiceURL  string `yaml:"indexer_service_url"`
}
```

### Task 2.2: Indexer Client Interface Adaptation

**File:** `internal/indexer/internal/client/client.go`

- [ ] Verify `Client` implements `indexer.Service` interface
- [ ] Adapt `Health()` and `Stats()` return types if needed

### Task 2.3: Distributed Mode Query Init

**File:** `internal/services/manager_init.go`

- [ ] Modify `createQueryService()` for Distributed mode:
  - Must use Indexer gRPC client (never local service)
  - Require `IndexerServiceURL` config
- [ ] Fail startup if `IndexerServiceURL` not configured in Distributed mode

```go
func (m *Manager) createQueryService(ctx context.Context) (query.Service, error) {
    sf, err := m.getStorageFactory(ctx)
    if err != nil {
        return nil, err
    }

    if m.opts.Mode == ModeStandalone {
        // Standalone: direct call to local indexer
        if m.indexerService == nil {
            return nil, fmt.Errorf("indexer service required in standalone mode")
        }
        return query.NewService(sf.Document(), m.indexerService), nil
    }

    // Distributed (including --all): must use gRPC client
    if m.cfg.Gateway.IndexerServiceURL == "" {
        return nil, fmt.Errorf("gateway.indexer_service_url required in distributed mode")
    }
    client, err := indexer.NewClient(m.cfg.Gateway.IndexerServiceURL, slog.Default())
    if err != nil {
        return nil, fmt.Errorf("failed to connect to indexer: %w", err)
    }
    return query.NewService(sf.Document(), client), nil
}
```

---

## Phase 3: Error Handling & Observability

### Task 3.1: gRPC Error Code Mapping

**File:** `internal/query/internal/grpc/server.go`

- [ ] Map Indexer errors to gRPC status codes

| Indexer Error | gRPC Code |
|---------------|-----------|
| `ErrNoMatchingIndex` | `FailedPrecondition` |
| `ErrIndexRebuilding` | `Unavailable` |
| `ErrIndexNotReady` | `Unavailable` |

### Task 3.2: Health Check

- [ ] Query Service health check includes Indexer status

---

## Acceptance Criteria

- [ ] All existing tests pass
- [ ] Standalone mode (`--standalone`): direct calls work
- [ ] Distributed mode (`--all`, `--query`, default): uses gRPC
- [ ] Startup fails with clear error when Indexer unavailable
- [ ] Indexer errors propagate correctly to clients
