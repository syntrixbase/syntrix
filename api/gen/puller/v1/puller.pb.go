// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.21.12
// source: puller.proto

package pullerv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// SubscribeRequest configures a subscription to the event stream.
type SubscribeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Consumer identifier for logging/monitoring only.
	// Does not affect event delivery.
	ConsumerId string `protobuf:"bytes,1,opt,name=consumer_id,json=consumerId,proto3" json:"consumer_id,omitempty"`
	// Progress marker from last processed event.
	// Return events AFTER this marker (exclusive).
	// Empty = start from current head (no historical events).
	After string `protobuf:"bytes,2,opt,name=after,proto3" json:"after,omitempty"`
	// Enable catch-up coalescing when consumer is behind.
	// When enabled and consumer is catching up, multiple events
	// for the same document may be merged.
	CoalesceOnCatchUp bool `protobuf:"varint,3,opt,name=coalesce_on_catch_up,json=coalesceOnCatchUp,proto3" json:"coalesce_on_catch_up,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *SubscribeRequest) Reset() {
	*x = SubscribeRequest{}
	mi := &file_puller_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscribeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeRequest) ProtoMessage() {}

func (x *SubscribeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_puller_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeRequest.ProtoReflect.Descriptor instead.
func (*SubscribeRequest) Descriptor() ([]byte, []int) {
	return file_puller_proto_rawDescGZIP(), []int{0}
}

func (x *SubscribeRequest) GetConsumerId() string {
	if x != nil {
		return x.ConsumerId
	}
	return ""
}

func (x *SubscribeRequest) GetAfter() string {
	if x != nil {
		return x.After
	}
	return ""
}

func (x *SubscribeRequest) GetCoalesceOnCatchUp() bool {
	if x != nil {
		return x.CoalesceOnCatchUp
	}
	return false
}

// PullerEvent is the top-level wrapper for events emitted by the Puller service.
type PullerEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The actual change event.
	ChangeEvent *ChangeEvent `protobuf:"bytes,1,opt,name=change_event,json=changeEvent,proto3" json:"change_event,omitempty"`
	// Current progress marker (opaque string).
	// Consumer should save this value and pass it as 'after'
	// when reconnecting to resume from this position.
	Progress      string `protobuf:"bytes,2,opt,name=progress,proto3" json:"progress,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PullerEvent) Reset() {
	*x = PullerEvent{}
	mi := &file_puller_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PullerEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PullerEvent) ProtoMessage() {}

func (x *PullerEvent) ProtoReflect() protoreflect.Message {
	mi := &file_puller_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PullerEvent.ProtoReflect.Descriptor instead.
func (*PullerEvent) Descriptor() ([]byte, []int) {
	return file_puller_proto_rawDescGZIP(), []int{1}
}

func (x *PullerEvent) GetChangeEvent() *ChangeEvent {
	if x != nil {
		return x.ChangeEvent
	}
	return nil
}

func (x *PullerEvent) GetProgress() string {
	if x != nil {
		return x.Progress
	}
	return ""
}

// ChangeEvent represents a normalized change event from the database.
type ChangeEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique event identifier.
	EventId string `protobuf:"bytes,1,opt,name=event_id,json=eventId,proto3" json:"event_id,omitempty"`
	// Tenant identifier.
	Tenant string `protobuf:"bytes,2,opt,name=tenant,proto3" json:"tenant,omitempty"`
	// Mongo collection name.
	MgoColl string `protobuf:"bytes,3,opt,name=mgo_coll,json=mgoColl,proto3" json:"mgo_coll,omitempty"`
	// Mongo document identifier.
	MgoDocId string `protobuf:"bytes,4,opt,name=mgo_doc_id,json=mgoDocId,proto3" json:"mgo_doc_id,omitempty"`
	// Operation type: "insert", "update", "replace", or "delete".
	OpType string `protobuf:"bytes,5,opt,name=op_type,json=opType,proto3" json:"op_type,omitempty"`
	// Full document after the change (JSON encoded storage.StoredDoc).
	// Empty for delete operations.
	FullDoc []byte `protobuf:"bytes,6,opt,name=full_doc,json=fullDoc,proto3" json:"full_doc,omitempty"`
	// Description of update changes (JSON encoded).
	// Only present for update operations.
	UpdateDesc []byte `protobuf:"bytes,7,opt,name=update_desc,json=updateDesc,proto3" json:"update_desc,omitempty"`
	// MongoDB cluster timestamp.
	ClusterTime *ClusterTime `protobuf:"bytes,8,opt,name=cluster_time,json=clusterTime,proto3" json:"cluster_time,omitempty"`
	// Unix timestamp in milliseconds when the event was received.
	Timestamp int64 `protobuf:"varint,9,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Transaction number if part of a transaction.
	TxnNumber int64 `protobuf:"varint,10,opt,name=txn_number,json=txnNumber,proto3" json:"txn_number,omitempty"`
	// Backend identifier.
	Backend       string `protobuf:"bytes,11,opt,name=backend,proto3" json:"backend,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChangeEvent) Reset() {
	*x = ChangeEvent{}
	mi := &file_puller_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChangeEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChangeEvent) ProtoMessage() {}

func (x *ChangeEvent) ProtoReflect() protoreflect.Message {
	mi := &file_puller_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChangeEvent.ProtoReflect.Descriptor instead.
func (*ChangeEvent) Descriptor() ([]byte, []int) {
	return file_puller_proto_rawDescGZIP(), []int{2}
}

func (x *ChangeEvent) GetEventId() string {
	if x != nil {
		return x.EventId
	}
	return ""
}

func (x *ChangeEvent) GetTenant() string {
	if x != nil {
		return x.Tenant
	}
	return ""
}

func (x *ChangeEvent) GetMgoColl() string {
	if x != nil {
		return x.MgoColl
	}
	return ""
}

func (x *ChangeEvent) GetMgoDocId() string {
	if x != nil {
		return x.MgoDocId
	}
	return ""
}

func (x *ChangeEvent) GetOpType() string {
	if x != nil {
		return x.OpType
	}
	return ""
}

func (x *ChangeEvent) GetFullDoc() []byte {
	if x != nil {
		return x.FullDoc
	}
	return nil
}

func (x *ChangeEvent) GetUpdateDesc() []byte {
	if x != nil {
		return x.UpdateDesc
	}
	return nil
}

func (x *ChangeEvent) GetClusterTime() *ClusterTime {
	if x != nil {
		return x.ClusterTime
	}
	return nil
}

func (x *ChangeEvent) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *ChangeEvent) GetTxnNumber() int64 {
	if x != nil {
		return x.TxnNumber
	}
	return 0
}

func (x *ChangeEvent) GetBackend() string {
	if x != nil {
		return x.Backend
	}
	return ""
}

// ClusterTime represents MongoDB cluster timestamp for ordering.
type ClusterTime struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Seconds since Unix epoch.
	T uint32 `protobuf:"varint,1,opt,name=t,proto3" json:"t,omitempty"`
	// Increment within the second (for ordering multiple events).
	I             uint32 `protobuf:"varint,2,opt,name=i,proto3" json:"i,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClusterTime) Reset() {
	*x = ClusterTime{}
	mi := &file_puller_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterTime) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterTime) ProtoMessage() {}

func (x *ClusterTime) ProtoReflect() protoreflect.Message {
	mi := &file_puller_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterTime.ProtoReflect.Descriptor instead.
func (*ClusterTime) Descriptor() ([]byte, []int) {
	return file_puller_proto_rawDescGZIP(), []int{3}
}

func (x *ClusterTime) GetT() uint32 {
	if x != nil {
		return x.T
	}
	return 0
}

func (x *ClusterTime) GetI() uint32 {
	if x != nil {
		return x.I
	}
	return 0
}

var File_puller_proto protoreflect.FileDescriptor

const file_puller_proto_rawDesc = "" +
	"\n" +
	"\fpuller.proto\x12\x11syntrix.puller.v1\"z\n" +
	"\x10SubscribeRequest\x12\x1f\n" +
	"\vconsumer_id\x18\x01 \x01(\tR\n" +
	"consumerId\x12\x14\n" +
	"\x05after\x18\x02 \x01(\tR\x05after\x12/\n" +
	"\x14coalesce_on_catch_up\x18\x03 \x01(\bR\x11coalesceOnCatchUp\"l\n" +
	"\vPullerEvent\x12A\n" +
	"\fchange_event\x18\x01 \x01(\v2\x1e.syntrix.puller.v1.ChangeEventR\vchangeEvent\x12\x1a\n" +
	"\bprogress\x18\x02 \x01(\tR\bprogress\"\xe8\x02\n" +
	"\vChangeEvent\x12\x19\n" +
	"\bevent_id\x18\x01 \x01(\tR\aeventId\x12\x16\n" +
	"\x06tenant\x18\x02 \x01(\tR\x06tenant\x12\x19\n" +
	"\bmgo_coll\x18\x03 \x01(\tR\amgoColl\x12\x1c\n" +
	"\n" +
	"mgo_doc_id\x18\x04 \x01(\tR\bmgoDocId\x12\x17\n" +
	"\aop_type\x18\x05 \x01(\tR\x06opType\x12\x19\n" +
	"\bfull_doc\x18\x06 \x01(\fR\afullDoc\x12\x1f\n" +
	"\vupdate_desc\x18\a \x01(\fR\n" +
	"updateDesc\x12A\n" +
	"\fcluster_time\x18\b \x01(\v2\x1e.syntrix.puller.v1.ClusterTimeR\vclusterTime\x12\x1c\n" +
	"\ttimestamp\x18\t \x01(\x03R\ttimestamp\x12\x1d\n" +
	"\n" +
	"txn_number\x18\n" +
	" \x01(\x03R\ttxnNumber\x12\x18\n" +
	"\abackend\x18\v \x01(\tR\abackend\")\n" +
	"\vClusterTime\x12\f\n" +
	"\x01t\x18\x01 \x01(\rR\x01t\x12\f\n" +
	"\x01i\x18\x02 \x01(\rR\x01i2c\n" +
	"\rPullerService\x12R\n" +
	"\tSubscribe\x12#.syntrix.puller.v1.SubscribeRequest\x1a\x1e.syntrix.puller.v1.PullerEvent0\x01B;Z9github.com/syntrixbase/syntrix/api/gen/puller/v1;pullerv1b\x06proto3"

var (
	file_puller_proto_rawDescOnce sync.Once
	file_puller_proto_rawDescData []byte
)

func file_puller_proto_rawDescGZIP() []byte {
	file_puller_proto_rawDescOnce.Do(func() {
		file_puller_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_puller_proto_rawDesc), len(file_puller_proto_rawDesc)))
	})
	return file_puller_proto_rawDescData
}

var file_puller_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_puller_proto_goTypes = []any{
	(*SubscribeRequest)(nil), // 0: syntrix.puller.v1.SubscribeRequest
	(*PullerEvent)(nil),      // 1: syntrix.puller.v1.PullerEvent
	(*ChangeEvent)(nil),      // 2: syntrix.puller.v1.ChangeEvent
	(*ClusterTime)(nil),      // 3: syntrix.puller.v1.ClusterTime
}
var file_puller_proto_depIdxs = []int32{
	2, // 0: syntrix.puller.v1.PullerEvent.change_event:type_name -> syntrix.puller.v1.ChangeEvent
	3, // 1: syntrix.puller.v1.ChangeEvent.cluster_time:type_name -> syntrix.puller.v1.ClusterTime
	0, // 2: syntrix.puller.v1.PullerService.Subscribe:input_type -> syntrix.puller.v1.SubscribeRequest
	1, // 3: syntrix.puller.v1.PullerService.Subscribe:output_type -> syntrix.puller.v1.PullerEvent
	3, // [3:4] is the sub-list for method output_type
	2, // [2:3] is the sub-list for method input_type
	2, // [2:2] is the sub-list for extension type_name
	2, // [2:2] is the sub-list for extension extendee
	0, // [0:2] is the sub-list for field type_name
}

func init() { file_puller_proto_init() }
func file_puller_proto_init() {
	if File_puller_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_puller_proto_rawDesc), len(file_puller_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   4,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_puller_proto_goTypes,
		DependencyIndexes: file_puller_proto_depIdxs,
		MessageInfos:      file_puller_proto_msgTypes,
	}.Build()
	File_puller_proto = out.File
	file_puller_proto_goTypes = nil
	file_puller_proto_depIdxs = nil
}
