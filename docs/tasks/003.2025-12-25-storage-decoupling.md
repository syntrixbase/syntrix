# Storage Abstraction & Provider Plan

Date: 2025-12-25
Status: Completed
Scope: Server Storage Layer (Decouple Mongo, Provider Pattern, Routing Hook)

## 1. Why (Reasoning)

- Current code leaks Mongo types (`*mongo.Database`, `DB()`), coupling upper layers to implementation.
- Upcoming need: different backends for data/user/revocation, plus routing (read/write split, migration).
- Decoupling improves testability (mockable interfaces), allows gradual backend diversification.

## 2. Scope / Non-goals

- In scope: interface split (Document/User/Revocation), Provider pattern, Mongo implementation kept but hidden, routing hook at interface layer.
- Out of scope: introducing a second backend now; migration tooling and live cutover policies.

## 3. Interfaces (public surface, no Mongo types)

- `DocumentStore`: `Get/Create/Update/Patch/Delete/Query/Watch/Close`.
- `UserStore`: `CreateUser/GetUserByUsername/GetUserByID/UpdateUserLoginStats/ListUsers/UpdateUser/EnsureIndexes/Close` (Close optional but recommended for parity).
- `TokenRevocationStore`: `RevokeToken/RevokeTokenImmediate/IsRevoked/EnsureIndexes/Close`.
  (Aggregation type intentionally omitted to keep injection explicit.)

## 4. Provider Pattern

- Split providers by usage domain to avoid unused deps:
  - `DocumentProvider` (used by Query): `Document() DocumentStore`, `Close(ctx) error`.
  - `AuthProvider` (used by Auth): `Users() UserStore`, `Revocations() TokenRevocationStore`, `Close(ctx) error`.
- Each provider owns its backend connection/config, calls `EnsureIndexes` during construction, and manages its own lifecycle.
- Optional thin wrapper `storage.NewFromConfig(cfg.Storage)` can assemble both providers for Manager convenience, but internals stay split so callers only receive what they need.
- Backend selection remains config-driven, allowing per-store backends (document/user/revocation can differ).

## 5. Mongo Implementation (initial backend, hidden)

- Files under `internal/storage/mongo/`:
  - `document_store.go`: current MongoBackend logic adapted to `DocumentStore` interface, no `DB()` exposure.
  - `user_store.go`: move auth Mongo logic here implementing `UserStore`.
  - `revocation_store.go`: split from auth storage implementing `TokenRevocationStore`.
  - `document_provider.go`: builds client/collections for documents, wires strategy, calls `EnsureIndexes`, exposes `DocumentProvider`.
  - `auth_provider.go`: builds client/collections for users+revocations, calls `EnsureIndexes`, exposes `AuthProvider`.
- Reuse single Mongo connection/config for now (per requirement: same underlying implementation), but separated interfaces allow future divergence.

## 6. Routing / Multi-backend Readiness

- Add routing hook at Provider level: allow optional strategy config (future) to return different store impls for read vs write or migration (e.g., dual-write, read-primary/write-both).
- Interface remains stable; routing logic lives inside Provider (policy object), so callers stay unchanged.
- For now, default strategy returns single Mongo-backed stores.

- Interface sketch (Go):

  ```go
  type OpKind int

  const (
    OpRead OpKind = iota
    OpWrite
    OpMigrate // dual-write / cutover flows
  )

  type Router interface {
    SelectDocument(op OpKind) storage.DocumentStore
    SelectUser(op OpKind) storage.UserStore
    SelectRevocation(op OpKind) storage.TokenRevocationStore
  }

  // Default single-backend router: returns primary for all ops.
  type SingleRouter struct {
    doc storage.DocumentStore
    usr storage.UserStore
    rev storage.TokenRevocationStore
  }

  func (r *SingleRouter) SelectDocument(_ OpKind) storage.DocumentStore     { return r.doc }
  func (r *SingleRouter) SelectUser(_ OpKind) storage.UserStore             { return r.usr }
  func (r *SingleRouter) SelectRevocation(_ OpKind) storage.TokenRevocationStore { return r.rev }
  ```

- Provider usage: when strategy is nil, instantiate `SingleRouter` with primary stores and ensure callers always receive a router instance (no nil).

## 7. Manager Wiring Changes

- Replace `mongoBackendFactory` with domain-specific factories: `NewDocumentProvider(...)` and `NewAuthProvider(...)`.
- `initStorage`: builds `DocumentProvider` and hands `DocumentStore` to Query engine only.
- `initAuthService`: builds `AuthProvider` and injects `UserStore` + `TokenRevocationStore` separately into auth service; no aggregated `AuthStore` needed.
- Ensure index creation stays inside providers; Manager does not touch Mongo specifics.

## 8. Configuration (now vs future)

- Now: can still reuse one Mongo config if desired.
- Future/alt: allow per-store backend config (e.g., Document=Mongo, User=Postgre, Revocation=Redis) and routing policies (read/write split, migration dual-write) without API changes; composition happens in storage wiring (config-driven).

- Example sketch:

  ```yaml
  storage:
    document:
      backend: mongo
      mongo:
        uri: ...
        db: ...
        dataCollection: ...
        sysCollection: ...
        softDeleteRetention: ...
    user:
      backend: postgre
      postgre:
        dsn: ...
    revocation:
      backend: redis
      redis:
        addr: ...
        db: 0
        prefix: syntrix:rev
    routing:
      document:
        strategy: single        # single | dual-write | read-replica
        primary: mongo
        shadow:  pg-doc         # optional for migration
        reads: primary          # primary | shadow | both
        writes: primary         # primary | both
      user:
        strategy: single        # same defaults apply
        primary: postgre
      revocation:
        strategy: single        # same defaults apply
        primary: redis
  ```

## 9. Migration Steps

1) Define interfaces in stable packages (no Mongo imports).
2) Implement Mongo stores + Providers (document/auth); move auth Mongo logic out of `internal/auth/storage.go` into `internal/storage/mongo`.
3) Refactor Manager to consume Provider interfaces; update service constructors.
4) Update tests to build via Provider; add fakes/mocks for unit tests.
5) Remove/stop exposing `DB()` and any direct Mongo usage in upper layers.

## 10. Testing Plan (testify)

- Unit: Mongo document/user/revocation stores CRUD/index/error paths; Provider init failure cases.
- Service-layer tests: use interface fakes to avoid real Mongo.
- Integration: keep black-box via public API; ensure no direct DB usage remains.

## 11. Risks / Mitigations

- Hidden dependency leaks: audit for `*mongo.Database` usage; fail build if lingering references remain.
- Index creation ordering: ensure Provider calls `EnsureIndexes` once during init.
- Routing complexity: start with no-op strategy; design strategy interface early to avoid churn.
- Wrapper clarity: if `storage.NewFromConfig` is provided, it must still return split `DocumentProvider`/`AuthProvider` to avoid leaking unused stores.
- Routing defaults: define `OpKind` (Read/Write/Migrate) and a default single strategy; provider must fall back to default when strategy is nil.
- Error taxonomy: standardize `ErrInvalidArgument`/`ErrInternal`/`ErrNotFound` (or equivalents) and wrap backend errors consistently; for watch, expose a retryable sentinel (e.g., `ErrRetryable`).
- Resume token handling: validate and convert watch `resumeToken` eagerly; reject unsupported types with `ErrInvalidArgument`.
- Close lifecycle: enforce shutdown order (stop services â†’ close providers); make `Close` idempotent and close partial resources on construction failure.
- EnsureIndexes failure: provider construction should fail fast and clean up resources when index creation fails; cover in tests.
- Config defaults: default backend = mongo when unspecified; routing defaults to `strategy: single`; keep YAML fields aligned with Go structs.
- Testability: provide fake/mocks for Query/Auth interfaces to keep service tests Mongo-free.
- Dual-write behavior: document error handling for shadow writes (ignore vs propagate/alert) to avoid assumptions of silent drop.

## 12. Deliverables

- Interface definitions + Mongo provider/stores.
- Manager wiring refactor.
- Updated/unit tests (testify) and docs.

## 13. Detailed Interface Draft

- DocumentStore
  - Get(ctx, path string) (*storage.Document, error)
  - Create(ctx, doc *storage.Document) error
  - Update(ctx, path string, data map[string]interface{}, pred model.Filters) error
  - Patch(ctx, path string, data map[string]interface{}, pred model.Filters) error
  - Delete(ctx, path string, pred model.Filters) error
  - Query(ctx, q model.Query) ([]*storage.Document, error)
  - Watch(ctx, collection string, resumeToken any, opts storage.WatchOptions) (<-chan storage.Event, error)
  - Close(ctx context.Context) error

- UserStore
  - CreateUser(ctx, user *authn.User) error
  - GetUserByUsername(ctx, username string) (*authn.User, error)
  - GetUserByID(ctx, id string) (*authn.User, error)
  - UpdateUserLoginStats(ctx, id string, lastLogin time.Time, attempts int, lockoutUntil time.Time) error
  - ListUsers(ctx, limit, offset int) ([]*authn.User, error)
  - UpdateUser(ctx, user *authn.User) error
  - EnsureIndexes(ctx context.Context) error
  - Close(ctx context.Context) error

- TokenRevocationStore
  - RevokeToken(ctx, jti string, expiresAt time.Time) error
  - RevokeTokenImmediate(ctx, jti string, expiresAt time.Time) error
  - IsRevoked(ctx, jti string, gracePeriod time.Duration) (bool, error)
  - EnsureIndexes(ctx context.Context) error
  - Close(ctx context.Context) error

- Providers (split)
  - DocumentProvider: Document() DocumentStore; Close(ctx context.Context) error
  - AuthProvider: Users() UserStore; Revocations() TokenRevocationStore; Close(ctx context.Context) error

- Auth constructor
  - `authn.NewAuthService(userStore UserStore, revStore TokenRevocationStore, tokenSvc ...)`
  - No aggregated `AuthStore` is exposed; provider can still offer convenience accessors internally, but public injection stays explicit with two parameters.

- Query / Watch error semantics
  - Query: semantic errors (invalid fields/sort) return `ErrInvalidArgument`; backend failures return `ErrInternal`; empty results return an empty slice.
  - Watch: invalid `resumeToken` returns `ErrInvalidArgument`; unsupported collection returns `ErrInvalidArgument`/`ErrNotFound`; stream interruption returns a retryable error and may include a new `resumeToken`; ctx cancellation returns `ctx.Err()` directly.

- Routing hook (multi-backend/read-write split readiness)
  - Strategy interface sketch: SelectDocument(op OpKind) DocumentStore; SelectUser(op OpKind) UserStore; SelectRevocation(op OpKind) TokenRevocationStore. OpKind distinguishes read/write/migrate. Default strategy returns single Mongo-backed stores.
  - Clarification: routing can apply to any store (document/user/revocation). If unspecified, default strategy is `single` (reads=writes=primary).

## 14. Proposed Layout

```text
internal/storage/
  types.go
  provider/ (optional; could be same level)
    document_provider.go # DocumentProvider interface + default impl wiring
    auth_provider.go     # AuthProvider interface + default impl wiring
  mongo/
    document_provider.go # Builds client, strategy, EnsureIndexes for docs
    auth_provider.go     # Builds client, EnsureIndexes for users/revocations
    document_store.go    # DocumentStore impl (from current backend)
    user_store.go        # UserStore impl (from auth storage)
    revocation_store.go  # TokenRevocationStore impl
    utils.go             # BSON mapping helpers

  postgre/               # optional future backend for users
    provider.go
    user_store.go

  redis/                 # optional future backend for revocations
    provider.go
    revocation_store.go

internal/auth/
  service.go             # depends on UserStore + TokenRevocationStore
  types.go
  storage.go             # if kept, only adapter/interface alias; Mongo impl moves to mongo/

internal/services/
  manager.go / manager_init.go # use Provider to fetch stores; no DB exposure
```

## 15. Usage Examples (sketches)

- Manager init (single backend, no routing yet)

  ```go
  docProv, err := storage.NewDocumentProvider(ctx, cfg.Storage.Document)
  if err != nil { return err }
  authProv, err := storage.NewAuthProvider(ctx, cfg.Storage.Auth)
  if err != nil { return err }
  engine := query.NewEngine(docProv.Document(), cfg.Query.CSPServiceURL)
  authSvc := authn.NewAuthService(authProv.Users(), authProv.Revocations(), tokenSvc)
  ```

- Dual-write migration strategy (future-ready)

  ```go
  strategy := router.NewDualWriteStrategy(
      primary: mongoDocStore,
      shadow:  otherDocStore,
      readsFrom: router.Primary,
      writesTo: router.Both,
  )
  docProv := mongo.NewDocumentProviderWithStrategy(client, strategy)
  docStore := docProv.Document() // internally routed
  ```

- Unit test with fake stores (no Mongo)

  ```go
  fakeUsers := fakes.NewUserStore()
  fakeRevs  := fakes.NewRevocationStore()
  authSvc := authn.NewAuthService(fakeUsers, fakeRevs, tokenSvc)
  // exercise SignIn/Refresh without real DB
  ```

- Mixed backends per store (Mongo docs, PG users, Redis revocations)

  ```go
  docProv, _ := storage.NewDocumentProvider(ctx, cfg.Storage.Document)   // Mongo
  authProv, _ := storage.NewAuthProvider(ctx, cfg.Storage.Auth)         // Postgre users, Redis revocations

  engine := query.NewEngine(docProv.Document(), cfg.Query.CSPServiceURL)
  authSvc := authn.NewAuthService(authProv.Users(), authProv.Revocations(), tokenSvc)
  ```
