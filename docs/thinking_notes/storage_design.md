# 底层存储

现在使用的是MongoDB作为底层存储+索引引擎, 这个在原型验证和小规模用户下是够用的.
但是如果上规模, 比如1M+活跃用户, 那么这个方案会成为瓶颈, 我们可以考虑主存储和索引存储分开

## 主存储

系统对主存储的要求很低, 只需要支持:

- 点查询 - 按主key单点或者批量查询, 这个主要是从索引里拿到id后从主存拿数据
- 前缀扫描 - 主要用来按collection扫描全集, 用来重建索引

基于上面的要求, 主存储的可选项:

- MongoDB - 这个正式它的强项, 性能会非常好, 同时也支持原生分布式.
  - 通过_id来点(或者批量)查询
  - 为collection建一个Secondary Index, 因为这是一个high-capacity数据集, 索引友好, 另外update的时候不会更新它, 也就不会触发索引更新
  - 同时它有一个很好的change stream机制, 用来被动触发索引更新
- Azure Table Storage - 一个性能非常好的KV存储云服务, 而且很便宜. 通过collection来partition.
- AWS DynamoDB
- 很多分布式KV数据库也可以作为主存, 比如: TiKV. 当需要的时候可以仔细评估.

### 数据分层

所有数据长期驻留主存是很浪费的, 可以设计一个hot/warm/cold的路径, 在我们这个数据库里其实对冷热分离非常有好, 可以按collection的维度去做.

- Hot: 数据在主存, 索引Ready, 访问延迟非常低.
- Warm: 数据在主存, 索引可能已经被删掉了, 大集合重建索引会有秒级的延迟, 小集合在技术统计上会有延迟, 但是用户体验可能影响不大.
- Cold: 数据已被归档(从主存删除, 索引也删除), 这个时候访问需要从冷备里恢复, 会引入显著的延迟, 大集合 (5-10s), 小集合(1-2s).

冷数据可以归档到blob storage, 按collection打包成zip. 当需要的时候可以从blob 重新回填主存

## 索引存储

索引存储是一件比较麻烦的事情, 好在我们的查询比较简单, 不需要像SQL那种复杂的查询, 简单来说只要这个存储能够支持按key前缀来有序扫描就可以了.
那么很多KV都具备这个能力, 比如:

- RocksDB - 这是一个高性能的单机KV数据库, 拥有极为出色的写入性能.
  索引是一种可以被重建的二级数据, 对可靠性的要求没有那么高.
  只要每份索引有超过一个以上的副本(不需要一致性协议, 每一个copy都是从原始据生成), 那么即使有机器挂掉也不影响服务.
  扩容也相对比较容易, 只要拉新机器起来, 然后分配索引就行了.
  这里对索引的管理调度有一些挑战, 但这是成熟的工程问题.
- TiKV - 一个分布式KV存储, 支持按key扫描, 可能有点重.
- 很多云服务也提供类似的产品, 但是需要仔细评估, 比如: Azure COSMOS DB, Azure Table Storage

## 我们怎么选

其实我觉得这里不用决定一定用什么, 可以按需求做成可插拔的, 但我更偏向于:

- MongoDB + RocksDB这个组合, 完全不会被云服务商绑架

对于MongoDB作为主存, 我们可以扩展集群来水平扩展, 甚至可以建立多集群来扩展容量(如果单机集群太大了的话)
