# File Logging Design

**Date:** January 19, 2026
**Status:** Draft

## 1. Background & Problem Statement

Currently, Syntrix uses Go's `log/slog` standard library for structured logging, which is output only to stdout. While this works for development and containerized deployments with external log aggregation, it presents several challenges:

**Current State:**
- ✅ Using `log/slog` (Go 1.21+ standard library) with structured logging
- ✅ Good logging patterns with context propagation (request IDs, component names)
- ✅ Proper log levels (Debug, Info, Warn, Error)
- ❌ No file persistence - logs are lost when stdout is not captured
- ❌ No log rotation - potential disk space issues
- ❌ No configuration - hardcoded to stdout
- ❌ No separate error tracking - all logs mixed together

**Issues:**
1. **No Persistence**: Logs are lost if stdout is not redirected or captured by external systems
2. **Debugging Difficulty**: Hard to troubleshoot production issues without historical logs
3. **No Rotation**: If writing to files manually, no automatic cleanup/rotation
4. **Mixed Logs**: Error logs are not separated from informational logs, making incident response slower

## 2. Goals

Implement a file-based logging system that:
1. **Maintains Backward Compatibility**: Continue using `log/slog` API, no code changes required in existing services
2. **Adds File Persistence**: Write logs to rotating files on disk
3. **Separates Error Logs**: Maintain a separate `errors.log` for warn/error level logs
4. **Configurable**: Support flexible configuration for log directory, format, and rotation policies
5. **Production-Ready**: Support log rotation, compression, and retention policies

## 3. Requirements

### 3.1 Functional Requirements

#### Log Output Destinations
- **Console Output**: Continue supporting stdout output (enabled by default)
- **Main Log File**: All logs written to `syntrix.log`
- **Error Log File**: Warn and Error level logs written to separate `errors.log`
- **Multi-Output**: Support writing to console and files simultaneously

#### Log Format
- **Default Format**: Text format (human-readable)
- **Alternative Format**: JSON format (machine-readable, for log aggregation systems)
- **Configurable**: Format can be specified per output destination

#### Log Rotation
- **Rotation Strategy**: Rotate by file size (primary)
- **Max File Size**: Configurable, default 100MB per file
- **Retention Policy**:
  - Keep last N rotated files (default: 10)
  - Delete files older than N days (default: 30)
- **Compression**: Automatically gzip rotated files to save disk space
- **Naming Convention**: `syntrix-YYYYMMDD-NNN.log[.gz]`

#### Configuration
- **Log Directory**: Configurable directory path (relative or absolute)
  - Default: `logs/` (relative to working directory)
  - Example: `/var/log/syntrix/` (absolute path for production)
- **Log Level**: Global log level (debug, info, warn, error)
- **Per-Destination Configuration**: Each output can have different levels and formats

#### File Structure
```
logs/                          # Configurable directory
├── syntrix.log                # Current main log (all levels)
├── syntrix-20260119-001.log   # Rotated log (by size)
├── syntrix-20260119-002.log.gz # Compressed rotated log
├── errors.log                 # Current error log (warn + error only)
├── errors-20260119-001.log    # Rotated error log
└── errors-20260119-002.log.gz # Compressed rotated error log
```

### 3.2 Non-Functional Requirements

#### Performance
- **Asynchronous Writing**: Log writes should not block application threads
- **Buffering**: Use buffered I/O to minimize system calls
- **Minimal Overhead**: Logging should add < 5% CPU overhead

#### Reliability
- **Graceful Degradation**: If file writing fails, continue logging to console
- **Automatic Recovery**: Attempt to recreate log files if they are deleted
- **Atomic Rotation**: Log rotation should not lose messages

#### Observability
- **Startup Logging**: Log the logging configuration at startup
- **Error Reporting**: Log any logging system errors to stderr

## 4. Design

### 4.1 Architecture

```
┌─────────────────────────────────────────────────────┐
│                  Application Code                    │
│            (uses slog.Info/Warn/Error)              │
└──────────────────┬──────────────────────────────────┘
                   │
                   ▼
         ┌─────────────────────┐
         │  slog.Logger        │
         │  (Global Default)   │
         └──────────┬──────────┘
                    │
                    ▼
         ┌──────────────────────┐
         │   MultiHandler       │
         │  (Fan-out to all)    │
         └──┬────────┬─────────┬┘
            │        │         │
    ────────┘        │         └────────
    │               │                  │
    ▼               ▼                  ▼
┌─────────┐  ┌──────────────┐  ┌──────────────┐
│ Console │  │  Main File   │  │  Error File  │
│ Handler │  │   Handler    │  │   Handler    │
│         │  │ (all levels) │  │ (warn+error) │
└─────────┘  └──────┬───────┘  └──────┬───────┘
                    │                  │
                    ▼                  ▼
             ┌─────────────┐    ┌─────────────┐
             │ lumberjack  │    │ lumberjack  │
             │  (rotation) │    │  (rotation) │
             └──────┬──────┘    └──────┬──────┘
                    │                  │
                    ▼                  ▼
              syntrix.log        errors.log
```

### 4.2 Configuration Structure

#### YAML Configuration (`configs/config.yml`)
```yaml
logging:
  # Global log level: debug, info, warn, error
  level: "info"

  # Log format: text, json
  format: "text"

  # Log directory (relative or absolute path)
  # Relative paths are relative to the working directory
  # Default: "logs"
  dir: "logs"

  # File rotation settings
  rotation:
    # Maximum size in megabytes before rotation
    max_size: 100

    # Maximum number of old log files to retain
    max_backups: 10

    # Maximum days to retain old log files
    max_age: 30

    # Compress rotated files with gzip
    compress: true

  # Console output configuration
  console:
    enabled: true
    level: "info"    # Can override global level
    format: "text"   # text or json

  # Main file output configuration
  file:
    enabled: true
    level: "info"    # Can override global level
    format: "text"   # text or json
```

#### Go Configuration Structure
```go
// internal/config/logging.go
package config

import "time"

type LoggingConfig struct {
    Level    string           `yaml:"level"`    // debug, info, warn, error
    Format   string           `yaml:"format"`   // text, json
    Dir      string           `yaml:"dir"`      // log directory path
    Rotation RotationConfig   `yaml:"rotation"`
    Console  ConsoleConfig    `yaml:"console"`
    File     FileConfig       `yaml:"file"`
}

type RotationConfig struct {
    MaxSize    int  `yaml:"max_size"`    // MB
    MaxBackups int  `yaml:"max_backups"` // number of files
    MaxAge     int  `yaml:"max_age"`     // days
    Compress   bool `yaml:"compress"`    // gzip old files
}

type ConsoleConfig struct {
    Enabled bool   `yaml:"enabled"`
    Level   string `yaml:"level"`  // optional override
    Format  string `yaml:"format"` // text or json
}

type FileConfig struct {
    Enabled bool   `yaml:"enabled"`
    Level   string `yaml:"level"`  // optional override
    Format  string `yaml:"format"` // text or json
}
```

### 4.3 Default Values

```go
func DefaultLoggingConfig() LoggingConfig {
    return LoggingConfig{
        Level:  "info",
        Format: "text",
        Dir:    "logs",
        Rotation: RotationConfig{
            MaxSize:    100,
            MaxBackups: 10,
            MaxAge:     30,
            Compress:   true,
        },
        Console: ConsoleConfig{
            Enabled: true,
            Level:   "info",
            Format:  "text",
        },
        File: FileConfig{
            Enabled: true,
            Level:   "info",
            Format:  "text",
        },
    }
}
```

### 4.4 Log Format Examples

#### Text Format (Default)
```
2026-01-19T16:30:00.123Z INFO HTTP Request component=server method=POST path=/v1/databases/default/collections/users/documents status=200 duration_ms=15 request_id=abc123
2026-01-19T16:30:00.456Z ERROR Database connection failed component=storage error="connection timeout" retry_count=3
```

#### JSON Format
```json
{"time":"2026-01-19T16:30:00.123Z","level":"INFO","msg":"HTTP Request","component":"server","method":"POST","path":"/v1/databases/default/collections/users/documents","status":200,"duration_ms":15,"request_id":"abc123"}
{"time":"2026-01-19T16:30:00.456Z","level":"ERROR","msg":"Database connection failed","component":"storage","error":"connection timeout","retry_count":3}
```

### 4.5 Implementation Components

#### New Package: `internal/logging`

```
internal/logging/
├── logger.go           # Main logger initialization
├── handler.go          # Custom handler implementations
├── multi_handler.go    # Fan-out to multiple handlers
├── level_filter.go     # Filter handler by log level
└── logger_test.go      # Unit tests
```

#### Key Functions

```go
// internal/logging/logger.go
package logging

import (
    "log/slog"
    "github.com/syntrixbase/syntrix/internal/config"
)

// Initialize sets up the global logger based on configuration
func Initialize(cfg config.LoggingConfig) error

// NewLogger creates a new logger instance with the given configuration
func NewLogger(cfg config.LoggingConfig) (*slog.Logger, error)

// Shutdown gracefully closes all log files and flushes buffers
func Shutdown() error
```

### 4.6 Integration Points

#### Startup Sequence (`cmd/syntrix/main.go`)

```go
// 1. Load configuration
cfg := config.LoadConfig()

// 2. Initialize logging (before any other services)
if err := logging.Initialize(cfg.Logging); err != nil {
    log.Fatalf("Failed to initialize logging: %v", err)
}
defer logging.Shutdown()

// 3. Log startup message
slog.Info("Starting Syntrix", "version", Version, "mode", cfg.Deployment.Mode)

// 4. Initialize services (they will use the configured logger)
// ...
```

## 5. Dependencies

### External Libraries

**lumberjack.v2** - Log rotation library
- **Package**: `gopkg.in/natefinch/lumberjack.v2`
- **License**: MIT
- **Why**: Most mature and widely-used log rotation library for Go
- **Features**:
  - Automatic rotation by size
  - Configurable retention (by count and age)
  - Automatic compression
  - Thread-safe
  - No external dependencies

### Standard Library

- `log/slog` - Structured logging (Go 1.21+)
- `io` - I/O operations
- `os` - File operations
- `path/filepath` - Path manipulation

## 6. Migration Strategy

### Phase 1: Add Configuration (Zero Behavior Change)
- Add `LoggingConfig` to `internal/config`
- Add default values
- No behavioral changes yet (still logs to stdout only)
- **Verification**: Existing tests pass, no logs change

### Phase 2: Implement Logging Package
- Create `internal/logging` package
- Implement multi-handler, file rotation
- Unit tests for logging components
- **Verification**: Unit tests pass, no integration yet

### Phase 3: Integration
- Update `cmd/syntrix/main.go` to initialize logging
- Replace `slog.Default()` usage with configured logger
- **Verification**: Integration tests pass, logs appear in files

### Phase 4: Documentation & Testing
- Update README with logging configuration
- Add integration tests for log rotation
- Test in development and staging environments
- **Verification**: All tests pass, manual verification of log files

## 7. Testing Strategy

### Unit Tests
- Configuration parsing and defaults
- Handler initialization and message routing
- Level filtering (errors-only for `errors.log`)
- Path resolution (relative vs absolute)

### Integration Tests
- Log rotation by size
- Log compression
- Retention policy enforcement
- Concurrent logging from multiple goroutines
- Graceful shutdown and buffer flushing

### Manual Testing
- Start server, verify log files are created
- Generate logs, verify rotation occurs at size limit
- Stop server gracefully, verify no log loss
- Check compressed files are valid gzip

## 8. Performance Considerations

### Benchmarks
- Log throughput: Target > 100,000 messages/second
- CPU overhead: < 5% under normal load
- Memory overhead: < 50MB for log buffers

### Optimizations
- **Buffered I/O**: Use `bufio.Writer` to reduce syscalls
- **Async Rotation**: Rotate files in background to avoid blocking
- **Lock-Free Paths**: Minimize mutex contention in hot paths

## 9. Operational Considerations

### Disk Space Management
- **Default Settings**: ~1GB max disk usage per log type (10 files × 100MB)
- **Monitoring**: Operators should monitor `logs/` directory size
- **Recommendation**: Set up alerts if disk usage exceeds threshold

### Log Analysis
- **Text Format**: Grep-friendly for quick searches
- **JSON Format**: Can be ingested by ELK, Loki, Splunk, etc.
- **Structured Fields**: All logs include `component`, `time`, `level`, `msg`

### Troubleshooting
- If log files are not created: Check directory permissions
- If rotation is not working: Check `max_size` configuration
- If logs are lost: Check for panics before `Shutdown()` is called

## 10. Future Enhancements (Out of Scope)

### Phase 2 Features
- **Dynamic Level Adjustment**: Change log level via HTTP API without restart
- **Per-Component Levels**: Different log levels for different components
  ```yaml
  components:
    puller: debug
    gateway: info
    indexer: warn
  ```
- **Sampling**: Reduce high-frequency logs (e.g., keep 1 in 100 requests)

### Phase 3 Features
- **Remote Logging**: Send logs to external systems (Syslog, Loki, etc.)
- **Log Query API**: Simple HTTP API to query recent logs
- **Metrics Integration**: Count log messages per level, expose via Prometheus

## 11. Why This Design?

### Why Text Format by Default?
- **Human Readable**: Easier for developers to read logs during development
- **Grep-Friendly**: Quick searches without needing JSON parsers
- **Backward Compatible**: Matches current stdout behavior

### Why `lumberjack`?
- **Proven**: Used by major projects (Kubernetes, Docker, etc.)
- **Simple**: Minimal API, easy to integrate
- **Reliable**: Years of production use, well-tested
- **No External Dependencies**: Pure Go implementation

### Why Separate `errors.log`?
- **Incident Response**: Quickly find errors without filtering
- **Alerting**: Can monitor just `errors.log` for issues
- **Retention**: Can have different retention policies (keep errors longer)

### Why Not Component-Level Configuration?
- **Simplicity**: Easier to configure and understand
- **95% Use Case**: Most users need global level + error separation
- **Future**: Can be added later without breaking changes

## 12. Open Questions

- ❓ Should we support log output to both relative and absolute paths simultaneously?
  - **Decision**: No, choose one directory path (simplifies configuration)

- ❓ Should rotation happen at midnight (daily logs) in addition to size?
  - **Decision**: No, size-based rotation is sufficient (can add later if needed)

- ❓ Should we include hostname/instance ID in log messages?
  - **Decision**: Not by default (can be added via custom fields if needed)

## 13. References

- [Go slog Documentation](https://pkg.go.dev/log/slog)
- [Lumberjack GitHub](https://github.com/natefinch/lumberjack)
- [Structured Logging Best Practices](https://betterstack.com/community/guides/logging/structured-logging/)
