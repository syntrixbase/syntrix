# Indexer gRPC Service

Date: January 10, 2026
Status: Draft
Scope: gRPC service interface for distributed deployments.

> For architecture overview, see [Indexer Architecture](01.architecture.md).
> For implementation details, see [Index Implementation](02.index.md).

## Overview

Indexer exposes a gRPC service for distributed deployments where Query Engine runs in a separate process. In standalone mode, Query Engine calls Indexer directly via the `LocalService` interface without gRPC overhead.

## Deployment Modes

| Mode | Indexer Location | Query Engine Calls |
|------|------------------|-------------------|
| Standalone | Same process as Query Engine | Direct `LocalService` interface call |
| Distributed | Separate process | gRPC `IndexerService` RPC |

### Architecture Diagram

```
Standalone Mode:
┌─────────────────────────────────────────┐
│              Single Process              │
│  ┌──────────────┐   ┌────────────────┐  │
│  │ Query Engine │──>│ Indexer        │  │
│  │              │   │ (LocalService) │  │
│  └──────────────┘   └────────────────┘  │
└─────────────────────────────────────────┘

Distributed Mode:
┌──────────────────┐         ┌──────────────────┐
│   Query Engine   │  gRPC   │     Indexer      │
│                  │────────>│  (gRPC Server)   │
└──────────────────┘         └──────────────────┘
```

## Proto Definition

```proto
syntax = "proto3";
package syntrix.indexer.v1;

option go_package = "github.com/syntrixbase/syntrix/api/gen/indexer/v1;indexerv1";

service IndexerService {
  // Search executes an index query and returns ordered document references.
  // Indexer internally selects the best matching template based on
  // plan's OrderBy and Filters using Query-to-Index matching rules.
  rpc Search(SearchRequest) returns (SearchResponse);

  // Health returns the current health status of the indexer.
  rpc Health(HealthRequest) returns (HealthResponse);
}

message SearchRequest {
  string database = 1;
  string collection = 2;            // Concrete path: "users/alice/chats"
  repeated Filter filters = 3;      // Equality/range filters
  repeated OrderByField order_by = 4;
  int32 limit = 5;
  string start_after = 6;           // Base64 encoded cursor (OrderKey)
}

message Filter {
  string field = 1;
  string op = 2;                    // "eq", "gt", "lt", "gte", "lte"
  bytes value = 3;                  // JSON encoded value
}

message OrderByField {
  string field = 1;
  string direction = 2;             // "asc" or "desc"
}

message SearchResponse {
  repeated DocRef docs = 1;
  bool index_used = 2;              // false = no matching template, fallback needed
  string shard_status = 3;          // "healthy", "rebuilding", "failed"
}

message DocRef {
  string id = 1;
  string order_key = 2;             // Base64 encoded for cursor use
}

message HealthRequest {}

message HealthResponse {
  string status = 1;                // "healthy", "degraded", "unhealthy"
  map<string, ShardHealth> shards = 2;
}

message ShardHealth {
  string state = 1;                 // "healthy", "rebuilding", "failed"
  int64 doc_count = 2;
}
```

## Package Layout

```
internal/indexer/
├── interface.go           - Service/LocalService interfaces
├── service.go             - Main service implementation
├── internal/
│   ├── grpc/              - gRPC server adapter
│   │   └── server.go      - Implements IndexerServiceServer
│   ├── client/            - gRPC client (implements Service interface)
│   │   └── client.go
│   ├── manager/           - Index manager
│   ├── shard/             - Per-collection index shard
│   ├── encoding/          - OrderKey encoding/decoding
│   ├── template/          - Index template loading
│   └── rebuild/           - Rebuild orchestration
└── config/                - Indexer configuration
```

## Service Interface (Go)

```go
// Service is the public interface for Indexer (both local and remote).
type Service interface {
    Search(ctx context.Context, database string, plan Plan) (*SearchResult, error)
    Health(ctx context.Context) (*Health, error)
}

// LocalService extends Service with lifecycle and event handling methods.
// Only available for in-process usage.
type LocalService interface {
    Service

    // Start starts the indexer (loads templates, subscribes to Puller).
    Start(ctx context.Context) error

    // Stop gracefully stops the indexer.
    Stop(ctx context.Context) error

    // ApplyEvent applies a change event to update indexes.
    ApplyEvent(ctx context.Context, evt *ChangeEvent) error

    // Stats returns index statistics.
    Stats(ctx context.Context) (*Stats, error)
}

// SearchResult contains the search response with metadata.
type SearchResult struct {
    Docs        []DocRef
    IndexUsed   bool    // false = no matching template
    ShardStatus string  // "healthy", "rebuilding", "failed"
}
```

## Query Engine Integration

```go
// Query Engine pseudocode
func (q *QueryEngine) ExecuteQuery(ctx context.Context, database string, query Query) ([]Document, error) {
    // Build plan from query
    plan := Plan{
        Collection: query.Collection,
        Filters:    convertFilters(query.Where),
        OrderBy:    convertOrderBy(query.OrderBy),
        Limit:      query.Limit,
        StartAfter: query.Cursor,
    }

    // Call Indexer (local or remote via same interface)
    result, err := q.indexer.Search(ctx, database, plan)
    if err != nil {
        return nil, err
    }

    // Check if index was used
    if !result.IndexUsed || result.ShardStatus == "rebuilding" {
        // Fallback to storage scan with limit
        return q.storage.Query(ctx, database, query.WithLimit(500))
    }

    // Batch fetch documents by ID
    ids := make([]string, len(result.Docs))
    for i, doc := range result.Docs {
        ids[i] = doc.ID
    }
    return q.storage.BatchGet(ctx, database, query.Collection, ids)
}
```

## Factory Functions

```go
// NewService creates a local Indexer service (in-process).
func NewService(cfg Config, puller puller.Service, logger *slog.Logger) LocalService

// NewClient creates a remote Indexer client (gRPC).
func NewClient(address string, logger *slog.Logger) (Service, error)

// NewGRPCServer creates a gRPC server adapter for the Indexer.
func NewGRPCServer(svc LocalService) indexerv1.IndexerServiceServer
```

## Registration with Unified Server

```go
// In services/manager_init.go
func (m *Manager) initIndexer() error {
    // Create local service
    svc := indexer.NewService(m.cfg.Indexer, m.puller, m.logger)

    // Create gRPC server adapter
    grpcServer := indexer.NewGRPCServer(svc)

    // Register with unified gRPC server
    server.Default().RegisterGRPCService(
        &indexerv1.IndexerService_ServiceDesc,
        grpcServer,
    )

    // Start local service
    return svc.Start(m.ctx)
}
```

## Configuration

Indexer registers with the unified gRPC server (see [Server Architecture](../01.architecture.md)) and does not require a separate port configuration. The gRPC service is automatically available when the unified server starts.

**Notes**:
- In standalone mode, Query Engine uses `LocalService` directly (no gRPC overhead)
- In distributed mode, Query Engine connects to the unified gRPC server address

## Error Handling

| gRPC Status Code | Condition |
|------------------|-----------|
| `OK` | Success |
| `NOT_FOUND` | No matching template for collection |
| `UNAVAILABLE` | Shard is rebuilding or failed |
| `INVALID_ARGUMENT` | Invalid filter operator or direction |
| `INTERNAL` | Unexpected error |

## Observability

- **Metrics**: `indexer_search_requests_total`, `indexer_search_latency_seconds`, `indexer_grpc_errors_total`
- **Logs**: RPC request/response logging via gRPC interceptors
- **Tracing**: OpenTelemetry context propagation
