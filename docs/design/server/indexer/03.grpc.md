# Indexer gRPC Service

Date: January 10, 2026
Status: Draft
Scope: gRPC service interface for distributed deployments.

> For architecture overview, see [Indexer Architecture](01.architecture.md).
> For implementation details, see [Index Implementation](02.index.md).

## Overview

Indexer exposes a gRPC service for distributed deployments where Query Engine runs in a separate process. In standalone mode, Query Engine calls Indexer directly via the `LocalService` interface without gRPC overhead.

**Declarative Index Management**: Index management follows a declarative model inspired by Kubernetes reconciliation:
- **Desired State** comes from `templates.yaml` (loaded via `Reload`)
- **Actual State** is the in-memory indexes
- **Reconciler** computes diff and executes create/delete/rebuild operations automatically

## Deployment Modes

| Mode | Indexer Location | Query Engine Calls |
|------|------------------|-------------------|
| Standalone | Same process as Query Engine | Direct `LocalService` interface call |
| Distributed | Separate process | gRPC `IndexerService` RPC |

### Architecture Diagram

```
Standalone Mode:
┌─────────────────────────────────────────┐
│              Single Process              │
│  ┌──────────────┐   ┌────────────────┐  │
│  │ Query Engine │──>│ Indexer        │  │
│  │              │   │ (LocalService) │  │
│  └──────────────┘   └────────────────┘  │
└─────────────────────────────────────────┘

Distributed Mode:
┌──────────────────┐         ┌──────────────────┐
│   Query Engine   │  gRPC   │     Indexer      │
│                  │────────>│  (gRPC Server)   │
└──────────────────┘         └──────────────────┘
```

## Declarative Management Model

```
                     ┌─────────────────┐
                     │ templates.yaml  │
                     └────────┬────────┘
                              │
                        Reload() ←───── Manual trigger / Startup
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     Index Reconciler                         │
│                                                              │
│  ┌─────────────────┐         ┌─────────────────┐            │
│  │  Desired State  │         │  Actual State   │            │
│  │  (from config)  │   vs    │  (in-memory)    │            │
│  └────────┬────────┘         └────────┬────────┘            │
│           │                           │                      │
│           └───────────┬───────────────┘                      │
│                       ▼                                      │
│               ┌──────────────┐                               │
│               │  Compute Diff │                              │
│               └──────┬───────┘                               │
│                      │                                       │
│         ┌────────────┼────────────┐                          │
│         ▼            ▼            ▼                          │
│     ToCreate     ToDelete     ToRebuild                      │
│     (新模板)     (已删模板)   (数据损坏)                      │
└─────────────────────────────────────────────────────────────┘
```

### Diff Calculation Rules

| Desired | Actual | Operation |
|---------|--------|-----------|
| Present | Absent | **Create** - Create index, trigger rebuild |
| Absent | Present | **Delete** - Remove index data |
| Present | Healthy | No action |
| Present | Failed | **Rebuild** - Rebuild index |
| Present | Rebuilding | Wait for completion |

### Common Operations

| Scenario | Action |
|----------|--------|
| Add new index | Edit yaml → `Reload()` → Reconciler auto-creates |
| Remove index | Edit yaml → `Reload()` → Reconciler auto-deletes |
| Rebuild index | `InvalidateIndex(db, pattern, tmpl)` → Reconciler auto-rebuilds |
| View status | `GetState()` → Returns desired/actual/pending |

## Proto Definition

```proto
syntax = "proto3";
package syntrix.indexer.v1;

option go_package = "github.com/syntrixbase/syntrix/api/gen/indexer/v1;indexerv1";

// Index management follows a declarative model:
// - Desired state comes from templates.yaml (loaded via Reload)
// - Actual state is the in-memory indexes
// - Reconciler computes diff and executes create/delete/rebuild operations
service IndexerService {
  // --- Query Interface ---

  // Search executes an index query and returns ordered document references.
  rpc Search(SearchRequest) returns (SearchResponse);

  // Health returns the current health status of the indexer.
  rpc Health(HealthRequest) returns (HealthResponse);

  // --- Declarative Index Management ---

  // GetState returns the complete index state including desired, actual, and pending operations.
  rpc GetState(GetStateRequest) returns (IndexerState);

  // Reload reloads index templates from the configuration file (templates.yaml).
  rpc Reload(ReloadRequest) returns (ReloadResponse);

  // InvalidateIndex marks a index as needing rebuild.
  rpc InvalidateIndex(InvalidateIndexRequest) returns (InvalidateIndexResponse);
}

// --- Query Messages ---

message SearchRequest {
  string database = 1;
  string collection = 2;            // Concrete path: "users/alice/chats"
  repeated Filter filters = 3;      // Equality/range filters
  repeated OrderByField order_by = 4;
  int32 limit = 5;
  string start_after = 6;           // Base64 encoded cursor (OrderKey)
}

message Filter {
  string field = 1;
  string op = 2;                    // "eq", "gt", "lt", "gte", "lte"
  bytes value = 3;                  // JSON encoded value
}

message OrderByField {
  string field = 1;
  string direction = 2;             // "asc" or "desc"
}

message SearchResponse {
  repeated DocRef docs = 1;
}

message DocRef {
  string id = 1;
  string order_key = 2;             // Base64 encoded for cursor use
}

// --- Health Messages ---

message HealthRequest {}

message HealthResponse {
  string status = 1;                // "healthy", "degraded", "unhealthy"
  map<string, IndexHealth> indexes = 2;
}

message IndexHealth {
  string state = 1;                 // "healthy", "rebuilding", "failed"
  int64 doc_count = 2;
}

// --- Declarative Index Management Messages ---

message GetStateRequest {
  string database = 1;              // Optional: filter by database
  string pattern = 2;               // Optional: filter by pattern
}

message IndexerState {
  repeated IndexSpec desired = 1;   // Desired indexes from configuration
  repeated IndexInfo actual = 2;    // Actual indexes in memory
  repeated PendingOperation pending_ops = 3;  // Pending reconcile operations
}

message IndexSpec {
  string pattern = 1;               // e.g., "users/*/chats"
  string template_id = 2;           // e.g., "timestamp:desc"
  repeated IndexField fields = 3;   // Indexed fields
}

message IndexField {
  string field = 1;
  string direction = 2;             // "asc" or "desc"
}

message IndexInfo {
  string database = 1;
  string pattern = 2;               // e.g., "users/*/chats"
  string template_id = 3;           // e.g., "timestamp:desc"
  string state = 4;                 // "healthy", "rebuilding", "failed"
  int64 doc_count = 5;
}

message PendingOperation {
  string op_type = 1;               // "create", "delete", "rebuild"
  string database = 2;
  string pattern = 3;
  string template_id = 4;
  string status = 5;                // "pending", "running"
  int32 progress = 6;               // 0-100 for rebuild
  string error = 7;                 // Error message if failed
  int64 started_at = 8;             // Unix timestamp (0 if pending)
}

message ReloadRequest {}

message ReloadResponse {
  int32 templates_loaded = 1;
  repeated string errors = 2;       // Loading errors if any
}

message InvalidateIndexRequest {
  string database = 1;
  string pattern = 2;               // e.g., "users/*/chats"
  string template_id = 3;           // Optional: specific template
}

message InvalidateIndexResponse {
  int32 indexes_invalidated = 1;
}
```

## Package Layout

```
internal/indexer/
├── interface.go           - Service/LocalService interfaces
├── service.go             - Main service implementation
├── internal/
│   ├── grpc/              - gRPC server adapter
│   │   └── server.go      - Implements IndexerServiceServer
│   ├── client/            - gRPC client (implements Service interface)
│   │   └── client.go
│   ├── reconciler/        - Declarative state reconciler
│   │   └── reconciler.go
│   ├── manager/           - Index manager
│   ├── index/             - Per-collection index index
│   ├── encoding/          - OrderKey encoding/decoding
│   ├── template/          - Index template loading
│   └── rebuild/           - Rebuild orchestration
└── config/                - Indexer configuration
```

## Service Interface (Go)

```go
// Service is the public interface for Indexer (both local and remote).
type Service interface {
    // Query - returns document references or error
    // Errors: ErrNoMatchingIndex, ErrIndexNotReady, ErrIndexRebuilding, ErrInvalidPlan
    Search(ctx context.Context, database string, plan Plan) ([]DocRef, error)
    Health(ctx context.Context) (Health, error)
    Stats(ctx context.Context) (Stats, error)
}

// LocalService extends Service with lifecycle and event handling methods.
// Only available for in-process usage.
type LocalService interface {
    Service

    // Start starts the indexer (loads templates, starts reconciler, subscribes to Puller).
    Start(ctx context.Context) error

    // Stop gracefully stops the indexer.
    Stop(ctx context.Context) error

    // ApplyEvent applies a change event to update indexes.
    ApplyEvent(ctx context.Context, evt *ChangeEvent) error

    // Manager returns the underlying index manager for advanced operations.
    Manager() *manager.Manager
}

// Indexer errors - returned from Search when index cannot serve the query
var (
    ErrNoMatchingIndex = errors.New("no matching index for query")
    ErrIndexNotReady   = errors.New("index not ready")
    ErrIndexRebuilding = errors.New("index is rebuilding")
    ErrInvalidPlan     = errors.New("invalid query plan")
)

// IndexerState contains the complete index state.
type IndexerState struct {
    Desired    []IndexSpec        // From configuration
    Actual     []IndexInfo        // In memory
    PendingOps []PendingOperation // Reconciler queue
}

// IndexSpec describes a desired index from configuration.
type IndexSpec struct {
    Pattern    string
    TemplateID string
    Fields     []IndexField
}

// IndexInfo describes an actual index in memory.
type IndexInfo struct {
    Database   string
    Pattern    string
    TemplateID string
    State      string  // "healthy", "rebuilding", "failed"
    DocCount   int64
}

// PendingOperation describes a reconciler operation.
type PendingOperation struct {
    OpType     string  // "create", "delete", "rebuild"
    Database   string
    Pattern    string
    TemplateID string
    Status     string  // "pending", "running"
    Progress   int     // 0-100
    Error      string
    StartedAt  time.Time
}

// ReloadResult contains the result of a reload operation.
type ReloadResult struct {
    TemplatesLoaded int
    Errors          []string
}
```

## Reconciler Logic

```go
func (r *Reconciler) Run(ctx context.Context) {
    ticker := time.NewTicker(5 * time.Second)
    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            r.reconcile()
        case <-r.triggerCh:  // Manual trigger (e.g., after Reload)
            r.reconcile()
        }
    }
}

func (r *Reconciler) reconcile() {
    desired := r.templateLoader.GetDesired()
    actual := r.manager.ListIndexes()

    ops := computeDiff(desired, actual)

    for _, op := range ops {
        switch op.Type {
        case OpCreate:
            r.createAndRebuild(op.Database, op.Pattern, op.TemplateID)
        case OpDelete:
            r.deleteIndex(op.Database, op.Pattern, op.TemplateID)
        case OpRebuild:
            r.rebuild(op.Database, op.Pattern, op.TemplateID)
        }
    }
}

func computeDiff(desired []IndexSpec, actual []IndexInfo) []Operation {
    var ops []Operation

    // Build lookup maps
    actualMap := make(map[string]IndexInfo)
    for _, a := range actual {
        key := fmt.Sprintf("%s|%s|%s", a.Database, a.Pattern, a.TemplateID)
        actualMap[key] = a
    }

    desiredSet := make(map[string]bool)
    for _, d := range desired {
        // For each database that has data matching this pattern
        for _, db := range r.getDatabasesWithPattern(d.Pattern) {
            key := fmt.Sprintf("%s|%s|%s", db, d.Pattern, d.TemplateID)
            desiredSet[key] = true

            if a, exists := actualMap[key]; !exists {
                ops = append(ops, Operation{Type: OpCreate, ...})
            } else if a.State == "failed" {
                ops = append(ops, Operation{Type: OpRebuild, ...})
            }
        }
    }

    // Find indexes to delete (in actual but not in desired)
    for key, a := range actualMap {
        if !desiredSet[key] {
            ops = append(ops, Operation{Type: OpDelete, ...})
        }
    }

    return ops
}
```

## Query Engine Integration

```go
// Query Engine pseudocode
func (q *QueryEngine) ExecuteQuery(ctx context.Context, database string, query Query) ([]Document, error) {
    // Build plan from query
    plan := indexer.Plan{
        Collection: query.Collection,
        Filters:    convertFilters(query.Where),
        OrderBy:    convertOrderBy(query.OrderBy),
        Limit:      query.Limit,
        StartAfter: query.Cursor,
    }

    // Call Indexer (local or remote via same interface)
    // Errors indicate index issues - no fallback, Indexer is required
    docs, err := q.indexer.Search(ctx, database, plan)
    if err != nil {
        return nil, err  // ErrNoMatchingIndex, ErrIndexRebuilding, etc.
    }

    // Batch fetch documents by ID from storage
    paths := make([]string, len(docs))
    for i, doc := range docs {
        paths[i] = query.Collection + "/" + doc.ID
    }
    return q.storage.GetMany(ctx, database, paths)
}
```

## Factory Functions

```go
// NewService creates a local Indexer service (in-process).
func NewService(cfg Config, puller puller.Service, logger *slog.Logger) LocalService

// NewClient creates a remote Indexer client (gRPC).
func NewClient(address string, logger *slog.Logger) (Service, error)

// NewGRPCServer creates a gRPC server adapter for the Indexer.
func NewGRPCServer(svc LocalService) indexerv1.IndexerServiceServer
```

## Registration with Unified Server

```go
// In services/manager_init.go
func (m *Manager) initIndexer() error {
    // Create local service
    svc := indexer.NewService(m.cfg.Indexer, m.puller, m.logger)

    // Create gRPC server adapter
    grpcServer := indexer.NewGRPCServer(svc)

    // Register with unified gRPC server
    server.Default().RegisterGRPCService(
        &indexerv1.IndexerService_ServiceDesc,
        grpcServer,
    )

    // Start local service (includes reconciler)
    return svc.Start(m.ctx)
}
```

## Configuration

Indexer registers with the unified gRPC server (see [Server Architecture](../01.architecture.md)) and does not require a separate port configuration. The gRPC service is automatically available when the unified server starts.

**Notes**:
- In standalone mode, Query Engine uses `LocalService` directly (no gRPC overhead)
- In distributed mode, Query Engine connects to the unified gRPC server address

## Error Handling

| gRPC Status Code | Condition |
|------------------|-----------|
| `OK` | Success |
| `NOT_FOUND` | No matching template for collection |
| `UNAVAILABLE` | Index is rebuilding or failed |
| `INVALID_ARGUMENT` | Invalid filter operator or direction |
| `INTERNAL` | Unexpected error |

## Observability

- **Metrics**: `indexer_search_requests_total`, `indexer_search_latency_seconds`, `indexer_reconcile_ops_total`
- **Logs**: Reconciler operations, template reload, index state changes
- **Tracing**: OpenTelemetry context propagation
