# Index Storage Design

Date: 2026-01-13
Status: Draft
Scope: Storage abstraction for indexes (memory and persistent)

## Motivation

Indexes need a unified storage abstraction that supports:

1. **Development/Testing** - Fast in-memory storage, no external dependencies
2. **Production** - Persistent storage that survives restarts

| Problem (memory-only) | Impact |
|---------|--------|
| Service restart | All indexes lost, full rebuild required |
| Memory growth | Large datasets cause OOM |
| Startup time | Rebuild from storage scan + event replay |
| Buffer overflow | If Puller buffer overflows during downtime, full rebuild required |

## Goals

1. **Unified interface** - Same `Store` interface for both memory and persistent backends
2. **Durability (pebble mode)** - Indexes survive service restarts
3. **Fast recovery (pebble mode)** - Resume from last checkpoint, no full rebuild
4. **Bounded memory (pebble mode)** - Configurable cache size, not proportional to data
5. **Zero config (memory mode)** - Works out of the box for dev/test

## Non-Goals (v1)

- Distributed/sharded indexes
- Multi-node replication
- Online schema changes

---

## Package Structure

```
internal/indexer/internal/
  mem_store/              # Memory storage implementation
    store.go              # MemoryStore (BTree + byID map)
    store_test.go
  persist_store/          # Persistent storage implementation
    store.go              # PersistStore (PebbleDB)
    keys.go               # Key encoding helpers
    store_test.go
    keys_test.go
  manager/
    store.go              # Store interface (defined by consumer)
    manager.go
    ...
```

---

## Store Interface

Defined in `manager` package (the consumer):

```go
// internal/indexer/internal/manager/store.go

type Store interface {
    // Index operations
    Upsert(db, pattern, tmplID, docID string, orderKey []byte) error
    Delete(db, pattern, tmplID, docID string) error
    Get(db, pattern, tmplID, docID string) ([]byte, bool)
    Search(db, pattern, tmplID string, opts SearchOptions) ([]DocRef, error)

    // Index management
    DeleteIndex(db, pattern, tmplID string) error
    SetState(db, pattern, tmplID string, state IndexState) error
    GetState(db, pattern, tmplID string) (IndexState, error)

    // Checkpoint
    SaveProgress(eventID string) error
    LoadProgress() (string, error)

    // Lifecycle
    Flush() error
    Close() error
}

type SearchOptions struct {
    Lower      []byte  // Lower bound (inclusive)
    Upper      []byte  // Upper bound (exclusive)
    StartAfter []byte  // Cursor for pagination (exclusive)
    Limit      int     // Max results to return
}

type IndexState string

const (
    IndexStateHealthy    IndexState = "healthy"
    IndexStateRebuilding IndexState = "rebuilding"
    IndexStateFailed     IndexState = "failed"
)
```

---

## Storage Mode Selection

Users choose via configuration:

```yaml
indexer:
  storage_mode: "memory"      # or "pebble"

  # Pebble mode settings (only when storage_mode: pebble)
  store:
    path: "data/indexer/indexes.db"
    batch_size: 100
    batch_interval: 100ms
    queue_size: 10000
    block_cache_size: 67108864
```

### Mode Comparison

| Aspect | Memory | Pebble |
|--------|--------|--------|
| Startup | Rebuild from storage | Load from disk |
| Restart recovery | Full rebuild | Resume from checkpoint |
| Memory usage | Proportional to data | Bounded by cache |
| Write latency | ~1μs | ~10-50μs (async) |
| Read latency | ~10μs | ~50-100μs (cached) |
| Use case | Dev/test, small datasets | Production, large datasets |

### Factory Function

```go
// internal/indexer/service.go

func newStore(cfg Config) (manager.Store, error) {
    switch cfg.StorageMode {
    case "memory", "":
        return mem_store.New(), nil
    case "pebble":
        return persist_store.New(cfg.Store)
    default:
        return nil, fmt.Errorf("unknown storage mode: %s", cfg.StorageMode)
    }
}
```

---

## MemoryStore Implementation

`mem_store.MemoryStore` uses in-memory data structures:

- **BTree** for ordered iteration (same semantics as PebbleDB)
- **byID map** for O(1) document lookups
- **No persistence** - data lost on restart

```go
type MemoryStore struct {
    mu       sync.RWMutex
    indexes  map[string]*memoryIndex  // key: "{db}|{hash}"
    progress string
}

type memoryIndex struct {
    tree  *btree.BTreeG[btreeItem]
    byID  map[string][]byte  // docID -> orderKey
    state IndexState
}
```

### Operations

All operations are synchronous and in-memory:

- `Upsert` - O(log n) BTree insert + O(1) map update
- `Delete` - O(log n) BTree delete + O(1) map delete
- `Get` - O(1) map lookup
- `Search` - O(log n + k) BTree range scan
- `Flush/Close` - No-op

---

## PersistStore Implementation

`persist_store.PersistStore` uses PebbleDB with async batching:

### Storage Layout

```
data/indexer/
  └── indexes.db/          # Single PebbleDB instance
        ├── MANIFEST-*
        ├── OPTIONS-*
        ├── *.sst
        └── WAL/
```

### Key Design

Compact index identifier using xxHash64:

```
hash = hex(xxHash64(pattern + "|" + tmplID))  → 16 chars
```

**Key structure:**

```
# Index data (ordered by OrderKey for range scans)
idx/{db}/{hash}/{orderKey}              →  {docID}

# Reverse index (for Upsert: find old key to delete)
rev/{db}/{hash}/{docID}                 →  {orderKey}

# Hash mapping (for debugging/introspection)
map/{db}/{hash}                         →  {pattern}|{tmplID}

# Index metadata
meta/state/{db}/{hash}                  →  "healthy"|"rebuilding"|"failed"

# Global checkpoint
meta/progress                           →  {lastEventID}
```

### Async Batching

Similar to Puller buffer pattern:

```go
type PersistStore struct {
    db        *pebble.DB

    mu        sync.RWMutex
    pending   map[string]*pendingOp  // key: "{db}|{hash}|{docID}"
    flushing  map[string]*pendingOp

    notifyCh  chan struct{}
    closeCh   chan struct{}
    batcherWG sync.WaitGroup

    cfg       StoreConfig
}

type pendingOp struct {
    db       string
    hash     string  // hex(xxHash64(pattern + "|" + tmplID))
    docID    string
    orderKey []byte  // nil = delete
}
```

### Write Flow

```
Upsert/Delete()
    │
    ▼
pending map (in memory)
    │
    ├──► notifyCh signal
    │
    ▼
batcher goroutine
    │
    ├──► BatchSize reached OR
    ├──► BatchInterval elapsed OR
    └──► Close() called
            │
            ▼
        swap pending → flushing
            │
            ▼
        build pebble.Batch
            │
            ▼
        batch.Commit(pebble.Sync)
            │
            ▼
        clear flushing
```

### Search Consistency

Search must see both persisted and pending data:

```go
func (s *PersistStore) Search(...) ([]DocRef, error) {
    // 1. Snapshot pending ops
    s.mu.RLock()
    memOps := make(map[string]*pendingOp)
    for k, v := range s.flushing {
        memOps[k] = v  // flushing first (older)
    }
    for k, v := range s.pending {
        memOps[k] = v  // pending overwrites flushing (newer)
    }
    s.mu.RUnlock()

    // 2. Scan PebbleDB + merge with memOps
    // 3. Return merged results
}
```

---

## Configuration

```go
type StoreConfig struct {
    // Storage path (required for pebble mode)
    Path string `yaml:"path"`  // default: "data/indexer/indexes.db"

    // Batching
    BatchSize     int           `yaml:"batch_size"`      // default: 100
    BatchInterval time.Duration `yaml:"batch_interval"`  // default: 100ms
    QueueSize     int           `yaml:"queue_size"`      // default: 10000

    // PebbleDB tuning
    BlockCacheSize int64 `yaml:"block_cache_size"`  // default: 64MB
}
```

---

## Rebuild Integration (PersistStore only)

### Index Rebuild Flow

```
hash = hex(xxHash64(pattern + "|" + tmplID))

1. Set meta/state/{db}/{hash} = "rebuilding"
2. Delete all keys with prefix idx/{db}/{hash}/
3. Delete all keys with prefix rev/{db}/{hash}/
4. Storage scan → Upsert each document
5. Event replay from recorded position
6. Set meta/state/{db}/{hash} = "healthy"
7. Flush pending writes
```

### Startup Recovery

```
1. Open PebbleDB
2. Read meta/progress → lastEventID
3. For each index (scan meta/state/ prefix):
   - If state == "healthy": ready to serve
   - If state == "rebuilding": resume or restart rebuild
   - If state == "failed": log error, skip index
4. Subscribe to Puller from lastEventID
5. Resume normal operation
```

---

## Performance Considerations

### Expected Latency

| Operation | MemoryStore | PersistStore | Notes |
|-----------|-------------|--------------|-------|
| Upsert | ~1μs | ~10-50μs | Async batch amortizes |
| Search (cache hit) | ~10μs | ~50-100μs | Block cache helps |
| Search (cache miss) | N/A | ~1-5ms | SSD read |
| Get by ID | ~100ns | ~10-50μs | Usually cached |

### Memory Usage

| Component | MemoryStore | PersistStore |
|-----------|-------------|--------------|
| Index data | Proportional to data | Block cache (default 64MB) |
| Pending ops | N/A | ~1KB × QueueSize |
| Iterator buffers | Minimal | ~10KB per active search |

---

## Error Handling

### MemoryStore

| Error | Handling |
|-------|----------|
| None expected | All operations are in-memory |

### PersistStore

| Error | Handling |
|-------|----------|
| PebbleDB write failure | Close store, fail all pending ops |
| Batch commit failure | Retry once, then close store |
| Corruption detected | Log, mark index failed, trigger rebuild |
| Disk full | Fail writes, continue reads |

---

## Observability

### Metrics (PersistStore)

```
indexer_store_writes_total{status="success|error"}
indexer_store_reads_total{status="success|error"}
indexer_store_batch_size_histogram
indexer_store_batch_latency_seconds
indexer_store_pending_ops_gauge
indexer_store_disk_bytes_gauge
```

### Health Check

```go
// MemoryStore
func (s *MemoryStore) Health() StoreHealth {
    return StoreHealth{Status: "ok"}
}

// PersistStore
func (s *PersistStore) Health() StoreHealth {
    return StoreHealth{
        Status:      "ok",
        DiskUsage:   s.db.Metrics().DiskSpaceUsage(),
        PendingOps:  len(s.pending),
        LastFlush:   s.lastFlushTime,
    }
}
```

---

## References

- [Puller Buffer Implementation](../../puller/01.buffer.md)
- [PebbleDB Documentation](https://github.com/cockroachdb/pebble)
- [Index Architecture](01.architecture.md)
