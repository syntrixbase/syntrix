# Query Layer Details

Date: December 26, 2025
Status: Draft
Scope: Planner/executor for `model.Query` over Data/Index.

## Why
- Centralize query planning, choosing index vs fallback, and batching fetches.
- Keep wire semantics stable (filters/order/limit/startAfter/showDeleted).

### Wire Model (recap)
```go
type Query struct {
	Collection  string  `json:"collection"`
	Filters     Filters `json:"filters"`
	OrderBy     []Order `json:"orderBy"`
	Limit       int     `json:"limit"`
	StartAfter  string  `json:"startAfter"` // cursor
	ShowDeleted bool    `json:"showDeleted"`
}

type Filter struct {
	Field string      `json:"field"`
	Op    string      `json:"op"`
	Value interface{} `json:"value"`
}

type Order struct {
	Field     string `json:"field"`
	Direction string `json:"direction"` // "asc" or "desc"
}
```
- Reserved fields (`id`, `collection`, `version`, `updatedAt`, `createdAt`, `deleted`) are added/stripped at the service layer; storage keeps internal representation.
- Tenant is not part of `model.Query`; it is carried separately on every `Service` call and HTTP request body. Empty tenant resolves to `model.DefaultTenantID` for dev/test only.
- Translation example (Mongo): `collection` → parent path, filters map to `data.<field>`, `orderBy` maps to sort; used for intuition only (engine stays backend-agnostic).
- Example (wire → Mongo intuition only):
```json
{
	"collection": "users/alice/posts",
	"filters": [
		{"field": "status", "op": "==", "value": "published"},
		{"field": "views",  "op": ">",  "value": 100}
	],
	"orderBy": [{"field": "views", "direction": "desc"}],
	"limit": 10
}
```
maps to `db.documents.find({ parent: "users/alice/posts", "data.status": "published", "data.views": { "$gt": 100 } }).sort({ "data.views": -1 }).limit(10)`.

## Responsibilities
- Compile `model.Query` into index plan; decide fallback when index unavailable.
- Execute index-first: fetch DocRefs, batch-get from Data, merge metadata, enforce ordering/limit/startAfter.
- Fallback scan: bounded prefix scan, in-memory order with guardrails, emit metrics for index miss.
- Enforce tenant scoping: plan, fetch, watch, and replication ops must never cross tenants; all cursors and checkpoints are tenant-scoped.
- Support replication/watch consumers using the same execution primitives.
- Share filter evaluation across query execution and watch streams: push down indexable predicates; apply remaining predicates via a common evaluator in-memory for both query results and watch events. Realtime watch can be hosted outside the core HTTP/query worker, calling into this evaluator to reduce load while keeping semantics aligned.

## Interfaces (sketch)
- Public via `Service` methods:
	- `GetDocument`, `CreateDocument`, `ReplaceDocument`, `PatchDocument`, `DeleteDocument`
	- `ExecuteQuery(ctx, model.Query) ([]Document, error)`
	- `Watch(ctx, collection string, filters Filters, startAfter string) (<-chan Event, error)` — streaming may be implemented in a realtime tier that reuses the shared filter evaluator; core query engine focuses on planning/execution.
	- `Pull/Push` (replication)
- Internal helpers: `executeWithIndex(ctx, q) ([]Document, error)`, `fallbackScan(ctx, q)`, `batchFetch(ctx, refs)`, shared `evaluateFilters(items, filters)` used by query post-filter and watch.
- Config: batch size for Data fetch, max fallback docs (`fallback_docs_max`, default 500).

### Defaults / Execution Notes
- Data batch size: default 128 doc refs per fetch; tunable.
- Index-first: if index is missing/unready/version-mismatch, allow bounded fallback only when the total documents scanned/fetched stay under `fallback_docs_max` (config; default 500 docs). If the cap would be exceeded or fallback is disabled, return `IndexNotReady` instead of stressing storage.
- Missing index/unready: engine returns `IndexNotReady`; planner may emit an index suggestion/hint (policy TBD) but does not auto-create.
- Cursor/startAfter: encode using Index OrderKey and prefix with an encoding-version byte. A version bump does **not** mean a new logical index; it signals an encoding change that requires the existing index to rebuild and emit the new OrderKeys. If a cursor version mismatches the active index encoding, return `IndexNotReady` so clients retry after rebuild.
- Pushdown: filters on indexed fields are pushed; non-indexable filters are post-filtered only when index provides candidates. If no usable index and fallback is disabled or would exceed the doc cap, return `IndexNotReady` instead of scanning.

#### Cursor/OrderKey Versioning
- Include version byte; on mismatch return `IndexNotReady` (no scan fallback) to avoid storage pressure; client retries when index is rebuilt.

#### Policy Values (initial)
- Data batch size: 128.
- Fallback doc cap: 500 documents default via config (`fallback_docs_max`); if exceeded or disabled, return `IndexNotReady` instead of scanning.

## Dependencies
- Index, Data; metrics/logging; config knobs; clock.

## Testing (testify)
- Index-hit path: ordering, limits, startAfter, showDeleted.
- Fallback path: bounded results, ordering correctness, pagination cursors, abort when `fallback_docs_max` is reached and return `IndexNotReady`.
- Mixed scenarios: index gap triggers rebuild; ensure fallback still respects semantics.

## Open Points
- Cursor encoding for startAfter across index/fallback parity (align with Index OrderKey; stable serialization).
- Pushdown vs post-filter: when index lacks field or operator, define which filters are applied post-fetch and how limits are preserved.
- Index suggestion surface (planner hints) and how/if to surface recommended indexes when missing.
- Whether to expose cursor as opaque string only or allow structured form; must stay stable across backends if exposed.
- Watch reuse: real-time watch streams should reuse the shared filter evaluator (post-filter) rather than a separate implementation; no index planning in watch path, just filter events and stream out.
