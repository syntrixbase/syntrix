# Data Layer Details

Date: December 26, 2025
Status: Draft
Scope: Data adapters over `storage.DocumentStore` for query engine.

## Why
- Keep storage as single source of truth with CAS/version/tombstone semantics.
- Provide a uniform, testable surface for Query/Index without leaking backend specifics.
- Emit reliable change events to drive index maintenance.

## Responsibilities
- CRUD/Patch/Delete with filters (CAS) and protected-field stripping/flattening.
- Prefix/batch reads to support query fallback and index rebuild iterators.
- Change stream emission per collection with ordering guarantees.
- Backpressure to protect storage during scans/rebuilds.

## Interfaces (sketch)
- `Get(ctx, fullpath) (Document, error)`
- `BatchGet(ctx, fullpaths []string) ([]Document, error)`
- `ScanPrefix(ctx, collection string, startAfter string, limit int) ([]Document, string, error)` // returns next cursor
- `Create/Update/Patch/Delete(ctx, doc, filters) error` // CAS via filters
- `Changes(ctx, collection string) (<-chan Event, error)` // ordered per collection
- `type Event struct { Fullpath, Collection string; Version int64; Deleted bool; UpdatedAt int64; CreatedAt int64; DataHash string; Payload map[string]any optional }

### Defaults / Execution Notes
- Hash: xxhash64 of canonical JSON for `DataHash`; payload omitted by default, capped (e.g., 32KB) when included for replay/testing only.
- Scan: default batch 500 docs; per-collection rebuild QPS cap (e.g., 5k ops/s) and max concurrent rebuilds (e.g., 2 global) with a queue. Fallback doc counting includes tombstones and filtered-out rows so Query can enforce `fallback_docs_max` consistently.
- Change stream: per-collection ordering by version/ts; detect gaps and signal rebuild; channel buffers small (e.g., 1-10) to avoid staleness; drop to rebuild on sustained overflow.
- Protected fields: strip reserved fields on writes; flatten on reads to user shape with metadata (id/collection/version/createdAt/updatedAt/deleted).
- Hot/Warm/Cold: collection metadata tracks `state`, `lastAccess`, `indexState`; warm allows on-demand rebuild; cold denies/queues scans until restore.

#### Policy Values (initial)
- DataHash: xxhash64; payload cap 32KB when enabled.
- Scan batch: 500 docs; rebuild QPS cap: 5k ops/s per collection; max concurrent rebuilds: 2 global.
- Change stream buffer: 10; overflow triggers rebuild flag.
- Hot/Warm/Cold: warm → allow on-demand rebuild with throttle; cold → interface hook reserved (not implemented yet), default behavior unchanged; future could deny/queue and require restore.

## Dependencies
- `storage.DocumentStore`; clock; hash util.

## Testing (testify)
- CAS/conflict paths, tombstone propagation.
- Prefix scan pagination and ordering.
- Change stream ordering/idempotency, gap detection triggers.
- Protected fields strip/flatten correctness.

## Open Points
- Hash function choice (e.g., xxhash64 for speed vs sha256 for stability) and payload inclusion policy (hash-only vs payload for replay; cap payload size).
- Scan limits and backpressure defaults for rebuild (batch size, QPS/IO caps, max concurrent rebuilds).
- Hot/Warm/Cold integration: collection metadata (state, lastAccess, indexState), how scans/rebuild behave for warm (on-demand rebuild) and cold (deny/queue + restore pipeline).
