# Query Engine Refactor Requirements

Date: December 26, 2025
Status: Draft
Scope: Encapsulate query surfaces, split internals into Data/Index/Query layers, and align with existing HTTP/replication behaviors.

## Goals (Why)
- Reduce public surface to the `Service` interface plus factories; hide Engine/Server/Client structs inside internal packages.
- Separate concerns for data access, index maintenance, and query execution to unblock scalability (hot/warm/cold tiers, rebuilds) and align with `storage_design` thoughts.
- Keep HTTP/replication/watch behaviors stable while enabling pluggable Data/Index backends.
- Improve testability via clear contracts (interface-level tests) and black-box HTTP tests.
 - Honor multi-tenant isolation across the stack (service, HTTP, query, replication, watch) with explicit tenant parameters and safe defaults.

## Functional Requirements (How)
- Public API: expose `Service`, `NewService(storage.DocumentStore, cspURL string) Service`, `NewClient(baseURL string) Service`, and `NewHTTPHandler(s Service) http.Handler`; no other exported structs.
- Multi-tenant surface: every `Service` method accepts an explicit `tenant string`; HTTP/replication/watch requests carry `tenant` in the body; empty tenants resolve to `model.DefaultTenantID` only for backward compatibility in dev/test.
- Tenant isolation: Data, Index, Query, Watch, and Replication must not read/write across tenants; change events, checkpoints, and index partitions include the tenant id.
- Data layer: wrap `storage.DocumentStore`; provide point/batch get, prefix scan, CAS-aware create/update/patch/delete, tombstones, and change stream for index updates; remain the source of truth.
- Index layer: consume Data change stream; support prefix/ordered scans for query plans; allow rebuild via Data prefix scan; index storage is pluggable (start with minimal in-process stub, plan for RocksDB/external KV).
- Query layer: compile/execute `model.Query`; prefer index-first then batch fetch via Data; allow bounded Data fallback when index is unavailable only if scanned/fetched documents stay under a config cap (default 500 docs); respect filters/order/limit/startAfter/showDeleted semantics.
- Replication: preserve existing pull/push semantics (version/CAS, deleted flag, checkpoint ordering) and HTTP routes.
- Watch: keep `/internal/v1/watch` streaming behavior; allow backend choice (CSP call or local stream) behind interfaces.
- Observability: basic metrics/logging hooks at Data/Index/Query boundaries (latency, hits/misses, rebuild stats); at minimum keep current logging, design for extension.

## Non-Goals / Out of Scope
- Changing query DSL or adding new operators/aggregations beyond current `model.Query`.
- Implementing new storage backends now (Mongo stays primary); only adapter seams are introduced.
- Global secondary index planner or cost-based optimizer in this iteration.
- Multi-region replication changes.

## Constraints
- Preserve existing HTTP paths and JSON shapes to avoid SDK breakage.
- Validate tenant input on the edge; default tenant fallback is temporary and should be removable once callers send explicit tenant.
- Avoid new external dependencies unless approved; reuse testify for tests.
- Follow package visibility rules: implementations reside under `internal/query/internal/...`.
- Keep hot path performance at least on par with current behavior; fallback scans must be bounded (pagination/limits).

## Testing & Quality
- Unit tests with `github.com/stretchr/testify`: interface contract tests (Service), HTTP handler black-box tests (`httptest`), client/handler parity tests, replication and watch behaviors.
- Ensure change-stream to index pipeline has coverage for ordering, tombstones, and CAS conflicts.
- Run `make test`/`go test ./...` after refactor; add coverage for new packages.

## Open Questions
- Index capability scope for first cut: prefix + single-field range vs early support for composite sort keys.
- Rebuild triggers and throttling: when to rebuild (on-demand vs scheduled), how to rate-limit scans on large collections.
- Hot/warm/cold interplay: policies for dropping indexes on cold collections and on-demand rebuild SLA.
- CSP watch path: consolidate remote watch vs local watch behind the same interface or keep dual paths?
