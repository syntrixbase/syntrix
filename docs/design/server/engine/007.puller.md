# Engine Integration with Puller Service

Date: December 29, 2025
Status: Updated - References Standalone Puller Service
Scope: How Query Engine consumes change events from the standalone Puller service for index updates.

**IMPORTANT**: The Puller component has been promoted to a standalone service. See [Puller Service Architecture](../server/puller/001.architecture.md) for the complete design.

This document describes how the Query Engine integrates with the Puller service for index updates.

## Architecture Overview

```
MongoDB Change Stream
    ↓
Puller Service (Standalone)
    ↓
NATS JetStream
    ↓
Query Engine Index Consumer
    ↓
Index Updates
```

## Engine's Responsibilities
- Subscribe to relevant NATS JetStream subjects from Puller
- Consume change events for index updates
- Maintain per-collection checkpoints for rebuild decisions
- Detect lag/gaps and trigger index rebuild when needed

## Integration Pattern

### Consuming from Puller via JetStream

```go
type IndexEventConsumer struct {
    js           nats.JetStreamContext
    consumerName string
    collections  []string  // Collections this engine instance cares about
}

func (c *IndexEventConsumer) Subscribe(ctx context.Context) error {
    // Subscribe to Puller events for specific collections
    // Subject pattern: puller.events.{collection}.{partition}

    for _, collection := range c.collections {
        subject := fmt.Sprintf("puller.events.%s.>", collection)

        _, err := c.js.Subscribe(subject, c.handleIndexUpdate,
            nats.ManualAck(),
            nats.Durable(c.consumerName),
            nats.DeliverAll())

        if err != nil {
            return err
        }
    }
    return nil
}

func (c *IndexEventConsumer) handleIndexUpdate(msg *nats.Msg) {
    // Decode event from Puller
    var evt PullerEvent
    json.Unmarshal(msg.Data, &evt)

    // Apply to index
    c.index.Upsert(evt)

    // Ack after successful application
    msg.Ack()
}
```

### Event Schema from Puller

Events from Puller follow this schema (defined in Puller service):
- `tenant`: Tenant ID
- `collection`: Collection name
- `documentKey`: Document ID
- `operationType`: insert/update/replace/delete
- `fullDocument`: Complete document (for insert/update/replace)
- `updateDescription`: Delta for updates
- `clusterTime`: MongoDB cluster timestamp
- `txnNumber`: Transaction number (if in transaction)

## Engine Consumer Configuration

```yaml
engine:
  index:
    puller:
      # NATS connection
      nats_urls:
        - nats://localhost:4222

      # Consumer settings
      consumer_name: "engine-index-{instance-id}"
      ack_wait: 5s
      max_ack_pending: 100

      # Collections to subscribe to
      collections:
        - users
        - orders
        - products

      # Checkpoint settings (local to Engine)
      checkpoint_store: etcd  # or mongo
      checkpoint_interval: 1s

      # Rebuild triggers
      lag_thresholds:
        soft_warn: 30s       # Log warning
        hard_rebuild: 2m    # Trigger index rebuild
```

## Index Update Semantics

### At-Least-Once Delivery
- Puller publishes events to JetStream with persistence
- Engine consumes with manual acknowledgment
- Events may be delivered multiple times (on retry, reconnect, etc.)
- **Engine index apply must be idempotent**

### Idempotency Requirements

```go
func (idx *Index) Upsert(evt PullerEvent) error {
    // Check if this event is older than current indexed version
    current := idx.Get(evt.DocumentKey)
    if current != nil && current.Version >= evt.ClusterTime {
        // Skip older event
        return nil
    }

    // Apply update
    return idx.upsertDocument(evt)
}
```

### Ordering Guarantees
- Puller guarantees per-partition ordering (via subject partitioning)
- Engine consumer should subscribe with single consumer per partition
- Multiple Engine instances can consume different partitions for scalability

## Lag Detection and Rebuild Triggers

### Monitoring Lag

```go
type LagMonitor struct {
    checkpointStore CheckpointStore
    jetstream       nats.JetStreamContext
}

func (m *LagMonitor) CheckLag(collection string) (time.Duration, error) {
    // Get Engine's last processed checkpoint
    checkpoint := m.checkpointStore.Get(collection)

    // Get latest available event from JetStream
    streamInfo := m.jetstream.StreamInfo("PULLER_EVENTS")

    // Calculate lag
    lag := calculateTimeLag(checkpoint, streamInfo.State.LastSeq)
    return lag, nil
}
```

### Rebuild Triggers

When lag exceeds thresholds:
1. **Soft Lag (30s)**: Log warning, emit metrics
2. **Hard Lag (2m)**: Trigger index rebuild from scratch

Rebuild process:
1. Stop consuming from JetStream temporarily
2. Query Engine scans MongoDB directly (via Data layer)
3. Rebuild index from current state
4. Resume JetStream consumption from latest

## Benefits of Using Standalone Puller

1. **Reduced MongoDB Load**: Single change stream connection (in Puller) instead of one per Engine instance
2. **Independent Scaling**: Puller and Engine can scale independently
3. **Shared Infrastructure**: Other services (Streamer, Trigger) also consume from same Puller
4. **Simplified Engine**: Engine no longer manages MongoDB connections or checkpoints at storage level
5. **Better Observability**: Centralized monitoring in Puller service

## Migration from Direct MongoDB Connection

For existing deployments:
1. Deploy Puller service
2. Configure Engine to subscribe to Puller's JetStream subjects
3. Trigger initial index rebuild to sync state
4. Remove direct MongoDB change stream code from Engine
5. Verify lag metrics and performance

## References

- [Puller Service Architecture](../server/puller/001.architecture.md) - Complete Puller design
- [Query Engine Index Design](003.index.md) - Index structure and operations
- [Query Engine Architecture](001.architecture.md) - Overall Engine architecture
