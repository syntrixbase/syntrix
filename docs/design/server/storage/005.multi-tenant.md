# Multi-Tenant Storage (Hybrid Strategy)

## 1. Context & Goals
- Service not yet launched; we can define multi-tenancy from day one.
- Default isolation: shared collections with strong row-level segregation via `tenant_id` (top-level field in Mongo documents).
- Allow upgrade path: select tenants can be routed to dedicated Mongo backends (schema/DB-per-tenant) while long-tail stays shared.

## 2. Requirements
- Default tenant id: `"default"` (used when no tenant is provided or for first-party traffic).
- No migration needed (no prod data).
- Tenant must be an explicit input to all storage operations; no implicit globals.
- Reads/writes/queries/watch must never cross tenants.
- Keep read/write split support; add per-tenant backend routing.

## 3. Current State (baseline)
- Storage interfaces lack tenant semantics; `_id` is a hash of `fullpath` only.
- Mongo stores filter by `_id`, `collection`, `deleted`; no `tenant_id` filter/index.
- Routers choose primary/replica only; no tenant-aware backend selection.

## 4. Design Overview (Why/How)
- Why hybrid: fast path is shared infra with low operational overhead; heavy tenants can isolate onto their own backend for blast-radius and performance.
- How: add `tenant_id` to data model and APIs; enforce filters at store/query layer; extend factory/router to map tenantâ†’backend.

## 5. Data Model Changes (Mongo)
- Add top-level `tenant_id` to all collections (documents, users, revocations).
- ID strategy: `_id` is tenant-aware using prefix format, e.g. `_id = tenant_id + ":" + hash(fullpath)` (and similarly for users/revocations). This guarantees global uniqueness and allows regex-based filtering in Change Streams (Watch) for delete events.
- Indexes:
  - Documents: `_id` as primary; store `collection_hash` (using existing hash implementation) and index `(tenant_id, collection_hash)` for scans; keep TTL on `sys_expires_at` scoped by tenant; retain the plain `collection` field for readability/debug.
  - Users: unique `(tenant_id, username)`; `_id` generated with tenant namespace (e.g. `tenant_id + ":" + hash(user_id_source)`) to avoid cross-tenant collisions; `(tenant_id, username)` enforces per-tenant uniqueness.
  - Revocations: `_id` tenant-aware; TTL on `expires_at`; mandatory `(tenant_id, expires_at)` to support per-tenant sweeping.

## 6. API & Types Changes
- Interfaces (`DocumentStore`, `UserStore`, `TokenRevocationStore`) gain `tenant string` parameter on all operations; `Query` gains required `Tenant` field injected by callers.
- ID helpers become tenant-aware (e.g. `CalculateTenantID(tenant, fullpath)`); path-only helpers are deprecated to avoid cross-tenant collisions.
- Context objects (if introduced later) must still carry explicit tenant and be validated before store calls.

## 7. Routing & Factory
- Factory maintains map: `tenant_id -> backend binding`. Defaults to shared backend; config can mark tenants as dedicated.
- Routers keep op-based selection (read/write split) per backend; tenant lookup happens before router selection.
- TODO: Define Read/Write split strategy for dedicated tenants (currently assumes dedicated backend is a single connection or handles its own topology).
- Fail-closed: tenant-id is mandatory at API boundary; default tenant should be injected by callers. If tenant-id is empty or binding not found, storage layer returns an error to prevent cross-tenant access.

## 8. Mongo Store Behavior (How)
- CRUD/Query/Watch filters always include `tenant_id`.
- Soft delete and TTL updates set `tenant_id` in writes; queries exclude deleted by default and filter tenant.
- Watch: server-side pipeline filters by tenant using `tenant_id` field for inserts/updates, and `documentKey._id` prefix match (`^tenant_id:`) for deletes.
- EnsureIndexes creates compound indexes including `tenant_id`.

## 9. Configuration Additions (example)
```yaml
storage:
  tenants:
    default:
      backend: default_mongo
    vip-tenant-a:
      backend: mongo_vip_a
  backends:
    default_mongo: {...}
    mongo_vip_a: {...}
  topology:
    document:
      strategy: read_write_split
      primary: default_mongo
      replica: default_mongo_replica
    user:
      strategy: single
      primary: default_mongo
    revocation:
      strategy: single
      primary: default_mongo
```
- `tenants` maps tenant ids to backend names; unspecified tenants fall back to `default` binding.
- Dedicated tenants can point to different backend entries (DB-per-tenant or schema-per-tenant via distinct `database_name`).

## 10. Rollout & Compatibility
- No existing data: just deploy with new schema/index creation on startup.
- Backfill path: if needed later, set `tenant_id` = `default` for legacy docs.

## 11. Testing Plan (must add/extend)

- Unit tests for stores: tenant A cannot read/update/delete tenant B docs; query returns only matching tenant; watch emits only same-tenant events (including deletes via client-side guard when server match is limited).
- User/Revocation: username uniqueness enforced per tenant; revocation lookups are tenant-scoped; tenant-aware `_id` differs across tenants for same logical path/ID source.
- Factory/router: tenant binding to dedicated backend; fallback to default; read/write split still respected per tenant; empty tenant-id must error.
- Index verification tests: `(tenant_id, collection_hash)` exists; TTL indexes remain; `_id` generation is tenant-aware (same path with different tenant yields different `_id`).

## 12. Next Steps (if approved)

- Update config structs to include tenant bindings; validate presence of default mapping.
- Extend interfaces and call sites to require tenant.
- Implement Mongo filters/indexes with `tenant_id`.
- Add tests per plan.
- Optional: add guard middleware to inject/validate tenant before storage calls.
