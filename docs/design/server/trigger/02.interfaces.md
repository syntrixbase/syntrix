# Interfaces and Contracts

## Public Surface (Why/How)

- Why: give callers a tiny, stable API and hide transport/storage/HTTP details.
- How: expose only service interfaces; everything else lives in internal adapters.

## Service Interfaces

See detailed interface definitions in:
- [evaluator/README.md](evaluator/README.md) - Evaluator Service interface
- [delivery/README.md](delivery/README.md) - Delivery Service interface

## Database Trust and Safety Constraints

- **Database source**: Trigger definitions are loaded in a database context; factory must validate the database in trigger config matches the scoped database passed to the factory. Reject or fail fast on mismatch.
- **docKey safety**: Subjects must not include `.` `*` `>` wildcards. Use base64url encoding without padding. Publisher encodes before subject construction; consumer decodes before handing to the worker.
- **Subject-length guard**: Enforce 1024-byte NATS limit. Hash docKey segment using SHA-256 hex truncated to 32 chars if the encoded subject would exceed the limit (payload keeps original docKey).
- **Database/collection validation**: Enforce allowed charset (letters, digits, dash, underscore) and max length (default <=128 chars each) at factory load; fail fast on violation.
- **Secret/token isolation**: System tokens are minted per database; secrets referenced by `SecretsRef` resolve within the database namespace. Cross-database secret reuse is forbidden.
- **Hash fallback observability**: When hashing is used, mark `subjectHashed=true` in payload and metrics.
- **Validation failure semantics**: Any database/collection/name or docKey encoding violation is fail-fast at factory/load time.
- **Secret/token failure handling**: Fetch/mint failures are treated as task failures and follow retry policy; no silent drop.

## Checkpoint Design

See [evaluator/01.checkpoint.md](evaluator/01.checkpoint.md) for the global checkpoint design.

Key points:
- Uses global checkpoint key `sys/checkpoints/trigger_evaluator`
- Puller returns aggregated progress tokens (not per-database)
- Database filtering happens at event level, not checkpoint level

## Partitioning and Hashing Contracts

- Consumer partition key and idempotency key use payload `DocKey` (decoded), not the hashed subject fragment.
- When subject hashing occurs, publisher sets `subjectHashed=true` in payload/metrics.
- Hash collision handling: On detected collision, serialize under a single partition, flag, and emit alerts.

## Package Layout

```
internal/trigger/
├── types/            # Shared types (Trigger, DeliveryTask, RetryPolicy)
├── config/           # Configuration
├── evaluator/        # Evaluator Service
├── delivery/         # Delivery Service
├── watcher/          # Document change watcher
├── pubsub/           # NATS publisher/consumer
└── worker/           # HTTP delivery worker
```

## Testing Plan

- Use testify fakes/mocks for NATS JS, storage.DocumentStore, and HTTP server.
- Cover: resume token load/save, event dispatch to evaluator, publisher subject format, consumer partitioning, retry/backoff caps, worker header/signature + system token injection.
- Cover: database mismatch rejection, docKey encoding/decoding invariants, subject-length guard (hash fallback), hash-flag propagation, database/collection name validation failures.

## Open Questions

- **Database isolation**: Decided to keep a single `TRIGGERS` stream with `triggers.<database>.>` subjects; revisit only if quotas/retention require per-database streams.
- **Checkpoint location**: **Resolved** - Uses global checkpoint key. See [evaluator/01.checkpoint.md](evaluator/01.checkpoint.md).
- **Observability**: Optional for now; add hooks later if needed.
