# Trigger Service Separation

## Overview (Why/How)

- **Why**: The current trigger system combines two distinct services in one package structure:
  1. **Evaluator** - Watches document changes, evaluates trigger conditions, publishes tasks
  2. **Delivery Worker** - Consumes tasks from queue, executes HTTP webhooks

  This coupling makes it harder to:
  - Scale services independently
  - Deploy in distributed configurations
  - Understand and maintain the codebase

- **How**: Reorganize `internal/trigger/` into two clear service packages: `evaluator/` and `delivery/`, each with its own service interface and factory.

## Current Structure

```
internal/trigger/
├── config/           # Shared config
├── engine/           # Mixed: TriggerEngine + TriggerFactory (creates both services)
│   ├── engine.go     # Evaluator logic
│   ├── factory.go    # Creates Engine AND Consumer
│   └── interfaces.go # TriggerEngine, TaskConsumer, TriggerFactory
├── evaluator/        # CEL condition evaluator
├── pubsub/           # Mixed: Publisher (for evaluator) + Consumer (for delivery)
│   ├── publisher.go
│   └── consumer.go
├── watcher/          # Document change watcher
├── worker/           # HTTP delivery worker
├── types/            # Shared types
└── ...
```

### Problems

1. `engine/` mixes two service concerns
2. `pubsub/` splits across two services
3. `TriggerFactory` creates unrelated components
4. Hard to understand which code belongs to which service

## Proposed Structure

```
internal/trigger/
├── types/            # Shared types (Trigger, DeliveryTask, RetryPolicy, etc.)
│   ├── types.go
│   ├── duration.go
│   ├── defaults.go
│   └── metrics.go
│
├── config/           # Shared configuration
│   └── config.go
│
├── evaluator/        # ★ Evaluator Service
│   ├── service.go         # EvaluatorService interface + implementation
│   ├── factory.go         # NewEvaluatorService factory
│   ├── cel/               # CEL condition evaluator (moved from evaluator/)
│   │   └── evaluator.go
│   ├── watcher/           # Document watcher (moved from watcher/)
│   │   ├── interfaces.go
│   │   └── watcher.go
│   └── publisher.go       # TaskPublisher adapter (uses core/pubsub)
│
├── delivery/         # ★ Delivery Service
│   ├── service.go         # DeliveryService interface + implementation
│   ├── factory.go         # NewDeliveryService factory
│   ├── consumer.go        # TaskConsumer adapter (uses core/pubsub)
│   └── worker/            # HTTP delivery worker (moved from worker/)
│       ├── interfaces.go
│       └── worker.go
│
├── nats.go           # NATS connection helpers (embedded/remote)
├── loader.go         # Trigger rules file loader
└── aliases.go        # Type aliases for backward compatibility
```

## Service Interfaces

### Evaluator Service

```go
// internal/trigger/evaluator/service.go
package evaluator

import (
    "context"
    "github.com/syntrixbase/syntrix/internal/trigger/types"
)

// Service evaluates document changes against trigger rules and publishes matched tasks.
type Service interface {
    // LoadTriggers validates and loads trigger rules.
    LoadTriggers(triggers []*types.Trigger) error

    // Start begins watching for changes and evaluating triggers.
    // Blocks until context is cancelled.
    Start(ctx context.Context) error

    // Close releases resources.
    Close() error
}

// ServiceOptions configures the evaluator service.
type ServiceOptions struct {
    Database     string
    StartFromNow bool
    RulesFile    string
    StreamName   string
}
```

### Delivery Service

```go
// internal/trigger/delivery/service.go
package delivery

import "context"

// Service consumes delivery tasks and executes HTTP webhooks.
type Service interface {
    // Start begins consuming and processing delivery tasks.
    // Blocks until context is cancelled.
    Start(ctx context.Context) error
}

// ServiceOptions configures the delivery service.
type ServiceOptions struct {
    StreamName      string
    NumWorkers      int
    ChannelBufSize  int
    DrainTimeout    time.Duration
    ShutdownTimeout time.Duration
}
```

## Data Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                     Evaluator Service                                │
│                                                                      │
│  ┌──────────┐    ┌─────────┐    ┌───────────┐    ┌──────────────┐  │
│  │ Watcher  │ -> │   CEL   │ -> │  Builder  │ -> │  Publisher   │  │
│  │(Puller)  │    │Evaluator│    │(DelivTask)│    │(core/pubsub) │  │
│  └──────────┘    └─────────┘    └───────────┘    └──────┬───────┘  │
└─────────────────────────────────────────────────────────┼───────────┘
                                                          │
                                            NATS JetStream│
                                                          │
┌─────────────────────────────────────────────────────────┼───────────┐
│                     Delivery Service                    │            │
│                                                         ▼            │
│  ┌──────────────┐    ┌─────────────┐    ┌──────────────────────┐   │
│  │   Consumer   │ -> │ Worker Pool │ -> │   HTTP Delivery      │   │
│  │(core/pubsub) │    │ (partition) │    │ (auth+sign+request)  │   │
│  └──────────────┘    └─────────────┘    └──────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
```

## Factory Functions

### Evaluator Factory

```go
// internal/trigger/evaluator/factory.go
package evaluator

import (
    "github.com/nats-io/nats.go"
    "github.com/syntrixbase/syntrix/internal/core/pubsub"
    natspubsub "github.com/syntrixbase/syntrix/internal/core/pubsub/nats"
    "github.com/syntrixbase/syntrix/internal/core/storage"
    "github.com/syntrixbase/syntrix/internal/puller"
    "github.com/syntrixbase/syntrix/internal/trigger/types"
)

type Dependencies struct {
    Store   storage.DocumentStore
    Puller  puller.Service
    Nats    *nats.Conn
    Metrics types.Metrics
}

func NewService(deps Dependencies, opts ServiceOptions) (Service, error) {
    // Create CEL evaluator
    eval, err := cel.NewEvaluator()
    if err != nil {
        return nil, err
    }

    // Create watcher
    w := watcher.NewWatcher(deps.Puller, deps.Store, opts.Database, watcher.Options{
        StartFromNow: opts.StartFromNow,
    })

    // Create publisher using core/pubsub
    pub, err := natspubsub.NewPublisher(deps.Nats, pubsub.PublisherOptions{
        StreamName:    opts.StreamName,
        SubjectPrefix: opts.StreamName,
    })
    if err != nil {
        return nil, err
    }

    taskPub := NewTaskPublisher(pub, deps.Metrics)

    svc := &service{
        evaluator: eval,
        watcher:   w,
        publisher: taskPub,
    }

    // Load rules from file if configured
    if opts.RulesFile != "" {
        triggers, err := trigger.LoadTriggersFromFile(opts.RulesFile)
        if err != nil {
            return nil, err
        }
        if err := svc.LoadTriggers(triggers); err != nil {
            return nil, err
        }
    }

    return svc, nil
}
```

### Delivery Factory

```go
// internal/trigger/delivery/factory.go
package delivery

import (
    "github.com/nats-io/nats.go"
    "github.com/syntrixbase/syntrix/internal/core/identity"
    "github.com/syntrixbase/syntrix/internal/core/pubsub"
    natspubsub "github.com/syntrixbase/syntrix/internal/core/pubsub/nats"
    "github.com/syntrixbase/syntrix/internal/trigger/types"
)

type Dependencies struct {
    Nats    *nats.Conn
    Auth    identity.AuthN
    Secrets worker.SecretProvider
    Metrics types.Metrics
}

func NewService(deps Dependencies, opts ServiceOptions) (Service, error) {
    // Create HTTP delivery worker
    w := worker.NewDeliveryWorker(deps.Auth, deps.Secrets, worker.HTTPClientOptions{}, deps.Metrics)

    // Create consumer using core/pubsub
    consumer, err := natspubsub.NewConsumer(deps.Nats, pubsub.ConsumerOptions{
        StreamName:      opts.StreamName,
        ConsumerName:    "TriggerDeliveryWorker",
        FilterSubject:   opts.StreamName + ".>",
        NumWorkers:      opts.NumWorkers,
        ChannelBufSize:  opts.ChannelBufSize,
        DrainTimeout:    opts.DrainTimeout,
        ShutdownTimeout: opts.ShutdownTimeout,
    })
    if err != nil {
        return nil, err
    }

    return &service{
        consumer: NewTaskConsumer(consumer, w, deps.Metrics),
    }, nil
}
```

## ServiceManager Integration

```go
// internal/services/manager_init.go

func (m *Manager) initTriggerEvaluator(ctx context.Context) error {
    deps := evaluator.Dependencies{
        Store:   m.documentStore,
        Puller:  m.pullerService,
        Nats:    m.natsConn,
        Metrics: m.metrics,
    }

    svc, err := evaluator.NewService(deps, evaluator.ServiceOptions{
        Database:     m.cfg.Trigger.Database,
        StartFromNow: m.cfg.Trigger.StartFromNow,
        RulesFile:    m.cfg.Trigger.RulesFile,
        StreamName:   m.cfg.Trigger.StreamName,
    })
    if err != nil {
        return err
    }

    m.triggerEvaluator = svc
    return nil
}

func (m *Manager) initTriggerDelivery(ctx context.Context) error {
    deps := delivery.Dependencies{
        Nats:    m.natsConn,
        Auth:    m.auth,
        Secrets: m.secrets,
        Metrics: m.metrics,
    }

    svc, err := delivery.NewService(deps, delivery.ServiceOptions{
        StreamName: m.cfg.Trigger.StreamName,
        NumWorkers: m.cfg.Trigger.NumWorkers,
    })
    if err != nil {
        return err
    }

    m.triggerDelivery = svc
    return nil
}
```

## Deployment Modes

With separate services, different deployment configurations become clearer:

### Standalone Mode

Both services run in the same process:

```go
// initStandalone
m.initTriggerEvaluator(ctx)
m.initTriggerDelivery(ctx)
```

### Distributed Mode

Services can run in separate processes:

```yaml
# evaluator node
services:
  trigger_evaluator: true
  trigger_delivery: false

# delivery node (can have multiple replicas)
services:
  trigger_evaluator: false
  trigger_delivery: true
```

### Configuration Flags

```go
type TriggerConfig struct {
    // Common
    StreamName string
    RulesFile  string

    // Evaluator-specific
    Database     string
    StartFromNow bool

    // Delivery-specific
    NumWorkers      int
    ChannelBufSize  int
    DrainTimeout    time.Duration
    ShutdownTimeout time.Duration
}
```

## Migration Plan

### Phase 1: Create Core Pubsub (prerequisite)

See `docs/design/server/core/01.pubsub.md`

### Phase 2: Create New Service Packages

1. Create `internal/trigger/evaluator/service.go` and `factory.go`
2. Move `cel/` from `evaluator/` to `evaluator/cel/`
3. Move `watcher/` to `evaluator/watcher/`
4. Create `internal/trigger/evaluator/publisher.go` using core/pubsub

5. Create `internal/trigger/delivery/service.go` and `factory.go`
6. Move `worker/` to `delivery/worker/`
7. Create `internal/trigger/delivery/consumer.go` using core/pubsub

### Phase 3: Update ServiceManager

1. Replace `TriggerFactory` usage with separate `evaluator.NewService` and `delivery.NewService`
2. Add separate config flags for each service
3. Update startup/shutdown sequences

### Phase 4: Cleanup

1. Remove old `internal/trigger/engine/`
2. Remove old `internal/trigger/pubsub/`
3. Update all imports
4. Run tests and fix any issues

### Phase 5: Documentation

1. Update `01.architecture.md`
2. Update `02.interfaces.md`
3. Add deployment examples

## Backward Compatibility

During migration, provide aliases in `internal/trigger/aliases.go`:

```go
package trigger

import (
    "github.com/syntrixbase/syntrix/internal/trigger/evaluator"
    "github.com/syntrixbase/syntrix/internal/trigger/delivery"
)

// Deprecated: Use evaluator.Service directly
type TriggerEngine = evaluator.Service

// Deprecated: Use delivery.Service directly
type TaskConsumer = delivery.Service
```

## Testing Strategy

1. **Unit tests**: Each service tested in isolation with mocked dependencies
2. **Integration tests**: Both services tested together with embedded NATS
3. **Contract tests**: Verify message format compatibility between publisher and consumer

## Open Questions

1. **Shared NATS connection**: Both services share the same NATS connection. Should they have separate connections for isolation?
   - Recommendation: Share connection, managed by ServiceManager

2. **Metrics interface**: Should both services share the same `types.Metrics` interface?
   - Recommendation: Yes, keep shared for consistency

3. **Health checks**: Each service should expose health status. How to aggregate in distributed mode?
   - Recommendation: Each service reports independently; orchestrator aggregates
