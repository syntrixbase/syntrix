# Task Publisher

## Overview

The TaskPublisher publishes matched delivery tasks to NATS JetStream for consumption by the Delivery Service.

## Interface

```go
// TaskPublisher publishes delivery tasks.
type TaskPublisher interface {
    Publish(ctx context.Context, task *types.DeliveryTask) error
    Close() error
}
```

## Subject Format

Tasks are published to subjects with the following format:

```
<stream_name>.<database>.<collection>.<encoded_docKey>
```

Example:
```
TRIGGERS.myapp.orders.b3JkZXIxMjM
```

### Components

| Part | Description | Example |
|------|-------------|---------|
| `stream_name` | NATS stream name | `TRIGGERS` |
| `database` | Syntrix logical database | `myapp` |
| `collection` | Document collection | `orders` |
| `encoded_docKey` | Base64url encoded document key | `b3JkZXIxMjM` |

## DocKey Encoding

Document keys must be encoded to be subject-safe (no `.` `*` `>` wildcards).

### Encoding Strategy

- **Algorithm**: Base64url without padding
- **Rationale**: Produces ASCII-safe output, reversible, widely supported

```go
func encodeDocKey(docKey string) string {
    return base64.RawURLEncoding.EncodeToString([]byte(docKey))
}

func decodeDocKey(encoded string) (string, error) {
    bytes, err := base64.RawURLEncoding.DecodeString(encoded)
    return string(bytes), err
}
```

## Subject Length Guard

NATS has a 1024-byte subject length limit. When the encoded subject would exceed this:

1. Hash the docKey portion using SHA-256
2. Truncate to 32 hex characters
3. Set `subjectHashed=true` flag in payload/metrics
4. Keep original docKey in payload for worker use

```go
func buildSubject(stream, database, collection, docKey string) (string, bool) {
    encoded := encodeDocKey(docKey)
    subject := fmt.Sprintf("%s.%s.%s.%s", stream, database, collection, encoded)

    if len(subject) > 1024 {
        hash := sha256.Sum256([]byte(encoded))
        hashStr := hex.EncodeToString(hash[:])[:32]
        subject = fmt.Sprintf("%s.%s.%s.%s", stream, database, collection, hashStr)
        return subject, true  // hashed=true
    }
    return subject, false
}
```

## DeliveryTask Payload

```go
type DeliveryTask struct {
    TriggerID   string
    Database    string
    Event       string
    Collection  string
    DocumentID  string
    Payload     map[string]interface{}
    URL         string
    Headers     map[string]string
    SecretsRef  string
    RetryPolicy *RetryPolicy
    Timeout     Duration
}
```

## Ordering and Idempotency

### Partition Key

Use **decoded docKey from payload**, not the hashed subject fragment:

- Hash fallback can map different docKeys to the same subject
- Using payload docKey preserves correct ordering

### Idempotency Key

Similarly, use the original docKey for deduplication:

```go
idempotencyKey := fmt.Sprintf("%s:%s:%s", triggerID, documentID, eventID)
```

## Observability

### Metrics

| Metric | Tags | Description |
|--------|------|-------------|
| `trigger.publish.count` | database, collection, success | Publish attempts |
| `trigger.publish.latency` | database | Publish latency histogram |
| `trigger.publish.hashed` | database | Hash fallback usage |

### Hash Path Monitoring

When subject hashing is used:
- Set `subjectHashed=true` in payload
- Emit metric with `hashed=true` tag
- Log if collision detected

## Implementation Reference

See: `internal/trigger/pubsub/publisher.go`
