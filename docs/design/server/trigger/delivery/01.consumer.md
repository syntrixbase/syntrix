# Task Consumer

## Overview

The TaskConsumer pulls delivery tasks from NATS JetStream and dispatches them to workers with proper partitioning.

## Interface

```go
// TaskConsumer consumes delivery tasks from NATS.
type TaskConsumer interface {
    // Start begins consuming tasks. Blocks until context is cancelled.
    Start(ctx context.Context) error
    // Stop initiates graceful shutdown.
    Stop() error
}
```

## Subscription

### Subject Pattern

```
<stream_name>.>
```

Example: `TRIGGERS.>` subscribes to all messages in the TRIGGERS stream.

### Consumer Configuration

```go
consumerConfig := jetstream.ConsumerConfig{
    Name:          "TriggerDeliveryWorker",
    Durable:       "TriggerDeliveryWorker",
    FilterSubject: streamName + ".>",
    AckPolicy:     jetstream.AckExplicitPolicy,
    MaxDeliver:    -1,  // Unlimited retries (handled by retry policy)
    AckWait:       30 * time.Second,
}
```

## Partitioning

Messages are partitioned by document key to ensure ordering:

```go
func (c *consumer) dispatch(msg jetstream.Msg) {
    var task types.DeliveryTask
    json.Unmarshal(msg.Data(), &task)

    // Partition by docKey (from payload, not subject)
    partitionKey := task.DocumentID
    workerIndex := hash(partitionKey) % numWorkers

    c.workerChans[workerIndex] <- msg
}
```

### Why Payload DocKey?

The subject may contain a hashed docKey (when exceeding length limits). Using the payload's `DocumentID` ensures:

1. Correct ordering for the same document
2. Proper deduplication
3. Consistent routing

## Message Handling

### Acknowledgement

```go
// On successful processing
msg.Ack()

// On retryable failure
msg.Nak()  // Redelivered after AckWait

// On fatal failure (no retry)
msg.Term()
```

### Retry Behavior

| Scenario | Action |
|----------|--------|
| HTTP 2xx | Ack |
| HTTP 4xx (except 429) | Term (no retry) |
| HTTP 429 | Nak (retry with backoff) |
| HTTP 5xx | Nak (retry) |
| Network error | Nak (retry) |
| Timeout | Nak (retry) |

## Worker Pool

### Structure

```go
type consumer struct {
    workerChans []chan jetstream.Msg
    wg          sync.WaitGroup
    numWorkers  int
}
```

### Initialization

```go
func (c *consumer) Start(ctx context.Context) error {
    // Create worker channels
    for i := 0; i < c.numWorkers; i++ {
        c.workerChans[i] = make(chan jetstream.Msg, c.channelBufSize)
        c.wg.Add(1)
        go c.runWorker(ctx, i)
    }

    // Start consuming
    return c.consumeLoop(ctx)
}
```

## Observability

### Metrics

| Metric | Tags | Description |
|--------|------|-------------|
| `trigger.consume.count` | database, success | Messages consumed |
| `trigger.consume.latency` | database | Processing latency |
| `trigger.worker.active` | worker_id | Active worker count |
| `trigger.worker.queue_size` | worker_id | Worker channel queue size |

### Logging

| Event | Level | Description |
|-------|-------|-------------|
| Message received | Debug | New message dispatched |
| Message acked | Debug | Successful processing |
| Message nacked | Warn | Retryable failure |
| Message termed | Error | Fatal failure |

## Implementation Reference

See: `internal/trigger/pubsub/consumer.go`
