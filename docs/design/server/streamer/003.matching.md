# Event Matching

**Date:** December 29, 2025
**Status:** Design Draft
**Component:** Streamer Event Matching Engine

## 1. Overview

This document details the event matching algorithm used by Streamer to efficiently match incoming change events against active subscriptions. The matching process uses a two-phase approach: Bloom filter (fast path) followed by CEL evaluation (slow path).

## 2. Matching Goals

### 2.1 Requirements

- **Correctness**: No false negatives (must match all relevant subscriptions)
- **Performance**: < 10ms matching latency at p99
- **Scalability**: Support 100k+ active subscriptions
- **Efficiency**: Minimize CPU usage per event

### 2.2 Trade-offs

```
Bloom Filter:
  ✅ Fast (O(k) where k = number of hash functions)
  ✅ Space-efficient (few KB per collection)
  ❌ False positives possible (but tunable)
  ❌ No false negatives

CEL Evaluation:
  ✅ 100% accurate
  ✅ Expressive (supports complex conditions)
  ❌ Slower (O(n) where n = filter complexity)
  ❌ CPU intensive for complex expressions
```

## 3. Two-Phase Matching

### 3.1 Architecture

```
┌────────────────────────────────────────────────────────────┐
│                     Incoming Event                          │
└──────────────────────┬─────────────────────────────────────┘
                       │
                       ▼
         ┌─────────────────────────────┐
         │  Phase 1: Bloom Filter      │
         │  (Fast Path)                │
         │                             │
         │  • O(k) hash computations   │
         │  • FP rate: ~1%             │
         │  • Latency: < 1ms           │
         └──────────┬──────────────────┘
                    │
                    │ (Candidate subscriptions: ~100-1000)
                    ▼
         ┌─────────────────────────────┐
         │  Phase 2: CEL Evaluation    │
         │  (Slow Path)                │
         │                             │
         │  • Exact matching           │
         │  • No false positives       │
         │  • Latency: 1-10ms          │
         └──────────┬──────────────────┘
                    │
                    ▼
         ┌─────────────────────────────┐
         │     Matched Subscriptions   │
         └─────────────────────────────┘
```

### 3.2 Implementation

```go
type MatchingEngine struct {
    bloomManager *BloomFilterManager
    celEvaluator *CELEvaluator
    indexManager *SubscriptionIndexManager
    metrics      *MatchingMetrics
}

func (m *MatchingEngine) Match(evt *NormalizedEvent) ([]*MatchResult, error) {
    startTime := time.Now()

    // Phase 1: Bloom Filter
    candidates, bloomTime := m.bloomFilterPhase(evt)
    m.metrics.BloomFilterLatency.Observe(bloomTime.Seconds())
    m.metrics.BloomFilterCandidates.Observe(float64(len(candidates)))

    // Phase 2: CEL Evaluation
    matches, celTime := m.celEvaluationPhase(evt, candidates)
    m.metrics.CELEvaluationLatency.Observe(celTime.Seconds())
    m.metrics.MatchesFound.Observe(float64(len(matches)))

    // Total latency
    totalLatency := time.Since(startTime)
    m.metrics.TotalMatchLatency.Observe(totalLatency.Seconds())

    return matches, nil
}
```

## 4. Phase 1: Bloom Filter

### 4.1 Bloom Filter Basics

A Bloom filter is a probabilistic data structure that can test whether an element is **possibly in a set** or **definitely not in a set**.

**Properties:**
- Space-efficient (bits instead of full data)
- Fast lookups (O(k) hash operations)
- False positives possible (but tunable)
- No false negatives (guaranteed)

### 4.2 Bloom Filter Construction

```go
type BloomFilter struct {
    bits      []uint64      // Bit array
    size      uint64        // Total bits
    k         int           // Number of hash functions
    n         int           // Number of elements added
    fpRate    float64       // Target false-positive rate
}

// Optimal parameters calculation
func NewBloomFilter(expectedElements int, fpRate float64) *BloomFilter {
    // Optimal bits: m = -n * ln(p) / (ln(2)^2)
    m := -float64(expectedElements) * math.Log(fpRate) / (math.Ln2 * math.Ln2)
    size := uint64(math.Ceil(m))

    // Optimal hash functions: k = (m/n) * ln(2)
    k := int(math.Ceil((float64(size) / float64(expectedElements)) * math.Ln2))

    return &BloomFilter{
        bits:   make([]uint64, (size+63)/64),
        size:   size,
        k:      k,
        fpRate: fpRate,
    }
}
```

### 4.3 Key Generation from Filters

```go
func (m *MatchingEngine) generateBloomKeys(filters []Filter) []uint64 {
    keys := make([]uint64, 0)

    for _, filter := range filters {
        // For equality filters, hash the field-value pair
        if filter.Op == "==" {
            key := hashFieldValue(filter.Field, filter.Value)
            keys = append(keys, key)
        }

        // For range filters, hash the field name only
        // (will be checked by CEL in phase 2)
        if isRangeOp(filter.Op) {
            key := hashField(filter.Field)
            keys = append(keys, key)
        }
    }

    return keys
}

func hashFieldValue(field string, value interface{}) uint64 {
    h := fnv.New64a()
    h.Write([]byte(field))
    h.Write([]byte("="))
    h.Write([]byte(fmt.Sprint(value)))
    return h.Sum64()
}

func hashField(field string) uint64 {
    h := fnv.New64a()
    h.Write([]byte(field))
    return h.Sum64()
}
```

### 4.4 Adding Subscription to Bloom Filter

```go
func (bf *BloomFilter) Add(keys []uint64) {
    for _, key := range keys {
        for i := 0; i < bf.k; i++ {
            hash := bf.hash(key, i)
            bitIndex := hash % bf.size
            wordIndex := bitIndex / 64
            bitOffset := bitIndex % 64
            bf.bits[wordIndex] |= (1 << bitOffset)
        }
    }
    bf.n++
}

func (bf *BloomFilter) hash(key uint64, i int) uint64 {
    // Double hashing: h(key, i) = h1(key) + i * h2(key)
    h1 := key
    h2 := key>>32 | key<<32
    return h1 + uint64(i)*h2
}
```

### 4.5 Checking Event Against Bloom Filter

```go
func (m *MatchingEngine) bloomFilterPhase(evt *NormalizedEvent) ([]*Subscription, time.Duration) {
    start := time.Now()

    // Get Bloom filter for this collection
    bloom := m.bloomManager.Get(evt.Collection)
    if bloom == nil {
        // No subscriptions for this collection
        return nil, time.Since(start)
    }

    // Generate keys from event
    eventKeys := m.generateEventKeys(evt)

    // Check if event matches Bloom filter
    if !bloom.MightContain(eventKeys) {
        // Definitely no matches
        return nil, time.Since(start)
    }

    // Bloom filter says "maybe" - get all subscriptions for this collection
    candidates := m.indexManager.GetByCollection(evt.Collection)

    return candidates, time.Since(start)
}

func (m *MatchingEngine) generateEventKeys(evt *NormalizedEvent) []uint64 {
    keys := make([]uint64, 0)

    // Generate keys for all fields in the event document
    for field, value := range evt.FullDoc {
        // Exact match key
        keys = append(keys, hashFieldValue(field, value))

        // Field-only key (for range queries)
        keys = append(keys, hashField(field))
    }

    return keys
}

func (bf *BloomFilter) MightContain(keys []uint64) bool {
    for _, key := range keys {
        if bf.mightContainSingle(key) {
            return true
        }
    }
    return false
}

func (bf *BloomFilter) mightContainSingle(key uint64) bool {
    for i := 0; i < bf.k; i++ {
        hash := bf.hash(key, i)
        bitIndex := hash % bf.size
        wordIndex := bitIndex / 64
        bitOffset := bitIndex % 64

        if (bf.bits[wordIndex] & (1 << bitOffset)) == 0 {
            return false  // Definitely not present
        }
    }
    return true  // Maybe present
}
```

## 5. Phase 2: CEL Evaluation

### 5.1 CEL Overview

CEL (Common Expression Language) is a non-Turing complete expression language designed for safe evaluation of user-provided expressions.

**Example CEL expressions:**
```
data.status == "active"
data.priority > 5
data.tags.contains("urgent")
data.amount >= 100 && data.currency == "USD"
```

### 5.2 CEL Compilation

```go
type CELEvaluator struct {
    env     *cel.Env
    cache   *lru.Cache  // Cache compiled programs
    metrics *CELMetrics
}

func NewCELEvaluator() (*CELEvaluator, error) {
    // Create CEL environment with custom types
    env, err := cel.NewEnv(
        cel.Types(&model.Document{}),
        cel.Variable("data", cel.MapType(cel.StringType, cel.DynType)),
        cel.Variable("collection", cel.StringType),
        cel.Variable("tenant", cel.StringType),
        cel.Variable("type", cel.StringType),
    )
    if err != nil {
        return nil, err
    }

    cache, _ := lru.New(10000)  // Cache up to 10k programs

    return &CELEvaluator{
        env:   env,
        cache: cache,
    }, nil
}

func (c *CELEvaluator) Compile(filters []Filter) (cel.Program, error) {
    // Build CEL expression from filters
    expr := c.buildExpression(filters)

    // Check cache
    if prog, ok := c.cache.Get(expr); ok {
        c.metrics.CacheHits.Inc()
        return prog.(cel.Program), nil
    }

    c.metrics.CacheMisses.Inc()

    // Compile
    ast, issues := c.env.Compile(expr)
    if issues != nil && issues.Err() != nil {
        return nil, issues.Err()
    }

    prog, err := c.env.Program(ast)
    if err != nil {
        return nil, err
    }

    // Cache compiled program
    c.cache.Add(expr, prog)

    return prog, nil
}

func (c *CELEvaluator) buildExpression(filters []Filter) string {
    if len(filters) == 0 {
        return "true"
    }

    expressions := make([]string, len(filters))
    for i, f := range filters {
        expressions[i] = c.filterToExpression(f)
    }

    return strings.Join(expressions, " && ")
}

func (c *CELEvaluator) filterToExpression(f Filter) string {
    switch f.Op {
    case "==":
        return fmt.Sprintf("%s == %s", f.Field, c.formatValue(f.Value))
    case "!=":
        return fmt.Sprintf("%s != %s", f.Field, c.formatValue(f.Value))
    case ">":
        return fmt.Sprintf("%s > %s", f.Field, c.formatValue(f.Value))
    case ">=":
        return fmt.Sprintf("%s >= %s", f.Field, c.formatValue(f.Value))
    case "<":
        return fmt.Sprintf("%s < %s", f.Field, c.formatValue(f.Value))
    case "<=":
        return fmt.Sprintf("%s <= %s", f.Field, c.formatValue(f.Value))
    case "in":
        return fmt.Sprintf("%s in %s", f.Field, c.formatValue(f.Value))
    case "contains":
        return fmt.Sprintf("%s.contains(%s)", f.Field, c.formatValue(f.Value))
    default:
        return "true"
    }
}
```

### 5.3 CEL Evaluation

```go
func (m *MatchingEngine) celEvaluationPhase(evt *NormalizedEvent, candidates []*Subscription) ([]*MatchResult, time.Duration) {
    start := time.Now()
    matches := make([]*MatchResult, 0)

    // Prepare CEL variables
    vars := map[string]interface{}{
        "data":       evt.FullDoc,
        "collection": evt.Collection,
        "tenant":     evt.Tenant,
        "type":       string(evt.Type),
    }

    for _, sub := range candidates {
        if m.evaluateSubscription(sub, vars) {
            matches = append(matches, &MatchResult{
                SubscriptionID: sub.ID,
                GatewayID:      sub.GatewayID,
                Event:          evt,
            })
        }
    }

    return matches, time.Since(start)
}

func (m *MatchingEngine) evaluateSubscription(sub *Subscription, vars map[string]interface{}) bool {
    // Evaluate CEL program
    out, _, err := sub.CELProgram.Eval(vars)
    if err != nil {
        m.metrics.CELEvaluationErrors.Inc()
        log.Errorf("CEL evaluation failed for subscription %s: %v", sub.ID, err)
        return false
    }

    // Check result
    result, ok := out.Value().(bool)
    if !ok {
        m.metrics.CELEvaluationErrors.Inc()
        log.Errorf("CEL evaluation returned non-boolean for subscription %s", sub.ID)
        return false
    }

    return result
}
```

## 6. Bloom Filter Management

### 6.1 Bloom Filter Manager

```go
type BloomFilterManager struct {
    filters  map[string]*BloomFilter  // collection → Bloom filter
    versions map[string]int           // collection → version
    config   BloomConfig
    mu       sync.RWMutex
}

type BloomConfig struct {
    FPRate          float64       // Target false-positive rate (default: 0.01)
    InitialCapacity int           // Initial expected elements (default: 1000)
    RebuildInterval time.Duration // Auto-rebuild interval (default: 24h)
    RebuildFPThreshold float64    // Rebuild if FP rate exceeds (default: 0.02)
}
```

### 6.2 Adding Keys

```go
func (bm *BloomFilterManager) AddKeys(collection string, keys []uint64) {
    bm.mu.Lock()
    defer bm.mu.Unlock()

    bloom := bm.getOrCreate(collection)
    bloom.Add(keys)
}

func (bm *BloomFilterManager) getOrCreate(collection string) *BloomFilter {
    if bloom, exists := bm.filters[collection]; exists {
        return bloom
    }

    // Create new Bloom filter
    bloom := NewBloomFilter(bm.config.InitialCapacity, bm.config.FPRate)
    bm.filters[collection] = bloom
    bm.versions[collection] = 1

    return bloom
}
```

### 6.3 Rebuild Trigger

```go
func (bm *BloomFilterManager) ShouldRebuild(collection string) bool {
    bm.mu.RLock()
    defer bm.mu.RUnlock()

    bloom := bm.filters[collection]
    if bloom == nil {
        return false
    }

    // Check actual FP rate via sampling
    actualFP := bm.estimateFPRate(collection)
    if actualFP > bm.config.RebuildFPThreshold {
        return true
    }

    return false
}

func (bm *BloomFilterManager) Rebuild(collection string, subscriptions []*Subscription) {
    bm.mu.Lock()
    defer bm.mu.Unlock()

    // Create new Bloom filter
    bloom := NewBloomFilter(len(subscriptions)*2, bm.config.FPRate)

    // Add all subscription keys
    for _, sub := range subscriptions {
        bloom.Add(sub.BloomKeys)
    }

    // Replace old filter
    bm.filters[collection] = bloom
    bm.versions[collection]++

    log.Infof("Rebuilt Bloom filter for collection %s (version %d, %d subscriptions)",
        collection, bm.versions[collection], len(subscriptions))
}
```

### 6.4 Auto-Rebuild Loop

```go
func (bm *BloomFilterManager) StartRebuildLoop(ctx context.Context, indexManager *SubscriptionIndexManager) {
    ticker := time.NewTicker(bm.config.RebuildInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            bm.rebuildAll(indexManager)
        }
    }
}

func (bm *BloomFilterManager) rebuildAll(indexManager *SubscriptionIndexManager) {
    collections := bm.getCollections()

    for _, collection := range collections {
        if bm.ShouldRebuild(collection) {
            subscriptions := indexManager.GetByCollection(collection)
            bm.Rebuild(collection, subscriptions)
        }
    }
}
```

## 7. Performance Optimization

### 7.1 Caching Strategies

**CEL Program Cache:**
```go
// Cache compiled CEL programs (hot path)
type CELCache struct {
    cache *lru.Cache
    hits  uint64
    misses uint64
}

// Typical hit rate: > 99% (same filters used repeatedly)
```

**Subscription Lookup Cache:**
```go
// Cache subscription lookups by collection
type SubscriptionCache struct {
    cache      *lru.Cache
    ttl        time.Duration  // 60 seconds
    lastUpdate map[string]time.Time
}
```

### 7.2 Batch Processing

```go
// Process multiple events in a batch
func (m *MatchingEngine) MatchBatch(events []*NormalizedEvent) ([][]*MatchResult, error) {
    results := make([][]*MatchResult, len(events))

    // Group events by collection for efficient Bloom filter checks
    byCollection := m.groupByCollection(events)

    for collection, evts := range byCollection {
        bloom := m.bloomManager.Get(collection)
        candidates := m.indexManager.GetByCollection(collection)

        for i, evt := range evts {
            if bloom != nil && !bloom.MightContain(m.generateEventKeys(evt)) {
                continue
            }
            results[i] = m.celEvaluationPhase(evt, candidates)
        }
    }

    return results, nil
}
```

## 8. Metrics & Observability

```go
type MatchingMetrics struct {
    // Phase 1: Bloom Filter
    BloomFilterLatency     prometheus.Histogram
    BloomFilterCandidates  prometheus.Histogram
    BloomFilterHits        prometheus.Counter
    BloomFilterMisses      prometheus.Counter
    BloomFilterFPRate      prometheus.Gauge

    // Phase 2: CEL Evaluation
    CELEvaluationLatency   prometheus.Histogram
    CELEvaluationErrors    prometheus.Counter
    CELCacheHits           prometheus.Counter
    CELCacheMisses         prometheus.Counter

    // Overall
    TotalMatchLatency      prometheus.Histogram
    MatchesFound           prometheus.Histogram
    EventsProcessed        prometheus.Counter
}
```

## 9. Configuration

```yaml
matching:
  # Bloom Filter
  bloom:
    fp_rate: 0.01              # Target false-positive rate
    initial_capacity: 1000     # Expected subscriptions per collection
    rebuild_interval: 24h      # Auto-rebuild interval
    rebuild_fp_threshold: 0.02 # Rebuild if FP rate exceeds

  # CEL
  cel:
    cache_size: 10000          # Number of compiled programs to cache
    evaluation_timeout: 100ms  # Max time for CEL evaluation

  # Performance
  batch_size: 100              # Events to process in batch
```

## 10. Testing

### 10.1 Correctness Tests
- No false negatives (all matches found)
- CEL evaluation accuracy
- Complex filter combinations

### 10.2 Performance Tests
- Matching latency (p50, p99, p999)
- Bloom filter efficiency
- CEL cache hit rate

### 10.3 Load Tests
- 100k subscriptions
- 10k events/sec
- Mixed filter complexity
