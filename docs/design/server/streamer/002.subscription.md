# Subscription Management

**Date:** December 29, 2025
**Status:** Design Draft
**Component:** Streamer Subscription Management

## 1. Overview

This document details how the Streamer manages subscriptions from Gateway nodes, including registration, indexing, TTL management, and expiry.

## 2. Subscription Lifecycle

### 2.1 Lifecycle States

```
┌──────────────┐
│  Registered  │ ◄──────────────────┐
└──────┬───────┘                    │
       │                            │
       │ (Heartbeat received)       │
       ▼                            │
┌──────────────┐                    │
│    Active    │────────────────────┘
└──────┬───────┘
       │
       │ (TTL expired, no heartbeat)
       ▼
┌──────────────┐
│   Expired    │
└──────┬───────┘
       │
       │ (Cleanup)
       ▼
┌──────────────┐
│   Removed    │
└──────────────┘
```

### 2.2 State Transitions

```go
type SubscriptionState int

const (
    StateRegistered SubscriptionState = iota
    StateActive
    StateExpired
    StateRemoved
)

type Subscription struct {
    ID          string
    GatewayID   string
    Tenant      string
    Collection  string
    Filters     []Filter
    CELProgram  cel.Program
    BloomKeys   []uint64
    State       SubscriptionState
    CreatedAt   time.Time
    UpdatedAt   time.Time
    ExpiresAt   time.Time
}
```

## 3. Registration Protocol

### 3.1 Registration Request

**Endpoint:** `POST /internal/v1/subscriptions`

**Request:**

```json
{
  "gatewayId": "gateway-1",
  "subscriptionId": "sub-abc123",
  "tenant": "default",
  "collection": "rooms/room-1/messages",
  "filters": [
    {
      "field": "data.status",
      "op": "==",
      "value": "active"
    },
    {
      "field": "data.priority",
      "op": ">",
      "value": 5
    }
  ],
  "ttl": 300
}
```

**Response (201 Created):**

```json
{
  "subscriptionId": "sub-abc123",
  "createdAt": "2025-12-29T10:00:00Z",
  "expiresAt": "2025-12-29T10:05:00Z",
  "bloomFilterVersion": 42
}
```

### 3.2 Registration Flow

```go
func (s *SubscriptionManager) Register(ctx context.Context, req *RegisterRequest) (*RegisterResponse, error) {
    // 1. Validate request
    if err := s.validate(req); err != nil {
        return nil, fmt.Errorf("validation failed: %w", err)
    }

    // 2. Compile CEL expression
    celProg, err := s.compileCEL(req.Filters)
    if err != nil {
        return nil, fmt.Errorf("CEL compilation failed: %w", err)
    }

    // 3. Generate Bloom filter keys
    bloomKeys := s.generateBloomKeys(req.Filters)

    // 4. Create subscription
    sub := &Subscription{
        ID:          req.SubscriptionID,
        GatewayID:   req.GatewayID,
        Tenant:      req.Tenant,
        Collection:  req.Collection,
        Filters:     req.Filters,
        CELProgram:  celProg,
        BloomKeys:   bloomKeys,
        State:       StateRegistered,
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
        ExpiresAt:   time.Now().Add(time.Duration(req.TTL) * time.Second),
    }

    // 5. Add to index
    if err := s.index.Add(sub); err != nil {
        return nil, fmt.Errorf("index add failed: %w", err)
    }

    // 6. Update Bloom filter
    s.bloomManager.AddKeys(req.Collection, bloomKeys)

    // 7. Record metrics
    s.metrics.SubscriptionsActive.Inc()
    s.metrics.SubscriptionsTotal.Inc()

    return &RegisterResponse{
        SubscriptionID:      sub.ID,
        CreatedAt:           sub.CreatedAt,
        ExpiresAt:           sub.ExpiresAt,
        BloomFilterVersion:  s.bloomManager.GetVersion(req.Collection),
    }, nil
}
```

### 3.3 Validation Rules

```go
func (s *SubscriptionManager) validate(req *RegisterRequest) error {
    // Required fields
    if req.GatewayID == "" {
        return errors.New("gatewayId is required")
    }
    if req.SubscriptionID == "" {
        return errors.New("subscriptionId is required")
    }
    if req.Tenant == "" {
        return errors.New("tenant is required")
    }
    if req.Collection == "" {
        return errors.New("collection is required")
    }

    // Subscription ID format
    if !isValidSubID(req.SubscriptionID) {
        return errors.New("subscriptionId must match pattern: [a-zA-Z0-9_-]+")
    }

    // Collection format
    if !isValidCollectionPath(req.Collection) {
        return errors.New("collection must be a valid path")
    }

    // TTL bounds
    if req.TTL < 60 || req.TTL > 3600 {
        return errors.New("ttl must be between 60 and 3600 seconds")
    }

    // Filter validation
    for _, f := range req.Filters {
        if err := validateFilter(f); err != nil {
            return fmt.Errorf("invalid filter: %w", err)
        }
    }

    return nil
}
```

## 4. Heartbeat & Renewal

### 4.1 Heartbeat Request

**Endpoint:** `PUT /internal/v1/subscriptions/:id/heartbeat`

**Request:** (empty body)

**Response (200 OK):**

```json
{
  "subscriptionId": "sub-abc123",
  "expiresAt": "2025-12-29T10:10:00Z"
}
```

### 4.2 Renewal Logic

```go
func (s *SubscriptionManager) Renew(ctx context.Context, subID string) (*RenewResponse, error) {
    sub, err := s.index.Get(subID)
    if err != nil {
        if errors.Is(err, ErrNotFound) {
            return nil, ErrSubscriptionNotFound
        }
        return nil, err
    }

    // Check if already expired
    if sub.State == StateExpired {
        return nil, ErrSubscriptionExpired
    }

    // Extend TTL
    newExpiry := time.Now().Add(s.config.DefaultTTL)
    sub.ExpiresAt = newExpiry
    sub.UpdatedAt = time.Now()

    // Update in index
    if err := s.index.Update(sub); err != nil {
        return nil, err
    }

    return &RenewResponse{
        SubscriptionID: sub.ID,
        ExpiresAt:      sub.ExpiresAt,
    }, nil
}
```

### 4.3 Recommended Heartbeat Strategy

**Gateway Side:**

```go
// Send heartbeat at TTL/2 interval
func (g *Gateway) startHeartbeatLoop(subID string, ttl time.Duration) {
    ticker := time.NewTicker(ttl / 2)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            if err := g.streamerClient.Heartbeat(subID); err != nil {
                log.Errorf("Heartbeat failed for %s: %v", subID, err)
                // Retry logic...
            }
        case <-g.stopCh:
            return
        }
    }
}
```

## 5. Subscription Index

### 5.1 Index Structure

```go
type SubscriptionIndex struct {
    mu sync.RWMutex

    // Primary index: subscription ID → subscription
    byID map[string]*Subscription

    // Secondary index: collection → subscriptions
    byCollection map[string][]*Subscription

    // Secondary index: gateway ID → subscriptions
    byGateway map[string][]*Subscription

    // Expiry heap (min-heap by ExpiresAt)
    expiryHeap *ExpiryHeap

    // Metrics
    metrics *IndexMetrics
}
```

### 5.2 Index Operations

**Add:**

```go
func (idx *SubscriptionIndex) Add(sub *Subscription) error {
    idx.mu.Lock()
    defer idx.mu.Unlock()

    // Check for duplicate
    if _, exists := idx.byID[sub.ID]; exists {
        return ErrSubscriptionExists
    }

    // Add to primary index
    idx.byID[sub.ID] = sub

    // Add to collection index
    idx.byCollection[sub.Collection] = append(idx.byCollection[sub.Collection], sub)

    // Add to gateway index
    idx.byGateway[sub.GatewayID] = append(idx.byGateway[sub.GatewayID], sub)

    // Add to expiry heap
    idx.expiryHeap.Push(sub)

    // Update metrics
    idx.metrics.TotalSubscriptions.Inc()
    idx.metrics.SubscriptionsByCollection.WithLabelValues(sub.Collection).Inc()

    return nil
}
```

**Remove:**

```go
func (idx *SubscriptionIndex) Remove(subID string) error {
    idx.mu.Lock()
    defer idx.mu.Unlock()

    sub, exists := idx.byID[subID]
    if !exists {
        return ErrSubscriptionNotFound
    }

    // Remove from primary index
    delete(idx.byID, subID)

    // Remove from collection index
    idx.removeFromSlice(&idx.byCollection[sub.Collection], sub)

    // Remove from gateway index
    idx.removeFromSlice(&idx.byGateway[sub.GatewayID], sub)

    // Remove from expiry heap
    idx.expiryHeap.Remove(sub)

    // Update metrics
    idx.metrics.TotalSubscriptions.Dec()
    idx.metrics.SubscriptionsByCollection.WithLabelValues(sub.Collection).Dec()

    return nil
}
```

**GetByCollection:**

```go
func (idx *SubscriptionIndex) GetByCollection(collection string) []*Subscription {
    idx.mu.RLock()
    defer idx.mu.RUnlock()

    subs := idx.byCollection[collection]

    // Return a copy to avoid race conditions
    result := make([]*Subscription, len(subs))
    copy(result, subs)

    return result
}
```

### 5.3 Expiry Heap

```go
type ExpiryHeap struct {
    items []*Subscription
}

func (h *ExpiryHeap) Len() int { return len(h.items) }

func (h *ExpiryHeap) Less(i, j int) bool {
    return h.items[i].ExpiresAt.Before(h.items[j].ExpiresAt)
}

func (h *ExpiryHeap) Swap(i, j int) {
    h.items[i], h.items[j] = h.items[j], h.items[i]
}

func (h *ExpiryHeap) Push(x interface{}) {
    h.items = append(h.items, x.(*Subscription))
}

func (h *ExpiryHeap) Pop() interface{} {
    old := h.items
    n := len(old)
    item := old[n-1]
    h.items = old[0 : n-1]
    return item
}

func (h *ExpiryHeap) Peek() *Subscription {
    if len(h.items) == 0 {
        return nil
    }
    return h.items[0]
}
```

## 6. TTL & Expiry Management

### 6.1 Expiry Loop

```go
func (s *SubscriptionManager) StartExpiryLoop(ctx context.Context) {
    ticker := time.NewTicker(s.config.ExpiryCheckInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            s.expireStaleSubscriptions()
        }
    }
}

func (s *SubscriptionManager) expireStaleSubscriptions() {
    now := time.Now()
    expired := make([]*Subscription, 0)

    s.index.mu.Lock()
    for {
        sub := s.index.expiryHeap.Peek()
        if sub == nil || sub.ExpiresAt.After(now) {
            break
        }

        // Remove from heap
        s.index.expiryHeap.Pop()
        expired = append(expired, sub)
    }
    s.index.mu.Unlock()

    // Process expired subscriptions (outside lock)
    for _, sub := range expired {
        s.handleExpiredSubscription(sub)
    }

    if len(expired) > 0 {
        log.Infof("Expired %d subscriptions", len(expired))
        s.metrics.SubscriptionsExpired.Add(float64(len(expired)))
    }
}
```

### 6.2 Expiry Handling

```go
func (s *SubscriptionManager) handleExpiredSubscription(sub *Subscription) {
    log.Infof("Subscription expired: %s (gateway: %s)", sub.ID, sub.GatewayID)

    // Mark as expired
    sub.State = StateExpired

    // Remove from index
    if err := s.index.Remove(sub.ID); err != nil {
        log.Errorf("Failed to remove expired subscription %s: %v", sub.ID, err)
    }

    // Update Bloom filter
    s.bloomManager.MarkDirty(sub.Collection)

    // Notify Gateway (optional)
    if s.config.NotifyOnExpiry {
        s.notifyGateway(sub.GatewayID, &ExpiryNotification{
            SubscriptionID: sub.ID,
            Reason:         "ttl_expired",
        })
    }

    // Record metrics
    s.metrics.SubscriptionsActive.Dec()
}
```

## 7. Unregistration

### 7.1 Explicit Unregistration

**Endpoint:** `DELETE /internal/v1/subscriptions/:id`

**Response (204 No Content)**

```go
func (s *SubscriptionManager) Unregister(ctx context.Context, subID string) error {
    sub, err := s.index.Get(subID)
    if err != nil {
        if errors.Is(err, ErrNotFound) {
            return nil  // Idempotent
        }
        return err
    }

    // Mark as removed
    sub.State = StateRemoved

    // Remove from index
    if err := s.index.Remove(subID); err != nil {
        return err
    }

    // Update Bloom filter
    s.bloomManager.MarkDirty(sub.Collection)

    // Record metrics
    s.metrics.SubscriptionsActive.Dec()
    s.metrics.SubscriptionsUnregistered.Inc()

    log.Infof("Subscription unregistered: %s", subID)
    return nil
}
```

### 7.2 Batch Unregistration

For Gateway shutdown:

**Endpoint:** `DELETE /internal/v1/gateways/:id/subscriptions`

```go
func (s *SubscriptionManager) UnregisterGateway(ctx context.Context, gatewayID string) error {
    subs := s.index.GetByGateway(gatewayID)

    for _, sub := range subs {
        if err := s.Unregister(ctx, sub.ID); err != nil {
            log.Errorf("Failed to unregister %s: %v", sub.ID, err)
        }
    }

    log.Infof("Unregistered %d subscriptions for gateway %s", len(subs), gatewayID)
    return nil
}
```

## 8. Subscription Limits & Quotas

### 8.1 Per-Gateway Limits

```go
type QuotaConfig struct {
    MaxSubscriptionsPerGateway int  // Default: 10000
    MaxSubscriptionsPerTenant  int  // Default: 50000
    MaxSubscriptionsGlobal     int  // Default: 100000
}

func (s *SubscriptionManager) checkQuota(req *RegisterRequest) error {
    // Check gateway quota
    gwSubs := len(s.index.GetByGateway(req.GatewayID))
    if gwSubs >= s.config.Quota.MaxSubscriptionsPerGateway {
        return ErrGatewayQuotaExceeded
    }

    // Check tenant quota
    tenantSubs := s.countByTenant(req.Tenant)
    if tenantSubs >= s.config.Quota.MaxSubscriptionsPerTenant {
        return ErrTenantQuotaExceeded
    }

    // Check global quota
    if s.index.TotalCount() >= s.config.Quota.MaxSubscriptionsGlobal {
        return ErrGlobalQuotaExceeded
    }

    return nil
}
```

## 9. Monitoring & Metrics

### 9.1 Key Metrics

```go
type SubscriptionMetrics struct {
    // Counters
    SubscriptionsTotal       prometheus.Counter
    SubscriptionsActive      prometheus.Gauge
    SubscriptionsExpired     prometheus.Counter
    SubscriptionsUnregistered prometheus.Counter

    // By Collection
    SubscriptionsByCollection *prometheus.GaugeVec  // Labels: collection

    // By Gateway
    SubscriptionsByGateway    *prometheus.GaugeVec  // Labels: gatewayId

    // By Tenant
    SubscriptionsByTenant     *prometheus.GaugeVec  // Labels: tenant

    // Latency
    RegistrationDuration      prometheus.Histogram
    RenewalDuration           prometheus.Histogram

    // Errors
    RegistrationErrors        prometheus.Counter
    RenewalErrors             prometheus.Counter
}
```

### 9.2 Health Checks

```go
func (s *SubscriptionManager) Health() *HealthStatus {
    return &HealthStatus{
        Status: "healthy",
        Subscriptions: HealthDetails{
            Total:    s.index.TotalCount(),
            Active:   s.countByState(StateActive),
            Expired:  s.countByState(StateExpired),
        },
        IndexSize: len(s.index.byID),
        HeapSize:  s.index.expiryHeap.Len(),
    }
}
```

## 10. Configuration

```yaml
subscription:
  # TTL
  default_ttl: 300s           # Default subscription TTL
  min_ttl: 60s                # Minimum allowed TTL
  max_ttl: 3600s              # Maximum allowed TTL
  expiry_check_interval: 10s  # How often to check for expired subscriptions

  # Quotas
  quota:
    max_per_gateway: 10000
    max_per_tenant: 50000
    max_global: 100000

  # Notifications
  notify_on_expiry: false     # Notify Gateway when subscription expires

  # Index
  index:
    initial_capacity: 10000   # Initial map capacity
```

## 11. Error Codes

```go
const (
    ErrSubscriptionExists        = "SUBSCRIPTION_EXISTS"
    ErrSubscriptionNotFound      = "SUBSCRIPTION_NOT_FOUND"
    ErrSubscriptionExpired       = "SUBSCRIPTION_EXPIRED"
    ErrGatewayQuotaExceeded      = "GATEWAY_QUOTA_EXCEEDED"
    ErrTenantQuotaExceeded       = "TENANT_QUOTA_EXCEEDED"
    ErrGlobalQuotaExceeded       = "GLOBAL_QUOTA_EXCEEDED"
    ErrInvalidFilter             = "INVALID_FILTER"
    ErrCELCompilationFailed      = "CEL_COMPILATION_FAILED"
)
```

## 12. Testing Considerations

### 12.1 Unit Tests

- Subscription registration with valid/invalid input
- TTL expiry logic
- Heartbeat renewal
- Index operations (add, remove, get)
- Quota enforcement
- Concurrent access to index

### 12.2 Integration Tests

- Gateway → Streamer registration flow
- Heartbeat loop
- Automatic expiry
- Bloom filter updates on add/remove

### 12.3 Load Tests

- 100k concurrent subscriptions
- 1k registrations/sec
- Heartbeat at scale
