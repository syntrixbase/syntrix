# Database Integration with Document Operations

**Date:** January 2026
**Status:** Draft
**Scope:** How database management integrates with existing document read/write operations.

## 1. Overview

This document describes how the new database management layer integrates with existing document operations to enforce:
- Database existence validation
- Status checks (reject operations on suspended/deleting databases)
- Future: quota enforcement

## 2. Current Document API

Existing document operations use this URL pattern:
```
/api/v1/databases/{database}/documents/{path...}
```

Operations:
- `GET` - Read document
- `POST` - Create document
- `PUT` - Replace document
- `PATCH` - Update document
- `DELETE` - Delete document

Query operations:
```
POST /api/v1/databases/{database}/query
```

## 3. Integration Points

### 3.1 Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                        HTTP Request                              │
│         GET /api/v1/databases/my-db/documents/users/123          │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Gateway Handler                              │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │              Authentication Middleware                    │   │
│  │              (validate JWT, extract user)                 │   │
│  └────────────────────────┬─────────────────────────────────┘   │
│                           │                                      │
│  ┌────────────────────────▼─────────────────────────────────┐   │
│  │           Database Validation Middleware (NEW)            │   │
│  │           - Check database exists                         │   │
│  │           - Check status is 'active'                      │   │
│  │           - Cache lookup for performance                  │   │
│  └────────────────────────┬─────────────────────────────────┘   │
│                           │                                      │
│  ┌────────────────────────▼─────────────────────────────────┐   │
│  │              Authorization Middleware                     │   │
│  │              (check security rules)                       │   │
│  └────────────────────────┬─────────────────────────────────┘   │
│                           │                                      │
│  ┌────────────────────────▼─────────────────────────────────┐   │
│  │              Document Handler                             │   │
│  │              (execute operation)                          │   │
│  └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 Middleware Order

1. **Authentication** - Validate JWT, extract user context
2. **Database Validation** (NEW) - Verify database exists and is active
3. **Authorization** - Check security rules
4. **Handler** - Execute document operation

**Note on order:** Authentication comes first so that unauthenticated users receive 401 Unauthorized rather than 404 Database Not Found. This prevents information leakage about which databases exist.

## 4. Database Validation Middleware

### 4.1 Identifier Resolution

The middleware must resolve the URL path identifier to a database. The identifier can be:
- A slug (e.g., `my-app-prod`)
- An ID with `id:` prefix (e.g., `id:a1b2c3d4e5f67890`)

### 4.2 Implementation

```go
package gateway

import (
    "net/http"
    "strings"

    "github.com/syntrixbase/syntrix/internal/core/database"
)

type DatabaseValidator struct {
    service database.Service
}

func NewDatabaseValidator(service database.Service) *DatabaseValidator {
    return &DatabaseValidator{service: service}
}

func (v *DatabaseValidator) Middleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        identifier := r.PathValue("database")
        if identifier == "" {
            writeError(w, http.StatusBadRequest, "database_required",
                "Database identifier is required in URL path")
            return
        }

        // Resolve identifier to database
        db, err := v.service.ResolveDatabase(r.Context(), identifier)
        if err != nil {
            switch err {
            case database.ErrDatabaseNotFound:
                writeError(w, http.StatusNotFound, "database_not_found",
                    "Database '"+identifier+"' does not exist")
            case database.ErrDatabaseDeleting:
                writeError(w, http.StatusGone, "database_deleting",
                    "Database '"+identifier+"' is being deleted")
            case database.ErrDatabaseSuspended:
                writeError(w, http.StatusForbidden, "database_suspended",
                    "Database '"+identifier+"' is suspended")
            default:
                writeError(w, http.StatusInternalServerError, "database_check_failed",
                    "Failed to validate database")
            }
            return
        }

        // Store resolved database in context for downstream handlers
        ctx := database.WithDatabase(r.Context(), db)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}
```

### 4.3 Service Method

```go
package database

import (
    "context"
    "strings"
)

// ResolveDatabase resolves an identifier (slug or id:xxx) to a database
func (s *Service) ResolveDatabase(ctx context.Context, identifier string) (*Database, error) {
    var db *Database
    var err error

    // Check if identifier is an ID (prefixed with "id:")
    if strings.HasPrefix(identifier, "id:") {
        id := identifier[3:]
        db, err = s.cache.GetByID(ctx, id)
    } else {
        // Treat as slug
        db, err = s.cache.GetBySlug(ctx, identifier)
    }

    if err != nil {
        return nil, err
    }

    // Check status
    switch db.Status {
    case StatusActive:
        return db, nil
    case StatusSuspended:
        return nil, ErrDatabaseSuspended
    case StatusDeleting:
        return nil, ErrDatabaseDeleting
    default:
        return nil, ErrDatabaseNotFound
    }
}

// ValidateDatabase is a simpler version that just checks if database is usable
func (s *Service) ValidateDatabase(ctx context.Context, identifier string) error {
    _, err := s.ResolveDatabase(ctx, identifier)
    return err
}
```

### 4.4 Cache Implementation

```go
package database

import (
    "context"
    "time"

    lru "github.com/hashicorp/golang-lru/v2"
)

type Cache struct {
    store         DatabaseStore
    idCache       *lru.Cache[string, *cacheEntry]   // Keyed by ID
    slugCache     *lru.Cache[string, string]        // Maps slug -> ID
    negativeCache *lru.Cache[string, time.Time]     // Cache for non-existent lookups
    ttl           time.Duration
    negativeTTL   time.Duration
}

type cacheEntry struct {
    db        *Database
    expiresAt time.Time
}

func NewCache(store DatabaseStore, size int, ttl, negativeTTL time.Duration) (*Cache, error) {
    idCache, err := lru.New[string, *cacheEntry](size)
    if err != nil {
        return nil, err
    }
    slugCache, err := lru.New[string, string](size)
    if err != nil {
        return nil, err
    }
    negativeCache, err := lru.New[string, time.Time](size / 10)
    if err != nil {
        return nil, err
    }
    return &Cache{
        store:         store,
        idCache:       idCache,
        slugCache:     slugCache,
        negativeCache: negativeCache,
        ttl:           ttl,
        negativeTTL:   negativeTTL,
    }, nil
}

func (c *Cache) GetByID(ctx context.Context, id string) (*Database, error) {
    // Check ID cache
    if entry, ok := c.idCache.Get(id); ok {
        if time.Now().Before(entry.expiresAt) {
            return entry.db, nil
        }
        c.idCache.Remove(id)
    }

    // Check negative cache
    cacheKey := "id:" + id
    if expiresAt, ok := c.negativeCache.Get(cacheKey); ok {
        if time.Now().Before(expiresAt) {
            return nil, ErrDatabaseNotFound
        }
        c.negativeCache.Remove(cacheKey)
    }

    // Fetch from store
    db, err := c.store.Get(ctx, id)
    if err == ErrDatabaseNotFound {
        c.negativeCache.Add(cacheKey, time.Now().Add(c.negativeTTL))
        return nil, err
    }
    if err != nil {
        return nil, err
    }

    // Add to caches
    c.addToCache(db)
    return db, nil
}

func (c *Cache) GetBySlug(ctx context.Context, slug string) (*Database, error) {
    // Check slug -> ID mapping
    if id, ok := c.slugCache.Get(slug); ok {
        if db, err := c.GetByID(ctx, id); err == nil {
            return db, nil
        }
        // ID no longer valid, remove slug mapping
        c.slugCache.Remove(slug)
    }

    // Check negative cache
    cacheKey := "slug:" + slug
    if expiresAt, ok := c.negativeCache.Get(cacheKey); ok {
        if time.Now().Before(expiresAt) {
            return nil, ErrDatabaseNotFound
        }
        c.negativeCache.Remove(cacheKey)
    }

    // Fetch from store
    db, err := c.store.GetBySlug(ctx, slug)
    if err == ErrDatabaseNotFound {
        c.negativeCache.Add(cacheKey, time.Now().Add(c.negativeTTL))
        return nil, err
    }
    if err != nil {
        return nil, err
    }

    // Add to caches
    c.addToCache(db)
    return db, nil
}

func (c *Cache) addToCache(db *Database) {
    c.idCache.Add(db.ID, &cacheEntry{
        db:        db,
        expiresAt: time.Now().Add(c.ttl),
    })
    if db.Slug != nil {
        c.slugCache.Add(*db.Slug, db.ID)
    }
    // Clear any negative cache entries
    c.negativeCache.Remove("id:" + db.ID)
    if db.Slug != nil {
        c.negativeCache.Remove("slug:" + *db.Slug)
    }
}

func (c *Cache) Invalidate(db *Database) {
    c.idCache.Remove(db.ID)
    if db.Slug != nil {
        c.slugCache.Remove(*db.Slug)
    }
}
```

**Cache behavior:**
- **Positive cache**: Stores existing databases with configurable TTL
- **Negative cache**: Stores "database not found" results with shorter TTL to prevent repeated DB queries for non-existent databases
- **Invalidation**: On create/delete, both positive and negative caches are cleared

## 5. Handler Registration

### 5.1 Current Handler Setup

```go
// Current setup (simplified)
mux.HandleFunc("GET /api/v1/databases/{database}/documents/{path...}",
    h.authenticated(h.authorized(h.handleGetDocument, "read")))
```

### 5.2 Updated Handler Setup

```go
// Add database validation middleware
dbValidator := database.NewDatabaseValidator(databaseService)

mux.Handle("GET /api/v1/databases/{database}/documents/{path...}",
    dbValidator.Middleware(
        h.authenticated(h.authorized(h.handleGetDocument, "read"))))

mux.Handle("POST /api/v1/databases/{database}/documents/{path...}",
    dbValidator.Middleware(
        h.authenticated(h.authorized(h.handleCreateDocument, "create"))))

// ... same for PUT, PATCH, DELETE

mux.Handle("POST /api/v1/databases/{database}/query",
    dbValidator.Middleware(
        h.authenticated(h.authorized(h.handleQuery, "read"))))
```

### 5.3 Helper Function

```go
func (h *Handler) withDatabaseValidation(handler http.Handler) http.Handler {
    return h.dbValidator.Middleware(handler)
}

// Usage
mux.Handle("GET /api/v1/databases/{database}/documents/{path...}",
    h.withDatabaseValidation(
        h.authenticated(h.authorized(h.handleGetDocument, "read"))))
```

## 6. Error Responses

### 6.1 Database Not Found

```http
GET /api/v1/databases/nonexistent/documents/users/123
```

```json
{
    "error": {
        "code": "database_not_found",
        "message": "Database 'nonexistent' does not exist"
    }
}
```
HTTP Status: `404 Not Found`

### 6.2 Database Suspended

```http
GET /api/v1/databases/suspended-db/documents/users/123
```

```json
{
    "error": {
        "code": "database_suspended",
        "message": "Database 'suspended-db' is suspended"
    }
}
```
HTTP Status: `403 Forbidden`

### 6.3 Database Deleting

```http
GET /api/v1/databases/deleting-db/documents/users/123
```

```json
{
    "error": {
        "code": "database_deleting",
        "message": "Database 'deleting-db' is being deleted"
    }
}
```
HTTP Status: `410 Gone`

## 7. Realtime/WebSocket Integration

### 7.1 Watch Endpoint

```
WS /api/v1/databases/{database}/watch
```

Database validation occurs:
1. On connection establishment
2. Periodically during long-lived connections (optional)

### 7.2 Implementation

```go
func (h *Handler) handleWatch(w http.ResponseWriter, r *http.Request) {
    databaseID := r.PathValue("database")

    // Validate before upgrade
    if err := h.databaseService.ValidateDatabase(r.Context(), databaseID); err != nil {
        // Return error before WebSocket upgrade
        writeError(w, http.StatusNotFound, "database_not_found", err.Error())
        return
    }

    // Upgrade to WebSocket
    conn, err := h.upgrader.Upgrade(w, r, nil)
    if err != nil {
        return
    }
    defer conn.Close()

    // ... handle watch
}
```

## 8. gRPC Integration

### 8.1 Query Service

For internal gRPC calls, database validation is performed at the gateway level before forwarding to Query Service.

```go
// Gateway validates database, then calls Query Service
func (h *Handler) handleQuery(w http.ResponseWriter, r *http.Request) {
    // Database already validated by middleware
    databaseID := r.PathValue("database")

    // Forward to Query Service (gRPC)
    resp, err := h.queryClient.Query(r.Context(), &pb.QueryRequest{
        Database: databaseID,
        // ...
    })
    // ...
}
```

### 8.2 Internal Services

Internal services trust database validation from Gateway:
- Query Service
- Streamer Service
- Puller Service

No additional validation needed in internal service-to-service calls.

## 9. Migration Phases

### 9.1 Phase 1: Logging Only (Non-Breaking)

```go
func (v *DatabaseValidator) MiddlewareLogging(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        databaseID := r.PathValue("database")

        err := v.service.ValidateDatabase(r.Context(), databaseID)
        if err != nil {
            // Log but don't block
            log.Warn("unregistered database access",
                "database", databaseID,
                "path", r.URL.Path,
                "error", err)
        }

        // Always proceed
        next.ServeHTTP(w, r)
    })
}
```

### 9.2 Phase 2: Warning Header

```go
func (v *DatabaseValidator) MiddlewareWarning(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        databaseID := r.PathValue("database")

        err := v.service.ValidateDatabase(r.Context(), databaseID)
        if err != nil {
            // Add warning header but proceed
            w.Header().Set("X-Database-Warning",
                "Database not registered. This will be required in future versions.")
        }

        next.ServeHTTP(w, r)
    })
}
```

### 9.3 Phase 3: Full Enforcement

Use the full middleware implementation from Section 4.1.

## 10. Performance Considerations

### 10.1 Cache Configuration

```yaml
database:
  cache:
    size: 1000      # Max cached databases
    ttl: 5m         # Cache entry TTL
```

### 10.2 Expected Performance

| Operation | Cached | Uncached |
|-----------|--------|----------|
| ValidateDatabase | <1ms | 1-5ms |
| Cache hit rate (steady state) | >99% | - |

### 10.3 Cache Warming

On startup, optionally preload active databases:

```go
func (c *Cache) Warm(ctx context.Context) error {
    databases, _, err := c.store.List(ctx, ListOptions{
        Status: StatusActive,
        Limit:  1000,
    })
    if err != nil {
        return err
    }

    for _, db := range databases {
        c.addToCache(db)
    }

    return nil
}
```

## 11. Testing

### 11.1 Unit Tests

```go
func TestDatabaseValidationMiddleware(t *testing.T) {
    tests := []struct {
        name           string
        databaseID     string
        databaseStatus DatabaseStatus
        expectedCode   int
    }{
        {"active database", "my-db", StatusActive, 200},
        {"nonexistent database", "missing", "", 404},
        {"suspended database", "suspended-db", StatusSuspended, 403},
        {"deleting database", "deleting-db", StatusDeleting, 410},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // ... test implementation
        })
    }
}
```

### 11.2 Integration Tests

- Create database → perform document operations → verify success
- Delete database → attempt document operation → verify rejection
- Suspend database → attempt document operation → verify rejection
- High concurrency validation with cache

## 12. Related Documents

- [01.architecture.md](01.architecture.md) - Architecture overview
- [02.api.md](02.api.md) - API endpoints design
- [03.schema.md](03.schema.md) - PostgreSQL schema design
- [../../gateway/restful_api.md](../../gateway/restful_api.md) - REST API design
- [../../gateway/realtime_watching.md](../../gateway/realtime_watching.md) - Realtime watching
