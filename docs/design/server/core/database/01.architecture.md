# Database Management Architecture

**Date:** January 2026
**Status:** Draft
**Scope:** Logical database lifecycle management - creation, listing, deletion, and metadata storage.

## 1. Context & Problem

### Current State
- Logical databases exist implicitly: any `database` string in API requests is accepted
- No registration or validation of database names
- No metadata storage (creation time, owner, description, quotas)
- No API to list available databases
- No lifecycle management (create/delete)
- Configuration file `storage.databases` section maps logical database names to physical backends (not metadata storage)

### Why This Matters
- **Discoverability**: Users cannot list their available databases
- **Governance**: No control over database creation (anyone can use any name)
- **Auditing**: No record of when databases were created or by whom
- **Resource Management**: Cannot enforce quotas or limits per database
- **Cleanup**: No way to delete a database and its data

## 2. Requirements

### Functional
1. **Database Registration**: Databases must be explicitly created before use
2. **Database Listing**: Users can list databases they have access to
3. **Database Deletion**: Databases can be deleted (with all contained data)
4. **Metadata Storage**: Store creation time, owner, description, settings
5. **Validation**: Reject operations on non-existent databases

### Non-Functional
1. **Backward Compatibility**: Existing `default` database continues to work
2. **Performance**: Database existence check must be fast (cached)
3. **Consistency**: Database metadata stored in reliable backend (PostgreSQL)

## 3. Architecture Overview

### 3.1 Component Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                         Gateway Layer                            │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  │
│  │ User API        │  │ Admin API       │  │ Document API    │  │
│  │ /api/v1/databases│  │ /admin/databases│  │ /api/v1/databases│  │
│  │                 │  │                 │  │ /{db}/documents │  │
│  └────────┬────────┘  └────────┬────────┘  └────────┬────────┘  │
└───────────┼─────────────────────┼─────────────────────┼──────────┘
            │                     │                     │
            ▼                     ▼                     ▼
┌─────────────────────────────────────────────────────────────────┐
│                      Database Service                            │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    Service Layer                         │    │
│  │  - CreateDatabase (with quota check)                     │    │
│  │  - ListDatabases (owner filter)                          │    │
│  │  - GetDatabase / UpdateDatabase / DeleteDatabase         │    │
│  │  - ValidateDatabase (for document operations)            │    │
│  └─────────────────────────┬───────────────────────────────┘    │
│                            │                                     │
│  ┌─────────────────────────▼───────────────────────────────┐    │
│  │                    Cache Layer                           │    │
│  │  - LRU cache for existence checks                        │    │
│  │  - TTL-based expiry                                      │    │
│  │  - Invalidation on create/delete                         │    │
│  └─────────────────────────┬───────────────────────────────┘    │
│                            │                                     │
│  ┌─────────────────────────▼───────────────────────────────┐    │
│  │                  DatabaseStore                           │    │
│  │  - CRUD operations                                       │    │
│  │  - CountByOwner (quota)                                  │    │
│  │  - Exists (validation)                                   │    │
│  └─────────────────────────┬───────────────────────────────┘    │
└────────────────────────────┼────────────────────────────────────┘
                             │
                             ▼
                    ┌─────────────────┐
                    │   PostgreSQL    │
                    │   (databases)   │
                    └─────────────────┘
```

### 3.2 Database Entity

```go
type Database struct {
    ID          string            // Auto-generated hex ID (e.g., "a1b2c3d4e5f67890")
    Slug        *string           // Optional URL-friendly identifier (e.g., "my-app-prod")
    DisplayName string            // Human-readable name
    Description string            // Optional description
    OwnerID     string            // User ID of creator
    CreatedAt   time.Time         // Creation timestamp
    UpdatedAt   time.Time         // Last modification timestamp
    Settings    DatabaseSettings  // Per-database configuration
    Status      DatabaseStatus    // active, suspended, deleting
}

type DatabaseSettings struct {
    MaxDocuments    int64  // 0 = unlimited
    MaxStorageBytes int64  // 0 = unlimited
    // Future: retention policies, replication settings, etc.
}

type DatabaseStatus string

const (
    DatabaseStatusActive    DatabaseStatus = "active"
    DatabaseStatusSuspended DatabaseStatus = "suspended"
    DatabaseStatusDeleting  DatabaseStatus = "deleting"
)
```

### 3.3 Database Identification

Databases have two identifiers:

| Identifier | Format | Purpose | Mutability |
|------------|--------|---------|------------|
| `id` | 16-char hex (auto-generated) | Internal reference, primary key | Immutable |
| `slug` | 3-63 chars, `^[a-z][a-z0-9-]{2,62}$` | URL-friendly access | Immutable once set |

**ID Generation:**
```
id = hex(blake3(uuid())[:8])
```

**Slug Rules:**
- Optional at creation, can be added later
- Once set, cannot be changed
- Must start with lowercase letter
- Only lowercase letters, digits, and hyphens allowed
- Length: 3-63 characters
- Globally unique
- Reserved slugs: `default`, `admin`, `system`, `api`, `auth`

**URL Routing:**
- Slug access: `/api/v1/databases/my-app/documents/...`
- ID access (with prefix): `/api/v1/databases/id:a1b2c3d4e5f67890/documents/...`
- Resolution: if identifier starts with `id:`, lookup by ID; otherwise, lookup by slug

**Implementation:**
```go
import (
    "encoding/hex"

    "github.com/google/uuid"
    "github.com/zeebo/blake3"
)

func GenerateDatabaseID() string {
    u := uuid.New()
    hash := blake3.Sum256(u[:])
    return hex.EncodeToString(hash[:8])
}
```

**Note:** This uses the same hashing approach as UserStore (see `internal/core/storage/postgres/user_store.go`).

### 3.4 Storage Location

**PostgreSQL** (same as UserStore):
- Reliable, transactional storage for metadata
- Consistent with user management approach
- Table: `databases`
- **Note:** No foreign key to `auth_users` - tables may reside in different PostgreSQL instances

**Why not MongoDB?**
- Database metadata is system-critical configuration
- Needs strong consistency guarantees
- Low volume, high importance data
- Aligns with UserStore placement

### 3.5 Configuration

The database service configuration integrates with the existing storage topology pattern.

**Storage Topology Extension** (in `storage.topology`):
```yaml
storage:
  topology:
    # ... existing document, user, revocation ...
    database:
      strategy: "single"
      primary: "default_postgres"
      collection: "databases"
```

**Database Service Configuration** (new top-level section):
```yaml
database:
  # Maximum databases a regular user can create (default: 3)
  max_databases_per_user: 3

  # Cache configuration
  cache:
    size: 1000      # Max cached databases
    ttl: 5m         # Cache entry TTL
    negative_ttl: 1m # TTL for "not found" cache entries

  # Deletion worker configuration
  deletion:
    interval: 1m      # How often to check for databases pending deletion
    batch_size: 1000  # Documents to delete per batch
```

**Go Config Struct:**
```go
type Config struct {
    MaxDatabasesPerUser int            `yaml:"max_databases_per_user"`
    Cache               CacheConfig    `yaml:"cache"`
    Deletion            DeletionConfig `yaml:"deletion"`
}

type CacheConfig struct {
    Size        int           `yaml:"size"`
    TTL         time.Duration `yaml:"ttl"`
    NegativeTTL time.Duration `yaml:"negative_ttl"`
}

type DeletionConfig struct {
    Interval  time.Duration `yaml:"interval"`
    BatchSize int           `yaml:"batch_size"`
}

func DefaultConfig() Config {
    return Config{
        MaxDatabasesPerUser: 3,
        Cache: CacheConfig{
            Size:        1000,
            TTL:         5 * time.Minute,
            NegativeTTL: 1 * time.Minute,
        },
        Deletion: DeletionConfig{
            Interval:  1 * time.Minute,
            BatchSize: 1000,
        },
    }
}
```

**Notes:**
- System admin bypasses quota limit
- `default` database (owned by `syntrix`) does not count against user quotas
- Set `max_databases_per_user` to `0` to disable user database creation (admin-only mode)

## 4. Core Interfaces

### 4.1 DatabaseStore Interface

```go
type DatabaseStore interface {
    // Create registers a new database
    Create(ctx context.Context, db *Database) error

    // Get retrieves database by ID
    Get(ctx context.Context, id string) (*Database, error)

    // List returns all databases (with optional filters)
    List(ctx context.Context, opts ListOptions) ([]*Database, int, error)

    // Update modifies database metadata
    Update(ctx context.Context, db *Database) error

    // Delete removes database metadata (data cleanup separate)
    Delete(ctx context.Context, id string) error

    // Exists checks if database is registered (for fast validation)
    Exists(ctx context.Context, id string) (bool, error)

    // CountByOwner returns number of databases owned by a user (for quota check)
    CountByOwner(ctx context.Context, ownerID string) (int, error)

    // EnsureIndexes creates required indexes
    EnsureIndexes(ctx context.Context) error

    // Close releases resources
    Close(ctx context.Context) error
}

type ListOptions struct {
    Owner  string         // Filter by owner
    Status DatabaseStatus // Filter by status
    Limit  int
    Offset int
}
```

### 4.2 Service Interface

```go
type Service interface {
    // CreateDatabase creates a new database (with quota check for non-admin)
    CreateDatabase(ctx context.Context, userID string, isAdmin bool, req CreateRequest) (*Database, error)

    // ListDatabases returns databases visible to the user
    ListDatabases(ctx context.Context, userID string, isAdmin bool, opts ListOptions) (*ListResult, error)

    // GetDatabase retrieves database details
    GetDatabase(ctx context.Context, userID string, isAdmin bool, id string) (*Database, error)

    // UpdateDatabase modifies database metadata
    UpdateDatabase(ctx context.Context, userID string, isAdmin bool, id string, req UpdateRequest) (*Database, error)

    // DeleteDatabase initiates database deletion
    DeleteDatabase(ctx context.Context, userID string, isAdmin bool, id string) error

    // ValidateDatabase checks if database exists and is active (for document operations)
    ValidateDatabase(ctx context.Context, id string) error

    // EnsureDefaultDatabase creates default database on startup
    EnsureDefaultDatabase(ctx context.Context) error
}
```

### 4.3 Error Types

```go
type ErrQuotaExceeded struct {
    Used  int
    Limit int
}

func (e ErrQuotaExceeded) Error() string {
    return fmt.Sprintf("maximum database limit reached (%d/%d)", e.Used, e.Limit)
}

var (
    ErrDatabaseNotFound   = errors.New("database not found")
    ErrDatabaseExists     = errors.New("database already exists")
    ErrDatabaseSuspended  = errors.New("database is suspended")
    ErrDatabaseDeleting   = errors.New("database is being deleted")
    ErrInvalidRequest     = errors.New("invalid request")
    ErrNotOwner           = errors.New("not database owner")
    ErrProtectedDatabase  = errors.New("cannot modify protected database")
)
```

## 5. Key Flows

### 5.1 Database Creation Flow

```
User Request
     │
     ▼
┌─────────────────┐
│ Validate Request│ ──invalid──▶ 400 Bad Request
│ (display_name)  │
└────────┬────────┘
         │ valid
         ▼
┌─────────────────┐
│ Check Quota     │ ──exceeded──▶ 403 Quota Exceeded
│ (non-admin)     │
└────────┬────────┘
         │ within limit
         ▼
┌─────────────────┐
│ Generate ID     │
│ (auto)          │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Create in Store │
└────────┬────────┘
         │ success
         ▼
┌─────────────────┐
│ Add to Cache    │
└────────┬────────┘
         │
         ▼
    201 Created
```

### 5.2 Database Deletion Flow

```
Delete Request
     │
     ▼
┌─────────────────┐
│ Check Owner     │ ──not owner──▶ 403 Forbidden
│ (or admin)      │
└────────┬────────┘
         │ authorized
         ▼
┌─────────────────┐
│ Check Protected │ ──default──▶ 400 Protected
└────────┬────────┘
         │ ok
         ▼
┌─────────────────┐
│ Set Status =    │
│ "deleting"      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Invalidate      │
│ Cache           │
└────────┬────────┘
         │
         ▼
    200 OK (async)
         │
         ▼ (background)
┌─────────────────┐
│ Delete all      │
│ documents       │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Delete indexes  │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Delete metadata │
└─────────────────┘
```

### 5.3 Background Deletion Task

The background deletion task is implemented as a periodic job that processes databases in `deleting` status:

```go
type DeletionWorker struct {
    dbStore       DatabaseStore
    documentStore DocumentStore
    indexer       IndexerClient
    interval      time.Duration
}

func (w *DeletionWorker) Run(ctx context.Context) {
    ticker := time.NewTicker(w.interval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return
        case <-ticker.C:
            w.processDeletedDatabases(ctx)
        }
    }
}

func (w *DeletionWorker) processDeletedDatabases(ctx context.Context) {
    // List databases with status = 'deleting'
    databases, _, _ := w.dbStore.List(ctx, ListOptions{
        Status: StatusDeleting,
        Limit:  10,
    })

    for _, db := range databases {
        // Delete all documents in batches
        for {
            deleted, err := w.documentStore.DeleteByDatabase(ctx, db.ID, 1000)
            if err != nil || deleted == 0 {
                break
            }
        }

        // Invalidate indexes
        w.indexer.InvalidateDatabase(ctx, db.ID)

        // Hard delete metadata
        w.dbStore.Delete(ctx, db.ID)
    }
}
```

**Configuration:**
```yaml
database:
  deletion:
    interval: 1m        # Check interval
    batch_size: 1000    # Documents per batch
```

### 5.4 Default Database Bootstrap

On startup, ensure `default` database exists. This follows the same pattern as `ensureAdminUser()` in `internal/services/manager_init.go`.

```go
// Called after ensureAdminUser() in Manager.Init()
func (s *Service) EnsureDefaultDatabase(ctx context.Context) error {
    // Get syntrix admin user ID
    adminUser, err := s.userStore.GetUserByUsername(ctx, "syntrix")
    if err != nil {
        return fmt.Errorf("cannot create default database: syntrix admin user not found: %w", err)
    }

    // Check if default database exists by slug
    _, err = s.store.GetBySlug(ctx, "default")
    if err == ErrDatabaseNotFound {
        slug := "default"
        return s.store.Create(ctx, &Database{
            ID:          GenerateDatabaseID(), // Auto-generated, not "default"
            Slug:        &slug,                // "default" is the slug
            DisplayName: "Default Database",
            Description: "System default database",
            OwnerID:     adminUser.ID,
            Status:      DatabaseStatusActive,
        })
    }
    return err
}
```

**Initialization Order** (in `manager_init.go`):
1. `initAuthService()` - Initialize auth service
2. `ensureAdminUser()` - Create `syntrix` admin user
3. `initDatabaseService()` - Initialize database service
4. `EnsureDefaultDatabase()` - Create database with slug `default`, owned by `syntrix`

**Note:** The `default` database has an auto-generated ID and uses `default` as its slug. It is owned by the `syntrix` admin user.

## 6. Authorization

### 6.1 Database Access Model

There are two distinct authorization scopes:

1. **Database Management** - Who can create/update/delete database metadata
2. **Database Usage** - Who can perform document operations within a database

**Key principle:** Any user can *use* any database for document operations (subject to security rules), but only the owner can *manage* the database metadata.

### 6.2 Relationship with `db_admin` Field

The existing `db_admin` field in user tokens grants **document operation bypass** for specific databases (see [identity/02.authentication.md](../identity/02.authentication.md)). This is separate from database ownership:

| Concept | Purpose | Scope |
|---------|---------|-------|
| **Database Owner** (`owner_id`) | Manages database metadata (update, delete) | Database management APIs |
| **Database Admin** (`db_admin[]`) | Bypasses authz rules for document operations | Document CRUD operations |

**Important: Owner Implicit db_admin**

Database owners automatically have `db_admin` privileges for their databases. This is enforced at the authorization layer (not stored in the user record):

```go
// In authz middleware
func isDBAdmin(userID string, dbAdmin []string, database *Database) bool {
    // Owner implicitly has db_admin for their databases
    if database.OwnerID == userID {
        return true
    }
    // Check explicit db_admin list
    for _, db := range dbAdmin {
        if db == database.ID || db == *database.Slug {
            return true
        }
    }
    return false
}
```

A user can also be explicitly granted `db_admin` for databases they don't own.

### 6.3 User API (`/api/v1/databases`)

| Action | Permission |
|--------|------------|
| Create database | Authenticated user (within quota) |
| List databases | Authenticated user (own databases only) |
| Get database | Owner only |
| Update database | Owner only |
| Delete database | Owner only |

### 6.4 Admin API (`/admin/databases`)

| Action | Permission |
|--------|------------|
| Create database | System admin (no quota limit) |
| List databases | System admin (all databases) |
| Get database | System admin |
| Update database | System admin |
| Delete database | System admin |

### 6.5 Document Operations (`/api/v1/databases/{database}/...`)

| Action | Permission |
|--------|------------|
| Use database (CRUD) | Database exists AND status is active AND (owner OR db_admin OR authorized by security rules) |

**Note:** Users do not need to own a database to use it for document operations. The `default` database is accessible to all users (subject to security rules).

## 7. Migration Path

### Phase 1: Add Infrastructure (non-breaking)
1. Add `databases` table to PostgreSQL
2. Implement `DatabaseStore` interface
3. Bootstrap `default` database on startup
4. Add admin and user APIs (optional use)

### Phase 2: Soft Enforcement (warning)
1. Log warnings for operations on unregistered databases
2. Allow operations to proceed (backward compatible)
3. Monitor usage patterns

### Phase 3: Hard Enforcement (breaking)
1. Reject operations on unregistered databases
2. Require explicit database creation
3. Document migration steps for users

## 8. Testing Plan

### Unit Tests
- DatabaseStore CRUD operations
- Naming validation (valid/invalid patterns)
- Cache behavior (hit/miss/invalidation)
- Quota enforcement logic

### Integration Tests
- Create database → use for documents → delete database
- Concurrent database creation with same ID
- Database deletion cleanup verification
- Authorization checks for database operations
- User quota enforcement (create up to limit, reject at limit)
- Admin bypass quota limit

### Edge Cases
- Delete database while documents are being written
- Create database with reserved name
- List databases with pagination
- Cache consistency under concurrent updates
- User deletes database then creates new one (quota recovery)
- Multiple users creating databases concurrently

## 9. Open Questions

1. **Soft delete period?** Should deleted databases be recoverable for N days?
2. **Database transfer?** Allow changing owner_id?
3. **Cross-database references?** Allow or strictly forbid?
4. **Quota usage tracking?** How to track current document count and storage usage per database for enforcing `max_documents` and `max_storage_bytes`?

## 10. Related Documents

- [02.api.md](02.api.md) - API endpoints design
- [03.schema.md](03.schema.md) - PostgreSQL schema design
- [04.integration.md](04.integration.md) - Integration with document operations
- [../storage/05.multi-database.md](../storage/05.multi-database.md) - Multi-database storage design
- [../identity/03.authorization.md](../identity/03.authorization.md) - Authorization rules
