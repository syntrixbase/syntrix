# Database Lifecycle: Suspend and Delete

**Date:** January 2026
**Status:** Draft
**Scope:** Database suspension and deletion operations, including background cleanup.

## 1. Overview

This document covers the lifecycle operations that change database availability:
- **Suspend**: Temporarily disable a database (reversible)
- **Delete**: Permanently remove a database and all its data (irreversible)

## 2. Database Status States

```
                    ┌─────────┐
                    │ active  │ ◄─── Normal operation
                    └────┬────┘
                         │
            ┌────────────┼────────────┐
            │            │            │
            ▼            │            ▼
     ┌───────────┐       │     ┌───────────┐
     │ suspended │ ◄─────┘     │ deleting  │ ──► (removed)
     └───────────┘             └───────────┘
            │                        ▲
            │                        │
            └────────────────────────┘
```

| Status | Description | Document Operations | Reversible |
|--------|-------------|---------------------|------------|
| `active` | Normal operation | Allowed | - |
| `suspended` | Temporarily disabled | Rejected (403) | Yes |
| `deleting` | Pending deletion | Rejected (410) | No |

## 3. Suspend Operation

### 3.1 Purpose

Suspension temporarily disables a database without deleting data. Use cases:
- Billing issues (payment overdue)
- Policy violations
- Maintenance windows
- User request (vacation mode)

### 3.2 Suspend Flow

```
Suspend Request (Admin only)
     │
     ▼
┌─────────────────┐
│ Check Admin     │ ──not admin──▶ 403 Forbidden
└────────┬────────┘
         │ authorized
         ▼
┌─────────────────┐
│ Check Status    │ ──already suspended──▶ 200 OK (no-op)
│                 │ ──deleting──▶ 400 Bad Request
└────────┬────────┘
         │ active
         ▼
┌─────────────────┐
│ Set Status =    │
│ "suspended"     │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Update Cache    │
└────────┬────────┘
         │
         ▼
    200 OK
```

### 3.3 Suspend API

**Request**
```http
PATCH /admin/databases/a1b2c3d4e5f67890
Content-Type: application/json
Authorization: Bearer <admin-token>

{
    "status": "suspended"
}
```

**Response (200 OK)**
```json
{
    "id": "a1b2c3d4e5f67890",
    "display_name": "Customer Database",
    "status": "suspended",
    "updated_at": "2026-01-23T12:00:00Z"
}
```

### 3.4 Impact on Document Operations

When a database is suspended, all document operations return 403 Forbidden:

```http
GET /api/v1/databases/a1b2c3d4e5f67890/documents/users/123
```

```json
{
    "error": {
        "code": "database_suspended",
        "message": "Database 'a1b2c3d4e5f67890' is suspended"
    }
}
```

### 3.5 Resume (Unsuspend)

**Request**
```http
PATCH /admin/databases/a1b2c3d4e5f67890
Content-Type: application/json
Authorization: Bearer <admin-token>

{
    "status": "active"
}
```

**Response (200 OK)**
```json
{
    "id": "a1b2c3d4e5f67890",
    "display_name": "Customer Database",
    "status": "active",
    "updated_at": "2026-01-23T14:00:00Z"
}
```

## 4. Delete Operation

### 4.1 Purpose

Deletion permanently removes a database and all its data:
- All documents in the database
- All indexes for the database
- Database metadata

**Warning:** This operation is irreversible.

### 4.2 Delete Flow

```
Delete Request
     │
     ▼
┌─────────────────┐
│ Check Owner     │ ──not owner/admin──▶ 403 Forbidden
└────────┬────────┘
         │ authorized
         ▼
┌─────────────────┐
│ Check Protected │ ──default db──▶ 400 Protected Database
└────────┬────────┘
         │ ok
         ▼
┌─────────────────┐
│ Check Status    │ ──already deleting──▶ 200 OK (no-op)
└────────┬────────┘
         │ active or suspended
         ▼
┌─────────────────┐
│ Set Status =    │
│ "deleting"      │
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Invalidate      │
│ Cache           │
└────────┬────────┘
         │
         ▼
    200 OK (accepted)
         │
         ▼ (async background)
┌─────────────────┐
│ Background      │
│ Cleanup Worker  │
└─────────────────┘
```

### 4.3 Delete API

**User API (Owner)**
```http
DELETE /api/v1/databases/a1b2c3d4e5f67890
Authorization: Bearer <user-token>
```

**Admin API**
```http
DELETE /admin/databases/a1b2c3d4e5f67890
Authorization: Bearer <admin-token>
```

**Response (200 OK)**
```json
{
    "id": "a1b2c3d4e5f67890",
    "status": "deleting",
    "message": "Database deletion initiated"
}
```

**Error: Protected Database**
```json
{
    "error": {
        "code": "protected_database",
        "message": "Cannot delete the 'default' database"
    }
}
```

### 4.4 Impact on Document Operations

When a database is in `deleting` status, all operations return 410 Gone:

```http
GET /api/v1/databases/a1b2c3d4e5f67890/documents/users/123
```

```json
{
    "error": {
        "code": "database_deleting",
        "message": "Database 'a1b2c3d4e5f67890' is being deleted"
    }
}
```

## 5. Background Deletion Worker

### 5.1 Why Background Worker?

Database deletion is handled asynchronously for several reasons:

| Synchronous Deletion Problem | Background Worker Solution |
|------------------------------|---------------------------|
| Large databases may take minutes to delete, causing HTTP timeout | Return immediately, process in background |
| Holds database connections during deletion | Batch processing with yields between batches |
| Deletion failure leaves data in inconsistent state | Worker can retry, auto-recovers after crash |
| Poor user experience (long wait) | User gets immediate response |

**Flow:**
1. User calls `DELETE /api/v1/databases/{id}`
2. API sets `status = 'deleting'` and returns `200 OK` immediately
3. Background worker periodically finds databases with `status = 'deleting'`
4. Worker deletes documents in batches, clears indexes, then hard-deletes metadata

### 5.2 Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Deletion Worker                           │
│                                                              │
│  ┌────────────────────────────────────────────────────────┐ │
│  │                    Periodic Ticker                      │ │
│  │                    (configurable interval)              │ │
│  └────────────────────────┬───────────────────────────────┘ │
│                           │                                  │
│                           ▼                                  │
│  ┌────────────────────────────────────────────────────────┐ │
│  │              Query databases with                       │ │
│  │              status = 'deleting'                        │ │
│  └────────────────────────┬───────────────────────────────┘ │
│                           │                                  │
│                           ▼                                  │
│  ┌────────────────────────────────────────────────────────┐ │
│  │              For each database:                         │ │
│  │              1. Delete documents (batched)              │ │
│  │              2. Invalidate indexes                      │ │
│  │              3. Delete metadata                         │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 5.3 Implementation

```go
package database

import (
    "context"
    "log/slog"
    "time"
)

type DeletionWorker struct {
    dbStore       DatabaseStore
    documentStore DocumentStore
    indexer       IndexerClient
    config        DeletionConfig
    logger        *slog.Logger
}

type DeletionConfig struct {
    Interval  time.Duration // How often to check for deleted databases
    BatchSize int           // Documents to delete per batch
}

func DefaultDeletionConfig() DeletionConfig {
    return DeletionConfig{
        Interval:  1 * time.Minute,
        BatchSize: 1000,
    }
}

func NewDeletionWorker(
    dbStore DatabaseStore,
    documentStore DocumentStore,
    indexer IndexerClient,
    config DeletionConfig,
    logger *slog.Logger,
) *DeletionWorker {
    return &DeletionWorker{
        dbStore:       dbStore,
        documentStore: documentStore,
        indexer:       indexer,
        config:        config,
        logger:        logger,
    }
}

// Run starts the deletion worker. Blocks until context is cancelled.
func (w *DeletionWorker) Run(ctx context.Context) {
    ticker := time.NewTicker(w.config.Interval)
    defer ticker.Stop()

    w.logger.Info("deletion worker started",
        "interval", w.config.Interval,
        "batch_size", w.config.BatchSize)

    for {
        select {
        case <-ctx.Done():
            w.logger.Info("deletion worker stopped")
            return
        case <-ticker.C:
            w.processDeletedDatabases(ctx)
        }
    }
}

func (w *DeletionWorker) processDeletedDatabases(ctx context.Context) {
    // List databases pending deletion
    databases, _, err := w.dbStore.List(ctx, ListOptions{
        Status: StatusDeleting,
        Limit:  10,
    })
    if err != nil {
        w.logger.Error("failed to list deleting databases", "error", err)
        return
    }

    for _, db := range databases {
        if err := w.deleteDatabase(ctx, db); err != nil {
            w.logger.Error("failed to delete database",
                "database_id", db.ID,
                "error", err)
            // Continue with next database
            continue
        }
        w.logger.Info("database deleted successfully", "database_id", db.ID)
    }
}

func (w *DeletionWorker) deleteDatabase(ctx context.Context, db *Database) error {
    // Step 1: Delete all documents in batches
    totalDeleted := 0
    for {
        deleted, err := w.documentStore.DeleteByDatabase(ctx, db.ID, w.config.BatchSize)
        if err != nil {
            return fmt.Errorf("delete documents: %w", err)
        }
        totalDeleted += deleted
        if deleted < w.config.BatchSize {
            break // No more documents
        }
        // Yield to prevent blocking
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
        }
    }
    w.logger.Debug("documents deleted",
        "database_id", db.ID,
        "count", totalDeleted)

    // Step 2: Invalidate indexes
    if err := w.indexer.InvalidateDatabase(ctx, db.ID); err != nil {
        return fmt.Errorf("invalidate indexes: %w", err)
    }

    // Step 3: Hard delete metadata
    if err := w.dbStore.Delete(ctx, db.ID); err != nil {
        return fmt.Errorf("delete metadata: %w", err)
    }

    return nil
}
```

### 5.4 DocumentStore Extension

The `DocumentStore` interface needs a new method for bulk deletion:

```go
type DocumentStore interface {
    // ... existing methods ...

    // DeleteByDatabase deletes up to `limit` documents belonging to the database.
    // Returns the number of documents actually deleted.
    DeleteByDatabase(ctx context.Context, database string, limit int) (int, error)
}
```

**MongoDB Implementation:**
```go
func (s *documentStore) DeleteByDatabase(ctx context.Context, database string, limit int) (int, error) {
    filter := bson.M{"database": database}

    // Find documents to delete
    cursor, err := s.collection.Find(ctx, filter, options.Find().SetLimit(int64(limit)).SetProjection(bson.M{"_id": 1}))
    if err != nil {
        return 0, err
    }
    defer cursor.Close(ctx)

    var ids []interface{}
    for cursor.Next(ctx) {
        var doc struct {
            ID string `bson:"_id"`
        }
        if err := cursor.Decode(&doc); err != nil {
            continue
        }
        ids = append(ids, doc.ID)
    }

    if len(ids) == 0 {
        return 0, nil
    }

    // Delete the documents
    result, err := s.collection.DeleteMany(ctx, bson.M{"_id": bson.M{"$in": ids}})
    if err != nil {
        return 0, err
    }

    return int(result.DeletedCount), nil
}
```

### 5.5 IndexerClient Extension

```go
type IndexerClient interface {
    // ... existing methods ...

    // InvalidateDatabase removes all index entries for a database.
    InvalidateDatabase(ctx context.Context, database string) error
}
```

## 6. Configuration

```yaml
database:
  max_databases_per_user: 3

  deletion:
    # How often to check for databases pending deletion
    interval: 1m

    # Number of documents to delete per batch
    batch_size: 1000

  cache:
    # Cache size for database lookups
    size: 1000

    # TTL for cached entries
    ttl: 5m

    # TTL for negative cache (database not found)
    negative_ttl: 1m
```

```go
type Config struct {
    MaxDatabasesPerUser int            `yaml:"max_databases_per_user"`
    Deletion            DeletionConfig `yaml:"deletion"`
    Cache               CacheConfig    `yaml:"cache"`
}

type DeletionConfig struct {
    Interval  time.Duration `yaml:"interval"`
    BatchSize int           `yaml:"batch_size"`
}

type CacheConfig struct {
    Size        int           `yaml:"size"`
    TTL         time.Duration `yaml:"ttl"`
    NegativeTTL time.Duration `yaml:"negative_ttl"`
}
```

## 7. Protected Databases

Certain databases cannot be deleted:

| Database | Reason |
|----------|--------|
| `default` | System default database, always required |

```go
func (s *Service) DeleteDatabase(ctx context.Context, userID string, isAdmin bool, id string) error {
    // Check protected databases
    if id == "default" {
        return ErrProtectedDatabase
    }

    // ... rest of delete logic
}
```

## 8. Permissions Summary

| Operation | User API | Admin API |
|-----------|----------|-----------|
| Suspend database | ❌ Not allowed | ✅ Admin only |
| Resume database | ❌ Not allowed | ✅ Admin only |
| Delete own database | ✅ Owner only | ✅ Any database |
| Delete others' database | ❌ Forbidden | ✅ Any database |

## 9. Testing Plan

### Unit Tests
- Suspend: active → suspended → active transitions
- Delete: status change to deleting
- Protected database rejection
- Permission checks (owner vs non-owner)

### Integration Tests
- Full deletion flow: delete request → background worker → verify cleanup
- Suspend → document operation rejected → resume → document operation allowed
- Concurrent deletion requests for same database
- Worker handles errors gracefully (partial deletion)

### Edge Cases
- Delete database while documents are being written
- Worker crash during deletion (resume on restart)
- Very large database deletion (millions of documents)
- Delete suspended database

## 10. Monitoring

### Metrics

| Metric | Type | Description |
|--------|------|-------------|
| `database_deletions_initiated_total` | Counter | Delete requests received |
| `database_deletions_completed_total` | Counter | Databases fully deleted |
| `database_deletion_duration_seconds` | Histogram | Time to fully delete a database |
| `database_deletion_documents_total` | Counter | Documents deleted |
| `database_suspensions_total` | Counter | Suspend operations |
| `database_resumptions_total` | Counter | Resume operations |

### Logging

```go
// Deletion initiated
logger.Info("database deletion initiated",
    "database_id", id,
    "owner_id", ownerID,
    "initiated_by", userID)

// Deletion completed
logger.Info("database deleted successfully",
    "database_id", id,
    "documents_deleted", totalDeleted,
    "duration_ms", duration.Milliseconds())

// Suspension
logger.Info("database suspended",
    "database_id", id,
    "suspended_by", adminID)
```

## 11. Service Manager Integration

The DeletionWorker integrates with the existing Service Manager pattern in `internal/services/manager_start.go`.

### 11.1 Manager Fields

```go
// In internal/services/manager.go
type Manager struct {
    // ... existing fields ...

    databaseService  database.Service
    deletionWorker   *database.DeletionWorker
}
```

### 11.2 Initialization (manager_init.go)

```go
// In initStandalone or initDistributed
func (m *Manager) initDatabaseService(ctx context.Context) error {
    sf, err := m.getStorageFactory(ctx)
    if err != nil {
        return err
    }

    // Create database store
    dbStore := postgres.NewDatabaseStore(sf.PostgresDB(), "databases")

    // Create service with cache
    m.databaseService, err = database.NewService(
        dbStore,
        m.cfg.Database,
        slog.Default(),
    )
    if err != nil {
        return fmt.Errorf("failed to create database service: %w", err)
    }

    // Ensure default database exists
    if err := m.databaseService.EnsureDefaultDatabase(ctx); err != nil {
        return fmt.Errorf("failed to ensure default database: %w", err)
    }

    // Create deletion worker
    m.deletionWorker = database.NewDeletionWorker(
        dbStore,
        sf.Document(),
        m.indexerService,  // May be nil, worker handles gracefully
        m.cfg.Database.Deletion,
        slog.Default(),
    )

    slog.Info("Initialized Database Service")
    return nil
}
```

### 11.3 Startup (manager_start.go)

```go
func (m *Manager) Start(bgCtx context.Context) {
    // ... existing service startups ...

    // Start Deletion Worker
    if m.deletionWorker != nil {
        m.wg.Add(1)
        go func() {
            defer m.wg.Done()
            slog.Info("Starting Database Deletion Worker...")
            m.deletionWorker.Run(bgCtx)
        }()
    }
}
```

### 11.4 Shutdown

The deletion worker stops gracefully when the context is cancelled, following the same pattern as other background services.

## 12. Related Documents

- [01.architecture.md](01.architecture.md) - Architecture overview
- [02.api.md](02.api.md) - API endpoints design
- [03.schema.md](03.schema.md) - PostgreSQL schema design
- [04.integration.md](04.integration.md) - Integration with document operations
