# In-Memory PubSub for Standalone Mode

**Date:** February 2026
**Status:** Approved

## 1. Overview

Implement in-memory pubsub for Standalone mode, replacing NATS dependency for simplified deployment.

### Why

| Problem | Solution |
|---------|----------|
| Standalone still requires embedded NATS | Replace with pure in-memory implementation |
| Extra resource overhead | No external dependencies, lighter weight |
| Slow startup | No NATS initialization required |
| Complex testing | Unit tests don't need NATS |

### How

Implement in-memory versions of `pubsub.Publisher` and `pubsub.Consumer` interfaces, routing messages within the process through an internal broker. The API mirrors the NATS implementation to ensure consistent usage patterns.

## 2. Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                         Engine                               │
│  (Public API - mirrors NATS JetStream interface)            │
│                                                              │
│  ┌────────────────────────────────────────────────────────┐ │
│  │                    broker (internal)                    │ │
│  │  subscriptions: map[pattern]*subscription               │ │
│  │                                                         │ │
│  │  Publisher ──publish()──► match pattern ──► msgCh      │ │
│  │                                                         │ │
│  │  Consumer ◄── Subscribe() ◄── msgCh                    │ │
│  └────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### Data Flow

```
Evaluator                          Delivery
    │                                  ▲
    ▼                                  │
TaskPublisher                    TaskConsumer
    │                                  ▲
    ▼                                  │
memoryPublisher ──► broker ──► memoryConsumer
```

## 3. Design Decisions

### 3.1 Hide Broker Behind Engine

**Problem**: Exposing Broker as a separate concept leaks implementation details and differs from NATS API.

**Decision**: Engine wraps broker internally, providing factory methods that mirror NATS:

```go
// Memory - symmetric with NATS
engine := memory.New()
pub, _ := engine.NewPublisher(opts)
consumer, _ := engine.NewConsumer(opts)

// NATS
js, _ := nats.NewJetStream(conn)
pub, _ := nats.NewPublisher(js, opts)
consumer, _ := nats.NewConsumer(js, opts)
```

### 3.2 Single Consumer per Pattern

**Problem**: Fan-out semantics differ from NATS competing consumers.

**Decision**: Support only single consumer per pattern. This:
- Matches current Trigger use case (one Consumer)
- Simplifies implementation
- Consistent with NATS competing consumer behavior

For multiple consumers, use NATS implementation.

### 3.3 Safe NakWithDelay

**Problem**: `time.AfterFunc` goroutine may write to closed channel after broker shutdown.

**Decision**: Message holds reference to Engine and context. Check both before requeue:
- Check `engine.IsClosed()` before attempting requeue
- Respect context cancellation

### 3.4 Subject Matching

**Decision**: Support NATS-style wildcard matching:
- `*` matches a single token
- `>` matches all remaining tokens (must be at the end)

### 3.5 Idempotent Acknowledgment

**Decision**: All Ack/Nak/Term methods are idempotent - calling multiple times has no effect.

### 3.6 StreamName/ConsumerName Handling

**Decision**: These NATS-specific options are ignored in memory implementation (logged as debug). Only `SubjectPrefix` and `FilterSubject` are used.

### 3.7 Metrics Hook

**Decision**: Call `OnPublish` callback with latency including channel blocking time, consistent with NATS.

## 4. Comparison with NATS

| Aspect | NATS | Memory |
|--------|------|--------|
| Factory | `NewJetStream(conn)` | `New()` |
| Multiple consumers | Competing | Single per pattern |
| Persistence | Yes | No |
| Cross-process | Yes | No |
| NakWithDelay | JetStream managed | time.AfterFunc |

## 5. Limitations

1. **No persistence** - Messages lost on restart
2. **Single consumer per pattern** - Use NATS for multiple consumers
3. **Single process only** - No cross-process communication

These are acceptable for Standalone mode (dev/test/edge).

## 6. Related Documents

- [PubSub Architecture](README.md)
- [NATS Design](01.nats.md)
