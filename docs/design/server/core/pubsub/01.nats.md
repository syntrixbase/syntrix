# NATS JetStream Implementation

**Date:** February 2026
**Status:** Implemented

## 1. Overview

NATS JetStream implementation of the pubsub interfaces for distributed mode.

### Why

- **Persistence** - Messages survive service restarts
- **Durability** - Consumer position tracked, resume from last checkpoint
- **Scalability** - Multiple consumers across processes/machines
- **Reliability** - At-least-once delivery with acknowledgment

### How

Wrap NATS JetStream APIs to implement `pubsub.Publisher` and `pubsub.Consumer` interfaces.

## 2. Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    NATS JetStream                            │
│                                                              │
│  ┌─────────────────┐     ┌─────────────────────────────────┐ │
│  │  Stream         │     │  Durable Consumer               │ │
│  │  - TRIGGERS     │────►│  - delivery-worker              │ │
│  │  - storage type │     │  - tracks position              │ │
│  └─────────────────┘     │  - explicit ack policy          │ │
│                          └─────────────────────────────────┘ │
│                                                              │
│  Publisher ──Publish()──► Stream ──► Consumer ──► msgCh     │
└─────────────────────────────────────────────────────────────┘
```

## 3. Components

### 3.1 Connection (`connection.go`)

```go
// JetStream wraps the NATS JetStream interface.
type JetStream interface {
    Publish(ctx context.Context, subject string, data []byte) error
    CreateOrUpdateStream(ctx context.Context, cfg jetstream.StreamConfig) (jetstream.Stream, error)
    CreateOrUpdateConsumer(ctx context.Context, stream string, cfg jetstream.ConsumerConfig) (jetstream.Consumer, error)
    Stream(ctx context.Context, name string) (jetstream.Stream, error)
}

// NewJetStream creates a JetStream context from a NATS connection.
func NewJetStream(nc *nats.Conn) (JetStream, error)
```

### 3.2 Publisher (`publisher.go`)

```go
type jetStreamPublisher struct {
    js   JetStream
    opts pubsub.PublisherOptions
}

func NewPublisher(js JetStream, opts pubsub.PublisherOptions) (pubsub.Publisher, error)
```

**Features:**
- Auto-creates stream if not exists
- Subject prefix management
- Retry mechanism (configurable attempts)
- OnPublish callback for metrics

**Publish Flow:**
1. Apply subject prefix → `SubjectPrefix + "." + subject`
2. Ensure stream exists (idempotent create/update)
3. Publish to JetStream
4. Call OnPublish callback with latency

### 3.3 Consumer (`consumer.go`)

```go
type jetStreamConsumer struct {
    js      JetStream
    opts    pubsub.ConsumerOptions
    closing atomic.Bool
}

func NewConsumer(js JetStream, opts pubsub.ConsumerOptions) (pubsub.Consumer, error)
```

**Features:**
- Creates durable consumer (survives restarts)
- Explicit acknowledgment policy
- Subject filtering
- Buffered message channel
- Graceful shutdown

**Subscribe Flow:**
1. Create/update stream with filter subject
2. Create durable consumer (AckExplicitPolicy)
3. Start consume callback loop
4. Return message channel

### 3.4 Message (`message.go`)

```go
type natsMessage struct {
    msg jetstream.Msg
}

func WrapMessage(msg jetstream.Msg) pubsub.Message
```

Directly delegates to underlying NATS message methods.

## 4. Configuration

### PublisherOptions

| Field | Type | Description |
|-------|------|-------------|
| `StreamName` | string | JetStream stream name |
| `SubjectPrefix` | string | Prefix added to all subjects |
| `RetryAttempts` | int | Publish retry count (0 = no retry) |
| `Storage` | StorageType | Memory or File storage |
| `OnPublish` | callback | Called after each publish |

### ConsumerOptions

| Field | Type | Description |
|-------|------|-------------|
| `StreamName` | string | JetStream stream name |
| `ConsumerName` | string | Durable consumer name |
| `FilterSubject` | string | Subject filter pattern |
| `ChannelBufSize` | int | Message channel buffer (default: 100) |
| `Storage` | StorageType | Storage type |

## 5. Stream Configuration

```go
jetstream.StreamConfig{
    Name:      opts.StreamName,
    Subjects:  []string{opts.SubjectPrefix + ".>"},
    Storage:   jetstream.MemoryStorage, // or FileStorage
    Retention: jetstream.LimitsPolicy,
}
```

## 6. Consumer Configuration

```go
jetstream.ConsumerConfig{
    Name:          opts.ConsumerName,
    Durable:       opts.ConsumerName,
    AckPolicy:     jetstream.AckExplicitPolicy,
    FilterSubject: opts.FilterSubject,
}
```

## 7. Error Handling

### Publisher Errors

| Error | Handling |
|-------|----------|
| Connection error | Return error, caller retries |
| Stream not found | Auto-create stream |
| Timeout | Return error with context |

### Consumer Errors

| Error | Handling |
|-------|----------|
| Connection error | Close channel, caller reconnects |
| Message processing | Caller decides Ack/Nak/Term |

## 8. Graceful Shutdown

```go
func (c *jetStreamConsumer) shutdown() {
    c.closing.Store(true)
    // Nak any unprocessed messages
    // Stop consumer
    // Close message channel
}
```

## 9. Usage Example

```go
// Setup
nc, _ := nats.Connect("nats://localhost:4222")
js, _ := natspubsub.NewJetStream(nc)

// Publisher
pub, _ := natspubsub.NewPublisher(js, pubsub.PublisherOptions{
    StreamName:    "TRIGGERS",
    SubjectPrefix: "TRIGGERS",
    OnPublish: func(subject string, err error, latency time.Duration) {
        metrics.RecordPublish(subject, err, latency)
    },
})
defer pub.Close()

pub.Publish(ctx, "db1.users.doc123", jsonData)

// Consumer
consumer, _ := natspubsub.NewConsumer(js, pubsub.ConsumerOptions{
    StreamName:     "TRIGGERS",
    ConsumerName:   "delivery-worker",
    FilterSubject:  "TRIGGERS.>",
    ChannelBufSize: 100,
})

msgCh, _ := consumer.Subscribe(ctx)
for msg := range msgCh {
    task := parseTask(msg.Data())
    if err := deliver(task); err != nil {
        msg.Nak()
    } else {
        msg.Ack()
    }
}
```

## 10. Comparison with Memory Implementation

| Aspect | NATS | Memory |
|--------|------|--------|
| Persistence | ✓ | ✗ |
| Cross-process | ✓ | ✗ |
| Durable consumer | ✓ | ✗ |
| Retry management | JetStream | Simple requeue |
| Use case | Production | Dev/Test/Edge |
