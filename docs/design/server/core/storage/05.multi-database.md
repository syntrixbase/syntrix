# Multi-Database Storage (Hybrid Strategy)

## 1. Context & Goals
- Service not yet launched; we can define multi-database from day one.
- Default isolation: shared collections with strong row-level segregation via `database` (top-level field in Mongo documents).
- Allow upgrade path: select databases can be routed to dedicated Mongo backends (schema/DB-per-database) while long-tail stays shared.

## 2. Requirements
- Default database id: `"default"` (used when no database is provided or for first-party traffic).
- No migration needed (no prod data).
- Database must be an explicit input to all storage operations; no implicit globals.
- Reads/writes/queries/watch must never cross databases.
- Keep read/write split support; add per-database backend routing.

## 3. Current State (baseline)
- Storage interfaces lack database semantics; `_id` is a hash of `fullpath` only.
- Mongo stores filter by `_id`, `collection`, `deleted`; no `database` filter/index.
- Routers choose primary/replica only; no database-aware backend selection.

## 4. Design Overview (Why/How)
- Why hybrid: fast path is shared infra with low operational overhead; heavy databases can isolate onto their own backend for blast-radius and performance.
- How: add `database` to data model and APIs; enforce filters at store/query layer; extend factory/router to map databaseâ†’backend.

## 5. Data Model Changes (Mongo)
- Add top-level `database` to all collections (documents, users, revocations).
- ID strategy: `_id` is database-aware using prefix format, e.g. `_id = database + ":" + hash(fullpath)` (and similarly for users/revocations). This guarantees global uniqueness and allows regex-based filtering in Change Streams (Watch) for delete events.
- Indexes:
  - Documents: `_id` as primary; store `collection_hash` (using existing hash implementation) and index `(database, collection_hash)` for scans; keep TTL on `sys_expires_at` scoped by database; retain the plain `collection` field for readability/debug.
  - Users: unique `(database, username)`; `_id` generated with database namespace (e.g. `database + ":" + hash(user_id_source)`) to avoid cross-database collisions; `(database, username)` enforces per-database uniqueness.
  - Revocations: `_id` database-aware; TTL on `expires_at`; mandatory `(database, expires_at)` to support per-database sweeping.

## 6. API & Types Changes
- Interfaces (`DocumentStore`, `UserStore`, `TokenRevocationStore`) gain `database string` parameter on all operations; `Query` gains required `Database` field injected by callers.
- ID helpers become database-aware (e.g. `CalculateDatabase(database, fullpath)`); path-only helpers are deprecated to avoid cross-database collisions.
- Context objects (if introduced later) must still carry explicit database and be validated before store calls.

## 7. Routing & Factory
- Factory maintains map: `database -> backend binding`. Defaults to shared backend; config can mark databases as dedicated.
- Routers keep op-based selection (read/write split) per backend; database lookup happens before router selection.
- TODO: Define Read/Write split strategy for dedicated databases (currently assumes dedicated backend is a single connection or handles its own topology).
- Fail-closed: database-id is mandatory at API boundary; default database should be injected by callers. If database-id is empty or binding not found, storage layer returns an error to prevent cross-database access.

## 8. Mongo Store Behavior (How)
- CRUD/Query/Watch filters always include `database`.
- Soft delete and TTL updates set `database` in writes; queries exclude deleted by default and filter database.
- Watch: server-side pipeline filters by database using `database` field for inserts/updates, and `documentKey._id` prefix match (`^database:`) for deletes.
- EnsureIndexes creates compound indexes including `database`.

## 9. Configuration Additions (example)
```yaml
storage:
  databases:
    default:
      backend: default_mongo
    vip-database-a:
      backend: mongo_vip_a
  backends:
    default_mongo: {...}
    mongo_vip_a: {...}
  topology:
    document:
      strategy: read_write_split
      primary: default_mongo
      replica: default_mongo_replica
    user:
      strategy: single
      primary: default_mongo
    revocation:
      strategy: single
      primary: default_mongo
```
- `databases` maps database ids to backend names; unspecified databases fall back to `default` binding.
- Dedicated databases can point to different backend entries (DB-per-database or schema-per-database via distinct `database_name`).

## 10. Rollout & Compatibility
- No existing data: just deploy with new schema/index creation on startup.
- Backfill path: if needed later, set `database` = `default` for legacy docs.

## 11. Testing Plan (must add/extend)

- Unit tests for stores: database A cannot read/update/delete database B docs; query returns only matching database; watch emits only same-database events (including deletes via client-side guard when server match is limited).
- User/Revocation: username uniqueness enforced per database; revocation lookups are database-scoped; database-aware `_id` differs across databases for same logical path/ID source.
- Factory/router: database binding to dedicated backend; fallback to default; read/write split still respected per database; empty database-id must error.
- Index verification tests: `(database, collection_hash)` exists; TTL indexes remain; `_id` generation is database-aware (same path with different database yields different `_id`).

## 12. Next Steps (if approved)

- Update config structs to include database bindings; validate presence of default mapping.
- Extend interfaces and call sites to require database.
- Implement Mongo filters/indexes with `database`.
- Add tests per plan.
- Optional: add guard middleware to inject/validate database before storage calls.
